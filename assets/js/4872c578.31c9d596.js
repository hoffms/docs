"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[1650],{96826:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=n(83117),a=(n(67294),n(3905));const o={id:"range-orders",title:"Range Orders"},r=void 0,l={unversionedId:"sdk/v3/guides/advanced/range-orders",id:"sdk/v3/guides/advanced/range-orders",title:"Range Orders",description:"Introduction",source:"@site/docs/sdk/v3/guides/advanced/05-range-orders.md",sourceDirName:"sdk/v3/guides/advanced",slug:"/sdk/v3/guides/advanced/range-orders",permalink:"/docs/sdk/v3/guides/advanced/range-orders",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/sdk/v3/guides/advanced/05-range-orders.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"range-orders",title:"Range Orders"},sidebar:"sdkSidebar",previous:{title:"Uniswap as a Price Oracle",permalink:"/docs/sdk/v3/guides/advanced/price-oracle"},next:{title:"Overview",permalink:"/docs/sdk/v3/reference/overview"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Understanding Range Orders",id:"understanding-range-orders",level:2},{value:"Calculating the Tick Range",id:"calculating-the-tick-range",level:2},{value:"Upper Tick",id:"upper-tick",level:3},{value:"Lower Tick",id:"lower-tick",level:3},{value:"Creating the Single Side Liquidity Position",id:"creating-the-single-side-liquidity-position",level:2},{value:"Minting the Position",id:"minting-the-position",level:3},{value:"Getting the tokenId",id:"getting-the-tokenid",level:3},{value:"Observing the Price",id:"observing-the-price",level:2},{value:"Closing the Limit Order",id:"closing-the-limit-order",level:2},{value:"Caveats",id:"caveats",level:2},{value:"Next Steps",id:"next-steps",level:2}],c={toc:p};function d(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,i.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"This guide will cover how single-side liquidity provisioning can be used to execute ",(0,a.kt)("strong",{parentName:"p"},"Limit Orders")," on Uniswap V3 Pools.\nAn example to showcase this concept can be found in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/examples/tree/main/v3-sdk/range-order"},"Range Order example"),", in the Uniswap code examples ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/example"},"repository"),".\nTo run this example, check out the guide's ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/examples/blob/main/v3-sdk/price-oracle/README.md"},"README")," and follow the setup instructions."),(0,a.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"This guide builds on top of the ",(0,a.kt)("a",{parentName:"p",href:"/docs/sdk/v3/guides/liquidity/position-data"},"Pooling Liquidity guides"),".\nWe recommend going through this section of the docs before imnplementing Range Orders."))),(0,a.kt)("p",null,"In this example we will create a single-side liquidity position with the ",(0,a.kt)("a",{parentName:"p",href:"/docs/contracts/v3/reference/periphery/NonfungiblePositionManager"},"NonfungiblePositionManager")," contract.\nWe will then use ",(0,a.kt)("strong",{parentName:"p"},"ethers JS")," to observe the price of the Pool on new blocks and withdraw the liquidity when our target is reached."),(0,a.kt)("p",null,"This guide will ",(0,a.kt)("strong",{parentName:"p"},"cover"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Understanding Range Orders"),(0,a.kt)("li",{parentName:"ol"},"Calculating our Tick Range"),(0,a.kt)("li",{parentName:"ol"},"Creating a single-side liquidity position"),(0,a.kt)("li",{parentName:"ol"},"Observing the price of the Pool"),(0,a.kt)("li",{parentName:"ol"},"Closing the Limit Order")),(0,a.kt)("p",null,"Before working through this guide, consider checking out the Range Orders ",(0,a.kt)("a",{parentName:"p",href:"../../../../concepts/protocol/range-orders.md"},"concept page")," to understand how Limit orders can be executed with Uniswap V3."),(0,a.kt)("p",null,"For this guide, the following Uniswap packages are used:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/@uniswap/v3-sdk"},(0,a.kt)("inlineCode",{parentName:"a"},"@uniswap/v3-sdk"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/@uniswap/sdk-core"},(0,a.kt)("inlineCode",{parentName:"a"},"@uniswap/sdk-core")))),(0,a.kt)("p",null,"The core code of this guide can be found in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/examples/tree/main/v3-sdk/range-order/src/libs/range-order.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"range-order.ts")),"."),(0,a.kt)("h2",{id:"understanding-range-orders"},"Understanding Range Orders"),(0,a.kt)("p",null,"If you have read the ",(0,a.kt)("a",{parentName:"p",href:"../../../../concepts/protocol/range-orders.md"},"Range Order Concept page"),", you can skip this section."),(0,a.kt)("p",null,"Positions on a V3 Pool are always created with a Tick range in which their liquidity is accessible to swaps on the Pool.\nLets look at the return value of the NonfungiblePositionManager contract when calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"positions")," function with a Position ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenId"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function positions(\n    uint256 tokenId\n  ) external view returns (\n    uint96 nonce, \n    address operator, \n    address token0, \n    address token1, \n    uint24 fee, \n    int24 tickLower,    // Lower Boundary of Position\n    int24 tickUpper,    // Upper Boundary of Position\n    uint128 liquidity,  // Liquidity\n    uint256 feeGrowthInside0LastX128, \n    uint256 feeGrowthInside1LastX128, \n    uint128 tokensOwed0, \n    uint128 tokensOwed1\n    )\n")),(0,a.kt)("p",null,"We see that a position only stores a single ",(0,a.kt)("inlineCode",{parentName:"p"},"liquidity")," value, and a ",(0,a.kt)("inlineCode",{parentName:"p"},"tickLower")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"tickUpper")," value that define the range in which the liquidity of the Position can be utilised for Swaps.\nThe actual ",(0,a.kt)("strong",{parentName:"p"},"amount")," of ",(0,a.kt)("inlineCode",{parentName:"p"},"token0")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"token1")," that a Pool owes the Position owner is calculated from the parts of the liquidity position that are to the left and right of the current Tick.\nLiquidity left of the current Tick is denominated in ",(0,a.kt)("inlineCode",{parentName:"p"},"token0")," and liquidity right of the current Tick is denominated in ",(0,a.kt)("inlineCode",{parentName:"p"},"token1"),"."),(0,a.kt)("p",null,"If a new Position is created and the Tick Range of the position does not include the current Tick of the Pool, only one of the two Tokens in the Pool can be provided."),(0,a.kt)("p",null,"We will call this a ",(0,a.kt)("strong",{parentName:"p"},"Single Side Liquidity Position"),"."),(0,a.kt)("img",{src:n(35732).Z,alt:"RangeOrder","box-shadow":"none"}),(0,a.kt)("p",null,"When the current Tick of the Pool moves across the Position, the ratio of ",(0,a.kt)("inlineCode",{parentName:"p"},"token0")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"token1")," will change, and ultimately inverse if the current Tick moves out of the position on the other side."),(0,a.kt)("p",null,"We will utilise this behaviour to provide liquidity with ",(0,a.kt)("inlineCode",{parentName:"p"},"token1")," and withdraw the position when it has been converted to ",(0,a.kt)("inlineCode",{parentName:"p"},"token0"),"."),(0,a.kt)("h2",{id:"calculating-the-tick-range"},"Calculating the Tick Range"),(0,a.kt)("p",null,"Our goal for this guide is to create a ",(0,a.kt)("a",{parentName:"p",href:"../../../../concepts/protocol/range-orders.md#take-profit-orders"},"Take Profit Order")," that trades ",(0,a.kt)("inlineCode",{parentName:"p"},"token0")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"token1")," when the Price of ",(0,a.kt)("inlineCode",{parentName:"p"},"token0")," increases by 5%.\nTo create our Position, we need to first decide the Tick Range that we want to provide liquidity in."),(0,a.kt)("h3",{id:"upper-tick"},"Upper Tick"),(0,a.kt)("p",null,"We ",(0,a.kt)("a",{parentName:"p",href:"/docs/sdk/v3/guides/advanced/pool-data"},"create a Pool")," that represents the V3 Pool we are interacting with and get the ",(0,a.kt)("inlineCode",{parentName:"p"},"token0Price"),".\nWe won't need full tick data in this example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Pool } from '@uniswap/v3-sdk'\n\n... \nconst pool = new Pool(token0, token1, fee, sqrtPriceX96, liquidity, tickCurrent)\n\nconst currentPrice = pool.token0Price\n")),(0,a.kt)("p",null,"Next we increase the ",(0,a.kt)("inlineCode",{parentName:"p"},"Price")," by 5%. We create a new Price with a numerator 5% higher than our current Price:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Price, Fraction } from '@uniswap/sdk-core'\n\nconst targetFraction = Price.asFraction.multiply(new Fraction(100 + 5, 100))\n\nconst targetPrice = new Price(\n    currentPrice.baseCurrency,\n    currentPrice.quoteCurrency,\n    targetFraction.denominator,\n    targetFraction.numerator\n)\n")),(0,a.kt)("p",null,"Be aware that the ",(0,a.kt)("inlineCode",{parentName:"p"},"numerator")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"denominator")," parameters are ordered differently in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Fraction")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Price")," constructor."),(0,a.kt)("p",null,"We have calculated our target Price but we still need to find the ",(0,a.kt)("strong",{parentName:"p"},"nearest usable tick")," to create our Position."),(0,a.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"As Positions can only start and end at initializable Ticks of the Pool, so we can only create a Range Order to a Price that exactly matches an initializable Tick."))),(0,a.kt)("p",null,"We use the ",(0,a.kt)("inlineCode",{parentName:"p"},"priceToClosestTick")," function to find the closest tick to our targetPrice.\nWe then use the ",(0,a.kt)("inlineCode",{parentName:"p"},"nearestUsableTick")," function to find the closest initializable Tick for the ",(0,a.kt)("inlineCode",{parentName:"p"},"tickSpacing")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Pool"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import {priceToClosestTick, nearestUsableTick} from '@uniswap/v3-sdk'\n\nlet targetTick = nearestUsableTick(\n    priceToClosestTick(targetPrice),\n    pool.tickSpacing\n)\n")),(0,a.kt)("p",null,"This nearest Tick will most likely not ",(0,a.kt)("strong",{parentName:"p"},"exactly")," match our Price target."),(0,a.kt)("p",null,"Depending on our personal preferences we can either err on the higher or lower side of our target by adding or subtracting the ",(0,a.kt)("inlineCode",{parentName:"p"},"tickSpacing")," if the initializable Tick is lower or higher than the theoretically closest Tick."),(0,a.kt)("h3",{id:"lower-tick"},"Lower Tick"),(0,a.kt)("p",null,"We now find the lower Tick by subtracting the tickSpacing from the upper Tick:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"let lowerTick = targetTick - pool.tickSpacing\n")),(0,a.kt)("p",null,"If the price difference is too low, the lower tick may be left of the current Tick of the Pool.\nIn that case we would not be able to provide single side liquidity.\nWe can either throw an Error or increase our Position by one Tick."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"if (tickLower <= pool.tickCurrent) {\n    tickLower += pool.tickSpacing\n    targetTick += pool.tickSpacing\n}\n")),(0,a.kt)("p",null,"We now have a lower and upper Tick for our Position, next we need to construct and mint it."),(0,a.kt)("h2",{id:"creating-the-single-side-liquidity-position"},"Creating the Single Side Liquidity Position"),(0,a.kt)("p",null,"We will use the ",(0,a.kt)("inlineCode",{parentName:"p"},"NonfungiblePositionManager")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Position")," classes from the ",(0,a.kt)("inlineCode",{parentName:"p"},"v3-sdk")," to construct our position. We then use an ",(0,a.kt)("strong",{parentName:"p"},"etherJS")," wallet to mint our Position onchain."),(0,a.kt)("p",null,"If you are not familiar with liquidity Positions, check out the ",(0,a.kt)("a",{parentName:"p",href:"/docs/sdk/v3/guides/liquidity/position-data"},"liquidity position guides"),"."),(0,a.kt)("h3",{id:"minting-the-position"},"Minting the Position"),(0,a.kt)("p",null,"We create a ",(0,a.kt)("inlineCode",{parentName:"p"},"Position")," object with our ticks and the amount of tokens we want to deposit:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Position } from '@uniswap/v3-sdk'\n\nconst position = Position.fromAmount0({\n    pool: pool,\n    tickLower: tickLower,\n    tickUpper: targetTick,\n    amount0: amount,\n    useFullPrecision: true\n})\n")),(0,a.kt)("p",null,"Before we mint our position, we need to give the ",(0,a.kt)("inlineCode",{parentName:"p"},"NonfungiblePositionManager")," Contract an approval to transfer our tokens.\nWe can find the Contract address on the official ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/v3-periphery/blob/main/deploys.md"},"Uniswap GitHub"),".\nFor local development, the contract address is the same as the network we are forking from.\nSo if we are using a local fork of mainnet like described in the ",(0,a.kt)("a",{parentName:"p",href:"/docs/sdk/v3/guides/local-development"},"Local development guide"),", the contract address would be the same as on mainnet."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import ethers from 'ethers'\n\nconst provider = new ethers.providers.JsonRpcProvider(rpcUrl)\nconst wallet = new ethers.Wallet(privateKey, provider)\n\nconst tokenContract = new ethers.Contract(\n    pool.token0.address,\n    ERC20_ABI,\n    wallet\n)\n\nawait tokenContract['approve'](\n    NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,\n    ethers.BigNumber.from(amount)\n    )\n")),(0,a.kt)("p",null,"Once we have our approval, we create the calldata for the ",(0,a.kt)("strong",{parentName:"p"},"Mint")," call using the ",(0,a.kt)("inlineCode",{parentName:"p"},"NonfungiblePositionManager"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import {MintOptions, NonfungiblePositionManager}\nimport { Percent } from '@uniswap/sdk-core'\n\nconst mintOptions: MintOptions = {\n    recipient: wallet.address,\n    deadline: Math.floor(Date.now() / 1000) + 60 * 20,\n    slippageTolerance: new Percent(50, 10_000),\n}\n\nconst { calldata, value } = NonfungiblePositionManager.addCallParameters(\n    order.position,\n    mintOptions\n)\n")),(0,a.kt)("p",null,"We can populate our mint transaction and send it with our wallet:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"}," const transaction = {\n    data: calldata,\n    to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,\n    value: ethers.BigNumber.from(value),\n    from: address,\n    maxFeePerGas: MAX_FEE_PER_GAS,\n    maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,\n  }\n\nconst txRes = await wallet.sendTransaction(transaction)\n")),(0,a.kt)("p",null,"You can find full code examples for these code snippets in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/uniswap/examples/blob/main/v3-sdk/range-order/src/libs/range-order.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"range-order.ts")),"."),(0,a.kt)("h3",{id:"getting-the-tokenid"},"Getting the tokenId"),(0,a.kt)("p",null,"We want to read the response to our ",(0,a.kt)("inlineCode",{parentName:"p"},"Mint")," function call to get ",(0,a.kt)("strong",{parentName:"p"},"the position id"),".\nWe will need the positionId to fetch the Position Info from the NFTPositionManager contract.\nWe wait for the transaction receipt and fetch the result using ",(0,a.kt)("inlineCode",{parentName:"p"},"trace_transaction"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"let receipt = null\nlet mintCallOutput\n\nwhile (receipt === null) {\n    try {\n        receipt = await provider.getTransactionReceipt(txRes.hash)\n\n        if (receipt === null) {\n            continue\n        } else {\n            const callTraces = await provider.send('trace_transaction', [\n                txRes.hash\n            ])\n            mintCallOutput = callTraces[0].result.output\n        }\n    } catch (e) {\n        break\n    }\n}\n")),(0,a.kt)("p",null,"Your Node provider may not support this call. In that case you can also call the NonfungiblePositionManager Contract with the wallet address and identify the Range Order Position manually:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const mintCallOutput = await wallet.call(transaction)\n")),(0,a.kt)("p",null,"We get a raw byte string as a return value from this function and have to parse it ourselves.\nWe decode the result with the ",(0,a.kt)("strong",{parentName:"p"},"ethers AbiCoder"),". The solidity function has this signature:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function mint(\n    struct INonfungiblePositionManager.MintParams params\n) external returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)\n")),(0,a.kt)("p",null,"So we need the first parameter to get the ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenId"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const decodedOutput = ethers.utils.defaultAbiCoder.decode(\n    ['tuple(uint256, uint128, uint256, uint256)'],\n    mintCallOutput\n  )[0]\n\nconst tokenId = decodedOutput.toString()\n")),(0,a.kt)("p",null,"Ethers handles the string decoding of the byte string we got and parses it to its internal datatypes.\nThe decodedOutput we get from the AbiCoder is a ",(0,a.kt)("inlineCode",{parentName:"p"},"ethers.Bignumber")," so we need to cast it to a string to use it with the SDK."),(0,a.kt)("p",null,"We have created our Range Order Position, now we need to monitor it."),(0,a.kt)("p",null,"In the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/uniswap/examples/blob/main/v3-sdk/range-order/src/libs/range-order.ts#L180"},"code example")," we use ",(0,a.kt)("inlineCode",{parentName:"p"},"wallet.call")," to get the position id.\n",(0,a.kt)("inlineCode",{parentName:"p"},"call")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"trace_call")," both simulate a transaction on the connected node and return the expected output, ",(0,a.kt)("inlineCode",{parentName:"p"},"trace_call")," gives us a much more detailed output though.\nDepending on the use case, either can be the better choice.\nIn a production environment you would prefer to wait for the ",(0,a.kt)("inlineCode",{parentName:"p"},"transactionReceipt")," like described earlier to ensure the transaction was actaully included in the blockchain."),(0,a.kt)("h2",{id:"observing-the-price"},"Observing the Price"),(0,a.kt)("p",null,"We need to observe the price of the Pool and withdraw our Position once the ",(0,a.kt)("inlineCode",{parentName:"p"},"tickCurrent")," has moved across our Position."),(0,a.kt)("p",null,"We use ",(0,a.kt)("strong",{parentName:"p"},"ethers JS")," to watch for new blocks and fetch the latest Pool data:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"\nprovider.on('block', refreshPool())\n\nfunction refreshPool() {\n\n    ... // construct Pool contract\n    \n    const slot0 = await poolContract.slot0()\n    const tickCurrent = slot0.tick\n}\n")),(0,a.kt)("p",null,"It is not necessary to calculate the Price from the tick we fetched, as executing the limit order is dependent on the tick range we defined and not the Price from which we calculated it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"\nif (tickCurrent > targetTick) {\n    // Withdraw position\n}\n")),(0,a.kt)("p",null,"We check if the tick has crossed our position, and if so we withdraw the Position."),(0,a.kt)("h2",{id:"closing-the-limit-order"},"Closing the Limit Order"),(0,a.kt)("p",null,"We call the NonfungiblePositionManager Contract with the ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenId")," to get all info of our position as we may have gotten fees from trades on the Pool:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import INON_FUNGIBLE_POSITION_MANAGER from '@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json'\n\nconst positionManagerContract = new ethers.Contract(\n    NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,\n    INONFUNGIBLE_POSITION_MANAGER.abi,\n    provider\n)\n\nconst positionInfo = await positionManagerContract.positions(tokenId)\n")),(0,a.kt)("p",null,"We use the ",(0,a.kt)("inlineCode",{parentName:"p"},"NonfungiblePositionManager"),", the ",(0,a.kt)("inlineCode",{parentName:"p"},"pool"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"positionInfo")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenId")," to create call parameter for a ",(0,a.kt)("inlineCode",{parentName:"p"},"decreaseLiquidity")," call."),(0,a.kt)("p",null,"We start with creating ",(0,a.kt)("inlineCode",{parentName:"p"},"CollectOptions"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Percent, CurrencyAmount } from '@uniswap/sdk-core'\nimport { CollectOptions, RemoveLiquidityOptions } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nconst collectOptions: Omit<CollectOptions, 'tokenId'> = {\n    expectedCurrencyOwed0: CurrencyAmount.fromRawAmount(\n        pool.token0,\n        JSBI.BigInt(positionInfo.tokensOwed0.toString())\n    ),\n    expectedCurrencyOwed1: CurrencyAmount.fromRawAmount(\n        pool.token1,\n        JSBI.BigInt(positionInfo.tokensOwed1.toString())\n    ),\n    recipient: wallet.address,\n}\n")),(0,a.kt)("p",null,"Next we create ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoveLiquidityOptions"),". We remove all our liquidity so we set liquidityPercentage to ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const removeLiquidityOptions: RemoveLiquidityOptions = {\n      deadline: Math.floor(Date.now() / 1000) + 60 * 20,\n      slippageTolerance: new Percent(50, 10_000),\n      tokenId,\n      // percentage of liquidity to remove\n      liquidityPercentage: new Percent(1),\n      collectOptions,\n    }\n")),(0,a.kt)("p",null,"We create a new ",(0,a.kt)("inlineCode",{parentName:"p"},"Position")," object from the updated ",(0,a.kt)("inlineCode",{parentName:"p"},"positionInfo")," info we fetched:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"\nconst updatedPosition = new Position{\n    pool,\n    liquidity: JSBI.BigInt(currentPositionInfo.liquidity.toString()),\n    tickLower: currentPositionInfo.tickLower,\n    tickUpper: currentPositionInfo.tickUpper,\n}\n")),(0,a.kt)("p",null,"We have everything to create our calldata now and are ready to make our Contract call:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"\nconst { calldata, value } = NonfungiblePositionManager.removeCallParameters(\n      updatedPosition,\n      removeLiquidityOptions\n    )\nconst transaction = {\n    data: calldata,\n    to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,\n    value: value,\n    from: address,\n    maxFeePerGas: MAX_FEE_PER_GAS,\n    maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,\n}\n\nconst result = await wallet.sendTransaction(transaction)\n")),(0,a.kt)("p",null,"Our liquidity position is removed and we receive ",(0,a.kt)("inlineCode",{parentName:"p"},"token1")," at the Price we have specified.\nWe have successfully executed a range order."),(0,a.kt)("h2",{id:"caveats"},"Caveats"),(0,a.kt)("p",null,"Executing a range order has certain limitations that may have become obvious during the course of this guide."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If the price of the Pool drops below ",(0,a.kt)("inlineCode",{parentName:"li"},"tickUpper")," while we already decided to withdraw our liquidity our order may fail and we either receive ",(0,a.kt)("inlineCode",{parentName:"li"},"token0"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"token0")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"token1")," or our transaction fails depending on our exact implementation."),(0,a.kt)("li",{parentName:"ul"},"Range Orders can only be created between initializable ticks and may not exactly represent our limit order Price-Target."),(0,a.kt)("li",{parentName:"ul"},"Depending on the price ratio of the tokens in the Pool the minimum price difference to the current price may be significant."),(0,a.kt)("li",{parentName:"ul"},"The tokens received are the average between the Price of ",(0,a.kt)("inlineCode",{parentName:"li"},"tickUpper")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"tickLower")," of the Range order. This can be a significant difference for Pools with a tickCurrent far from 0, for example tokens with different decimals (WETH/ USDT, WETH/USDC). The example showcases this behaviour well with the default configuration.")),(0,a.kt)("h2",{id:"next-steps"},"Next Steps"),(0,a.kt)("p",null,"This guide showcases everything you need to implement Range Orders on your own, but only demonstrates creating a Take Profit order in ",(0,a.kt)("inlineCode",{parentName:"p"},"token0")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"token1")," direction.\nConsider implementing Buy Limit orders as described in the ",(0,a.kt)("a",{parentName:"p",href:"../../../../concepts/protocol/range-orders.md#buy-limit-orders"},"Range Orders concept page"),"."),(0,a.kt)("p",null,"This is currently the last guide in the ",(0,a.kt)("inlineCode",{parentName:"p"},"v3-sdk")," series. Consider joining the ",(0,a.kt)("a",{parentName:"p",href:"https://discord.com/invite/sherry"},"Uniswap Discord")," or checkout the official ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap"},"GitHub")," to learn more about the Uniswap Protocol."))}d.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),h=a,k=u["".concat(s,".").concat(h)]||u[h]||d[h]||o;return n?i.createElement(k,r(r({ref:t},c),{},{components:n})):i.createElement(k,r({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},35732:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/range-order-947a26c9bae762fae15dc65a55a61987.png"}}]);