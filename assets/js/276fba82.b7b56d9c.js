"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[3493],{8690:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=t(3117),i=(t(7294),t(3905));const r={id:"advanced-examples",sidebar_position:3,title:"Advanced Examples"},o="\ud83d\udd34 Advanced Examples",s={unversionedId:"sdk/trigger-sdk/examples/advanced-examples",id:"sdk/trigger-sdk/examples/advanced-examples",title:"Advanced Examples",description:"Complex mini-apps with server-side logic and optimization.",source:"@site/docs/sdk/trigger-sdk/examples/advanced.md",sourceDirName:"sdk/trigger-sdk/examples",slug:"/sdk/trigger-sdk/examples/advanced-examples",permalink:"/docs/sdk/trigger-sdk/examples/advanced-examples",editUrl:"https://github.com/hoffms/docs/tree/main/docs/sdk/trigger-sdk/examples/advanced.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"advanced-examples",sidebar_position:3,title:"Advanced Examples"},sidebar:"sdkSidebar",previous:{title:"Intermediate Examples",permalink:"/docs/sdk/trigger-sdk/examples/intermediate-examples"},next:{title:"Quick Start",permalink:"/docs/sdk/trigger-sdk/quickstart"}},l={},c=[{value:"1. <strong>AI-Powered Yield Optimizer</strong>",id:"1-ai-powered-yield-optimizer",level:3},{value:"2. <strong>Dynamic NFT Pricing Engine</strong>",id:"2-dynamic-nft-pricing-engine",level:3},{value:"3. <strong>Advanced Arbitrage Bot</strong>",id:"3-advanced-arbitrage-bot",level:3}],p={toc:c};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"-advanced-examples"},"\ud83d\udd34 Advanced Examples"),(0,i.kt)("p",null,"Complex mini-apps with server-side logic and optimization."),(0,i.kt)("h3",{id:"1-ai-powered-yield-optimizer"},"1. ",(0,i.kt)("strong",{parentName:"h3"},"AI-Powered Yield Optimizer")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u23f1\ufe0f Setup: 30 minutes")," | ",(0,i.kt)("strong",{parentName:"p"},"Action Type: Dynamic")),(0,i.kt)("p",null,"Server calculates optimal DeFi yield strategies across multiple protocols."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const yieldOptimizerApp: Metadata = {\n  url: 'https://yield-optimizer.com',\n  icon: '\ud83e\udd16',\n  title: 'AI Yield Optimizer',\n  description: 'Maximize your DeFi yields with AI-powered strategies',\n  baseUrl: 'https://api.yield-optimizer.com',\n  actions: [\n    {\n      type: 'dynamic',\n      label: 'Optimize My Yield',\n      path: '/api/calculate-optimal-yield',\n      chains: { source: 'avalanche' },\n      params: [\n        {\n          name: 'amount',\n          label: 'Investment Amount (USDC)',\n          type: 'number',\n          required: true,\n          min: 100,\n          max: 1000000,\n          description: 'Minimum $100 for optimal strategy calculation',\n        },\n        {\n          name: 'riskTolerance',\n          label: 'Risk Tolerance',\n          type: 'select',\n          required: true,\n          options: [\n            {\n              label: 'Conservative (3-5% APY)',\n              value: 'low',\n              description: 'Stable protocols only, lower risk',\n            },\n            {\n              label: 'Moderate (5-12% APY)',\n              value: 'medium',\n              description: 'Balanced risk/reward approach',\n            },\n            {\n              label: 'Aggressive (12%+ APY)',\n              value: 'high',\n              description: 'Higher risk for maximum returns',\n            },\n          ],\n        },\n        {\n          name: 'timeHorizon',\n          label: 'Investment Duration',\n          type: 'radio',\n          required: true,\n          options: [\n            { label: '1 Week', value: 7, description: 'Short-term gains' },\n            { label: '1 Month', value: 30, description: 'Medium-term strategy' },\n            { label: '3 Months', value: 90, description: 'Long-term optimization' },\n            { label: '1 Year', value: 365, description: 'Maximum compounding' },\n          ],\n        },\n        {\n          name: 'autoCompound',\n          label: 'Auto-compound rewards',\n          type: 'boolean',\n          value: true,\n          description: 'Automatically reinvest rewards for compound growth',\n        },\n      ],\n    },\n  ],\n};\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Backend Implementation (Next.js API Route):")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// pages/api/calculate-optimal-yield.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { serialize } from 'wagmi';\nimport { avalanche } from 'viem/chains';\nimport { ExecutionResponse } from '@sherrylinks/sdk';\n\nexport async function POST(req: NextRequest) {\n  try {\n    const { searchParams } = new URL(req.url);\n    const amount = parseFloat(searchParams.get('amount') || '0');\n    const riskTolerance = searchParams.get('riskTolerance');\n    const timeHorizon = parseInt(searchParams.get('timeHorizon') || '30');\n    const autoCompound = searchParams.get('autoCompound') === 'true';\n\n    // \ud83e\udde0 AI-POWERED YIELD CALCULATION\n    const protocols = await fetchProtocolYields();\n    const filteredProtocols = filterByRisk(protocols, riskTolerance);\n    const optimalStrategy = await calculateOptimalAllocation({\n      protocols: filteredProtocols,\n      amount,\n      timeHorizon,\n      autoCompound,\n    });\n\n    // Build optimized transaction\n    const transaction = await buildYieldTransaction(optimalStrategy);\n    const serializedTx = serialize(transaction);\n\n    const response: ExecutionResponse = {\n      serializedTransaction: serializedTx,\n      chainId: 'avalanche',\n      params: {\n        functionName: 'executeYieldStrategy',\n        args: {\n          strategy: optimalStrategy.name,\n          expectedAPY: `${optimalStrategy.projectedAPY}%`,\n          protocols: optimalStrategy.protocols.join(', '),\n          projectedValue: `$${(amount * (1 + optimalStrategy.projectedAPY / 100)).toFixed(2)} after ${timeHorizon} days`,\n        },\n      },\n    };\n\n    return NextResponse.json(response);\n  } catch (error) {\n    return NextResponse.json({ error: 'Yield calculation failed' }, { status: 500 });\n  }\n}\n\n// AI yield calculation functions\nasync function fetchProtocolYields() {\n  // Fetch real-time yields from Aave, Compound, Yearn, etc.\n  const protocols = await Promise.all([\n    fetch('https://api.aave.com/data/liquidity/v1').then(r => r.json()),\n    fetch('https://api.compound.finance/api/v2/ctoken').then(r => r.json()),\n    fetch('https://api.yearn.finance/v1/chains/1/vaults/all').then(r => r.json()),\n  ]);\n  return protocols.flat();\n}\n\nfunction filterByRisk(protocols: any[], risk: string) {\n  const riskThresholds = { low: 3, medium: 6, high: 10 };\n  return protocols.filter(p => p.riskScore <= riskThresholds[risk]);\n}\n\nasync function calculateOptimalAllocation(config: any) {\n  // Portfolio optimization algorithm (Markowitz, Black-Litterman, etc.)\n  return {\n    name: 'Multi-Protocol Yield Strategy',\n    protocols: ['Aave USDC', 'Compound DAI', 'Yearn USDT'],\n    allocation: [0.4, 0.35, 0.25],\n    projectedAPY: 8.7,\n    riskScore: 4.2,\n  };\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\ud83c\udfaf What you'll learn:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Complex Dynamic Action implementation"),(0,i.kt)("li",{parentName:"ul"},"Server-side AI/ML integration"),(0,i.kt)("li",{parentName:"ul"},"Multi-protocol yield optimization"),(0,i.kt)("li",{parentName:"ul"},"Real-time data processing"),(0,i.kt)("li",{parentName:"ul"},"Advanced parameter handling")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"2-dynamic-nft-pricing-engine"},"2. ",(0,i.kt)("strong",{parentName:"h3"},"Dynamic NFT Pricing Engine")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u23f1\ufe0f Setup: 25 minutes")," | ",(0,i.kt)("strong",{parentName:"p"},"Action Type: Dynamic")),(0,i.kt)("p",null,"NFT pricing that adapts to market conditions, demand, and whale activity."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const dynamicNFTApp: Metadata = {\n  url: 'https://dynamic-nft.com',\n  icon: '\ud83d\udc8e',\n  title: 'Smart NFT Mint',\n  description: 'AI-powered dynamic pricing based on market conditions',\n  baseUrl: 'https://api.dynamic-nft.com',\n  actions: [\n    {\n      type: 'dynamic',\n      label: 'Mint at Current Price',\n      path: '/api/calculate-nft-price',\n      chains: { source: 'avalanche' },\n      params: [\n        {\n          name: 'tier',\n          label: 'NFT Tier',\n          type: 'select',\n          required: true,\n          options: [\n            {\n              label: 'Common \u26aa',\n              value: 'common',\n              description: 'Basic tier with standard traits',\n            },\n            {\n              label: 'Rare \ud83d\udd35',\n              value: 'rare',\n              description: 'Enhanced traits and special effects',\n            },\n            {\n              label: 'Epic \ud83d\udfe3',\n              value: 'epic',\n              description: 'Unique animations and rare attributes',\n            },\n            {\n              label: 'Legendary \ud83d\udfe1',\n              value: 'legendary',\n              description: 'Ultra-rare with exclusive benefits',\n            },\n          ],\n        },\n        {\n          name: 'quantity',\n          label: 'Quantity',\n          type: 'radio',\n          required: true,\n          options: [\n            { label: '1 NFT', value: 1, description: 'Single mint' },\n            { label: '3 NFTs', value: 3, description: '5% bulk discount' },\n            { label: '5 NFTs', value: 5, description: '10% bulk discount' },\n            { label: '10 NFTs', value: 10, description: '15% bulk discount' },\n          ],\n        },\n      ],\n    },\n  ],\n};\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Backend Implementation:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// pages/api/calculate-nft-price.ts\nexport async function POST(req: NextRequest) {\n  try {\n    const { searchParams } = new URL(req.url);\n    const tier = searchParams.get('tier');\n    const quantity = parseInt(searchParams.get('quantity') || '1');\n\n    // \ud83c\udfaf DYNAMIC PRICING ALGORITHM\n    const marketData = await analyzeMarketConditions();\n    const demandMetrics = await calculateDemandMetrics(tier);\n    const whaleActivity = await detectWhaleActivity();\n\n    const basePrice = getTierBasePrice(tier);\n    const dynamicMultiplier = calculatePriceMultiplier({\n      marketData,\n      demandMetrics,\n      whaleActivity,\n      quantity,\n    });\n\n    const finalPrice = basePrice * dynamicMultiplier * quantity;\n    const bulkDiscount = getBulkDiscount(quantity);\n    const totalPrice = finalPrice * (1 - bulkDiscount);\n\n    // Build mint transaction with dynamic pricing\n    const transaction = await buildMintTransaction({\n      tier,\n      quantity,\n      price: totalPrice,\n      recipient: searchParams.get('userAddress'),\n    });\n\n    const response: ExecutionResponse = {\n      serializedTransaction: serialize(transaction),\n      chainId: 'avalanche',\n      params: {\n        functionName: 'mintWithDynamicPrice',\n        args: {\n          tier: tier,\n          quantity: quantity,\n          currentPrice: `${totalPrice.toFixed(3)} AVAX`,\n          marketCondition: marketData.condition,\n          demandLevel: demandMetrics.level,\n          priceChange: `${((dynamicMultiplier - 1) * 100).toFixed(1)}%`,\n          bulkDiscount: `${(bulkDiscount * 100).toFixed(0)}%`,\n        },\n      },\n    };\n\n    return NextResponse.json(response);\n  } catch (error) {\n    return NextResponse.json({ error: 'Price calculation failed' }, { status: 500 });\n  }\n}\n\n// Dynamic pricing functions\nasync function analyzeMarketConditions() {\n  // Analyze overall NFT market, ETH price, gas fees, etc.\n  return {\n    condition: 'bullish', // bearish, neutral, bullish\n    volatility: 0.15,\n    volume24h: 1500000,\n  };\n}\n\nasync function calculateDemandMetrics(tier: string) {\n  // Analyze recent mints, wallet interest, social sentiment\n  return {\n    level: 'high', // low, medium, high\n    recentMints: 47,\n    uniqueWallets: 156,\n    socialSentiment: 0.8,\n  };\n}\n\nasync function detectWhaleActivity() {\n  // Monitor large wallet movements and buying patterns\n  return {\n    recentWhaleActivity: true,\n    largeWalletInterest: 0.7,\n  };\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\ud83c\udfaf What you'll learn:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Real-time market analysis"),(0,i.kt)("li",{parentName:"ul"},"Dynamic pricing algorithms"),(0,i.kt)("li",{parentName:"ul"},"Whale detection systems"),(0,i.kt)("li",{parentName:"ul"},"Bulk discount calculations"),(0,i.kt)("li",{parentName:"ul"},"Market sentiment integration")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"3-advanced-arbitrage-bot"},"3. ",(0,i.kt)("strong",{parentName:"h3"},"Advanced Arbitrage Bot")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u23f1\ufe0f Setup: 35 minutes")," | ",(0,i.kt)("strong",{parentName:"p"},"Action Type: Dynamic")),(0,i.kt)("p",null,"Multi-DEX arbitrage with flash loans and optimal routing."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const arbitrageBotApp: Metadata = {\n  url: 'https://arbitrage-bot.com',\n  icon: '\u26a1',\n  title: 'Flash Arbitrage Bot',\n  description: 'Execute profitable arbitrage opportunities across DEXs',\n  baseUrl: 'https://api.arbitrage-bot.com',\n  actions: [\n    {\n      type: 'dynamic',\n      label: 'Find & Execute Arbitrage',\n      path: '/api/find-arbitrage',\n      chains: { source: 'avalanche' },\n      params: [\n        {\n          name: 'tokenPair',\n          label: 'Token Pair',\n          type: 'select',\n          required: true,\n          options: [\n            {\n              label: 'AVAX/USDC',\n              value: 'AVAX_USDC',\n              description: 'Most liquid pair with frequent opportunities',\n            },\n            {\n              label: 'AVAX/USDT',\n              value: 'AVAX_USDT',\n              description: 'High volume, good for large trades',\n            },\n            {\n              label: 'USDC/USDT',\n              value: 'USDC_USDT',\n              description: 'Stable pair with smaller but consistent profits',\n            },\n          ],\n        },\n        {\n          name: 'maxSlippage',\n          label: 'Max Slippage (%)',\n          type: 'radio',\n          required: true,\n          options: [\n            { label: '0.1%', value: 0.1, description: 'Conservative, safer trades' },\n            { label: '0.5%', value: 0.5, description: 'Balanced approach' },\n            { label: '1.0%', value: 1.0, description: 'Aggressive, higher profits' },\n          ],\n        },\n        {\n          name: 'minProfitThreshold',\n          label: 'Minimum Profit Threshold',\n          type: 'number',\n          required: true,\n          min: 0.01,\n          max: 5.0,\n          value: 0.1,\n          description: 'Minimum profit % to execute trade',\n        },\n        {\n          name: 'useFlashLoan',\n          label: 'Use Flash Loans',\n          type: 'boolean',\n          value: true,\n          description: 'Enable flash loans for capital-free arbitrage',\n        },\n      ],\n    },\n  ],\n};\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Backend Implementation:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// pages/api/find-arbitrage.ts\nexport async function POST(req: NextRequest) {\n  try {\n    const { searchParams } = new URL(req.url);\n    const tokenPair = searchParams.get('tokenPair');\n    const maxSlippage = parseFloat(searchParams.get('maxSlippage') || '0.5');\n    const minProfitThreshold = parseFloat(searchParams.get('minProfitThreshold') || '0.1');\n    const useFlashLoan = searchParams.get('useFlashLoan') === 'true';\n\n    // \ud83d\udd0d SCAN MULTIPLE DEXs FOR ARBITRAGE OPPORTUNITIES\n    const dexPrices = await scanDEXPrices(tokenPair);\n    const opportunities = findArbitrageOpportunities(dexPrices, minProfitThreshold);\n\n    if (opportunities.length === 0) {\n      return NextResponse.json(\n        {\n          error: 'No profitable arbitrage opportunities found',\n        },\n        { status: 404 },\n      );\n    }\n\n    // Select best opportunity\n    const bestOpportunity = opportunities[0];\n\n    // Calculate optimal trade size\n    const optimalSize = calculateOptimalTradeSize(bestOpportunity, maxSlippage);\n\n    // Build arbitrage transaction\n    const transaction = useFlashLoan\n      ? await buildFlashLoanArbitrage(bestOpportunity, optimalSize)\n      : await buildDirectArbitrage(bestOpportunity, optimalSize);\n\n    const response: ExecutionResponse = {\n      serializedTransaction: serialize(transaction),\n      chainId: 'avalanche',\n      params: {\n        functionName: useFlashLoan ? 'executeFlashArbitrage' : 'executeDirectArbitrage',\n        args: {\n          pair: tokenPair,\n          buyDEX: bestOpportunity.buyDEX,\n          sellDEX: bestOpportunity.sellDEX,\n          tradeSize: `${optimalSize} tokens`,\n          expectedProfit: `${bestOpportunity.profitPercent.toFixed(2)}%`,\n          estimatedGain: `${((optimalSize * bestOpportunity.profitPercent) / 100).toFixed(2)}`,\n          flashLoan: useFlashLoan,\n        },\n      },\n    };\n\n    return NextResponse.json(response);\n  } catch (error) {\n    return NextResponse.json({ error: 'Arbitrage calculation failed' }, { status: 500 });\n  }\n}\n\nasync function scanDEXPrices(tokenPair: string) {\n  // Scan TraderJoe, Pangolin, SushiSwap, etc.\n  const dexAPIs = [\n    'https://api.traderjoe.xyz/v1/prices',\n    'https://api.pangolin.exchange/v1/prices',\n    'https://api.sushi.com/v1/prices',\n  ];\n\n  const prices = await Promise.all(\n    dexAPIs.map(api => fetch(`${api}/${tokenPair}`).then(r => r.json())),\n  );\n\n  return prices;\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\ud83c\udfaf What you'll learn:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Multi-DEX price scanning"),(0,i.kt)("li",{parentName:"ul"},"Flash loan implementation"),(0,i.kt)("li",{parentName:"ul"},"Optimal trade sizing"),(0,i.kt)("li",{parentName:"ul"},"Gas cost optimization"),(0,i.kt)("li",{parentName:"ul"},"Real-time opportunity detection")))}u.isMDXComponent=!0},3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(t),d=i,g=m["".concat(l,".").concat(d)]||m[d]||u[d]||r;return t?a.createElement(g,o(o({ref:n},p),{},{components:t})):a.createElement(g,o({ref:n},p))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);