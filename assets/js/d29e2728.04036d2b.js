"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[8847],{16609:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(83117),o=(n(67294),n(3905));const r={title:"ERC-6909"},i="Introduction",l={unversionedId:"contracts/v4/guides/ERC-6909",id:"contracts/v4/guides/ERC-6909",title:"ERC-6909",description:"Uniswap v4 uses ERC-6909, a token standard that works alongside the protocol\u2019s flash accounting system. This guide explains how ERC-6909 functions within v4, when to use mint versus burn operations, and how developers can implement them effectively.",source:"@site/docs/contracts/v4/guides/10-ERC-6909.mdx",sourceDirName:"contracts/v4/guides",slug:"/contracts/v4/guides/ERC-6909",permalink:"/docs/contracts/v4/guides/ERC-6909",editUrl:"https://github.com/hoffms/docs/tree/main/docs/contracts/v4/guides/10-ERC-6909.mdx",tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"ERC-6909"},sidebar:"contractsSidebar",previous:{title:"Swap routing",permalink:"/docs/contracts/v4/guides/swap-routing"},next:{title:"Position Manager",permalink:"/docs/contracts/v4/guides/position-manager"}},s={},c=[{value:"Integration with Flash Accounting",id:"integration-with-flash-accounting",level:2},{value:"Gas Efficiency",id:"gas-efficiency",level:2},{value:"Simplified Token Management",id:"simplified-token-management",level:2},{value:"Operations and Token Movement",id:"operations-and-token-movement",level:2},{value:"Using Mint and Burn",id:"using-mint-and-burn",level:2},{value:"Hook Integration",id:"hook-integration",level:2}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"Uniswap v4 uses ",(0,o.kt)("a",{parentName:"p",href:"/contracts/v4/concepts/erc6909"},"ERC-6909"),", a token standard that works alongside the protocol\u2019s flash accounting system. This guide explains how ERC-6909 functions within v4, when to use mint versus burn operations, and how developers can implement them effectively."),(0,o.kt)("h1",{id:"what-is-erc-6909"},"What is ERC-6909?"),(0,o.kt)("p",null,"ERC-6909 is a token standard that enables efficient token management within a single contract through multiple token balances per user. Where ERC-20 requires separate approve and transfer calls for token interactions, ERC-6909 provides native support for multi-token operations through mint/burn mechanics that integrate with v4\u2019s flash accounting system."),(0,o.kt)("p",null,"Here\u2019s how the approaches differ:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Traditional ERC-20 approach\nIERC20(tokenA).transferFrom(owner, poolManager, amount);\n\n// ERC-6909 approach in v4\npoolManager.burn(owner, currency.toId(), amount);\n")),(0,o.kt)("h2",{id:"integration-with-flash-accounting"},"Integration with Flash Accounting"),(0,o.kt)("p",null,"While flash accounting tracks balance changes as deltas throughout a transaction, ERC-6909 provides an additional primitive to resolve  deltas. "),(0,o.kt)("p",null,"This enables:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Simplified transaction flows through direct mint/burn operations"),(0,o.kt)("li",{parentName:"ol"},"Efficient handling of multi-step operations"),(0,o.kt)("li",{parentName:"ol"},"Streamlined token management when using the PoolManager")),(0,o.kt)("h2",{id:"gas-efficiency"},"Gas Efficiency"),(0,o.kt)("p",null,"ERC-6909 provides gas savings compared to ERC-20 tokens, making it particularly valuable for use cases requiring frequent token transfers like:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Day trading operations"),(0,o.kt)("li",{parentName:"ul"},"MEV bot transactions"),(0,o.kt)("li",{parentName:"ul"},"Active liquidity management")),(0,o.kt)("p",null,"This efficiency is especially beneficial when performing multiple token operations in rapid succession."),(0,o.kt)("h2",{id:"simplified-token-management"},"Simplified Token Management"),(0,o.kt)("p",null,"The traditional ERC-20 workflow requires careful management of allowances and transfers, often leading to complex transaction sequences and potential security concerns."),(0,o.kt)("p",null,"ERC-6909 takes a different approach by providing direct balance modifications through mint and burn operations."),(0,o.kt)("p",null,"By working through the PoolManager, all token operations are consolidated into a single interface. This means you don\u2019t need to worry about managing multiple token approvals or keeping track of allowances across different contracts. Instead, you can focus on the core logic of your application while the PoolManager handles the token management aspects."),(0,o.kt)("h1",{id:"understanding-erc-6909in-v4"},"Understanding ERC-6909\xa0in v4"),(0,o.kt)("p",null,"Let's explore how ERC-6909 is used across different v4 operations and understand when to use each of its operations."),(0,o.kt)("h2",{id:"operations-and-token-movement"},"Operations and Token Movement"),(0,o.kt)("p",null,"Different pool operations create different types of deltas that need to be resolved:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Swaps"),": Create negative deltas for input tokens and positive deltas for output tokens"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Adding Liquidity"),": Creates negative deltas (tokens you need to provide)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Removing Liquidity"),": Creates positive deltas (tokens you receive)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Donations"),": Creates negative deltas (tokens you're donating)")),(0,o.kt)("h2",{id:"using-mint-and-burn"},"Using Mint and Burn"),(0,o.kt)("p",null,"The choice between mint and burn operations depends on your token movement needs:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// When you have positive deltas (withdrawing value from PoolManager):\npoolManager.mint(currency, address(this), amount);\n\n// When you have negative deltas (transferring value to PoolManager):\npoolManager.burn(currency, address(this), amount);\n")),(0,o.kt)("p",null,"This pattern is used throughout v4's operations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Use mint when withdrawing value from the pool (like receiving tokens from swaps)"),(0,o.kt)("li",{parentName:"ul"},"Use burn when transferring value to the pool (like providing tokens)")),(0,o.kt)("h2",{id:"hook-integration"},"Hook Integration"),(0,o.kt)("p",null,"When building hooks, ERC-6909 operations help manage token movements within your hook's logic:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params)\n    internal\n    returns (bytes4, BeforeSwapDelta, uint24)\n{\n    poolManager.mint(key.currency0, address(this), amount);\n    \n    return (\n      BaseHook.beforeSwap.selector,\n      BeforeSwapDeltaLibrary.ZERO_DELTA,\n      0\n    );\n}\n")),(0,o.kt)("p",null,"Other common cases would be to use ",(0,o.kt)("inlineCode",{parentName:"p"},"mint")," for fee collection or ",(0,o.kt)("inlineCode",{parentName:"p"},"burn")," for token distribution."),(0,o.kt)("h1",{id:"implementation"},"Implementation"),(0,o.kt)("p",null,"Let's build a contract that handles donations in v4 using ERC-6909. We'll create a donation router that follows this flow:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Users call our donation function with their desired amounts"),(0,o.kt)("li",{parentName:"ol"},"Our contract packages this data and uses the PoolManager's unlock pattern"),(0,o.kt)("li",{parentName:"ol"},"In the callback, we unpack the data and execute the donation, handling token movements using ERC-6909")),(0,o.kt)("p",null,"First, let's set up our contract with the necessary imports and create a struct to help us pass data between functions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport { IPoolManager } from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";\nimport { PoolKey } from "@uniswap/v4-core/src/types/PoolKey.sol";\nimport { BalanceDelta } from "@uniswap/v4-core/src/types/BalanceDelta.sol";\nimport { Currency } from "@uniswap/v4-core/src/types/Currency.sol";\n\ncontract DonationRouter {\n    IPoolManager public immutable poolManager;\n\n    // This struct helps us pack donation parameters to pass through\n    // the unlock/callback pattern\n    struct CallbackData {\n        PoolKey key;\n        uint256 amount0;\n        uint256 amount1;\n        bytes hookData;\n    }\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n    }\n}\n')),(0,o.kt)("p",null,"Now let's implement the external donation function. Here we'll pack our parameters into the CallbackData struct and start the unlock process:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @notice Donates tokens to a pool\n/// @param key The pool to donate to\n/// @param amount0 Amount of token0 to donate\n/// @param amount1 Amount of token1 to donate\n/// @param hookData Optional data to pass to hooks\nfunction donate(\n    PoolKey memory key,\n    uint256 amount0,\n    uint256 amount1,\n    bytes memory hookData\n) external returns (BalanceDelta delta) {\n    // 1. Create a CallbackData struct with all our parameters\n    CallbackData memory data = CallbackData({\n        key: key,\n        amount0: amount0,\n        amount1: amount1,\n        hookData: hookData\n    });\n\n    // 2. Encode our struct into bytes to pass through unlock\n    bytes memory encodedData = abi.encode(data);\n    \n    // 3. Call unlock with our encoded data\n    // 4. unlock will call our callback, which returns encoded delta\n    // 5. Decode the returned bytes back into a BalanceDelta\n    delta = abi.decode(\n        poolManager.unlock(encodedData),\n        (BalanceDelta)\n    );\n}\n")),(0,o.kt)("p",null,"When the PoolManager calls our callback, we need to decode our data:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function unlockCallback(\n    bytes calldata rawData\n) external returns (bytes memory) {\n    // Only the PoolManager can trigger our callback\n    require(msg.sender == address(poolManager));\n\n    // Decode the bytes back into our CallbackData struct\n    // (CallbackData) tells abi.decode what type to expect\n    CallbackData memory data = abi.decode(rawData, (CallbackData));\n")),(0,o.kt)("p",null,"Now ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," contains the same values we packed in donate():"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"- `data.key`: The pool to donate to\n- `data.amount0`: Amount of first token\n- `data.amount1`: Amount of second token\n- `data.hookData`: Any hook data\n")),(0,o.kt)("p",null,"And we can execute the donation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    // Execute the donation through PoolManager\n    // This creates negative deltas for the tokens we're donating\n    BalanceDelta delta = poolManager.donate(\n        data.key,\n        data.amount0,\n        data.amount1,\n        data.hookData\n    );\n")),(0,o.kt)("p",null,"After executing the donation through the PoolManager, we need to handle the token transfers. The donation creates negative deltas, which represent tokens that we owe to the PoolManager. This is where ERC-6909's burn operation comes into play."),(0,o.kt)("p",null,"Instead of using traditional token transfers, we can use ERC-6909's burn operation to settle this debt. We check each token's delta and, if negative, burn the corresponding amount of ERC-6909 tokens. And finally return the encoded delta. Let\u2019s see how:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"}," // Handle any negative deltas by burning ERC-6909 tokens\n    if (delta.amount0() < 0) {\n        poolManager.burn(\n            data.key.currency0,\n            address(this),\n            uint256(-delta.amount0())\n        );\n    }\n    if (delta.amount1() < 0) {\n        poolManager.burn(\n            data.key.currency1,\n            address(this),\n            uint256(-delta.amount1())\n        );\n    }\n\n    // Encode and return the delta so donate() can decode it\n    return abi.encode(delta);\n}\n")))}d.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,k=p["".concat(s,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(k,i(i({ref:t},u),{},{components:n})):a.createElement(k,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);