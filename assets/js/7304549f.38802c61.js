"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[35592],{51651:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var r=n(83117),a=(n(67294),n(3905));const i={id:"signature-transfer",title:"SignatureTransfer",sidebar_position:1},s=void 0,o={unversionedId:"contracts/permit2/reference/signature-transfer",id:"contracts/permit2/reference/signature-transfer",title:"SignatureTransfer",description:"Source Code",source:"@site/docs/contracts/permit2/reference/signature-transfer.md",sourceDirName:"contracts/permit2/reference",slug:"/contracts/permit2/reference/signature-transfer",permalink:"/docs/contracts/permit2/reference/signature-transfer",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/permit2/reference/signature-transfer.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"signature-transfer",title:"SignatureTransfer",sidebar_position:1},sidebar:"contractsSidebar",previous:{title:"Overview",permalink:"/docs/contracts/permit2/overview"},next:{title:"AllowanceTransfer",permalink:"/docs/contracts/permit2/reference/allowance-transfer"}},l={},p=[{value:"Overview",id:"overview",level:2},{value:"Functions",id:"functions",level:2},{value:"Single <code>permitTransferFrom</code>",id:"single-permittransferfrom",level:3},{value:"Batched <code>permitTransferFrom</code>",id:"batched-permittransferfrom",level:3},{value:"Single <code>permitWitnessTransferFrom</code>",id:"single-permitwitnesstransferfrom",level:3},{value:"Batch <code>permitWitnessTransferFrom</code>",id:"batch-permitwitnesstransferfrom",level:3},{value:"Nonce Schema",id:"nonce-schema",level:2},{value:"Security Considerations",id:"security-considerations",level:2}],m={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol"},(0,a.kt)("strong",{parentName:"a"},"Source Code")))),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"The main entry points on this contract are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"permitTransferFrom"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Use permitTransferFrom when you want to transfer a token from an owner through signature validation."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"permitWitnessTransferFrom"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Use permitWitnessTransferFrom when you want to transfer a token from an owner through signature validation, but you would also like to validate other data. Any other data you wish to be validated can be passed through with the ",(0,a.kt)("inlineCode",{parentName:"li"},"witness")," param.")))),(0,a.kt)("p",null,"Each of these functions is overloaded with a batched version that allows users to transfer multiple tokens with 1 transaction."),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("h3",{id:"single-permittransferfrom"},"Single ",(0,a.kt)("inlineCode",{parentName:"h3"},"permitTransferFrom")),(0,a.kt)("p",null,"Use the ",(0,a.kt)("inlineCode",{parentName:"p"},"permitTransferFrom")," to transfer just one token."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Function signature")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Parameters")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"permit - Construct ",(0,a.kt)("inlineCode",{parentName:"li"},"PermitTransferFrom")," struct with the following:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\nstruct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"transferDetails - information about recipient and amount")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"owner - the signer of the permit message and owner of the tokens"),(0,a.kt)("li",{parentName:"ul"},"signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by ",(0,a.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-2098"},"EIP-2098"),", and contract signatures defined by ",(0,a.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP-1271"))),(0,a.kt)("h3",{id:"batched-permittransferfrom"},"Batched ",(0,a.kt)("inlineCode",{parentName:"h3"},"permitTransferFrom")),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"permitTransferFrom")," with the batched parameters when you want to transfer multiple tokens from an owner."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Function Signature")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Parameters")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"permit - Construct ",(0,a.kt)("inlineCode",{parentName:"li"},"PermitBatchTransferFrom")," with the following:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\nstruct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"transferDetails - parameterized by the spender with information about the token transfer.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The length of the ",(0,a.kt)("inlineCode",{parentName:"li"},"SignatureTransferDetails")," array must equal the length of the ",(0,a.kt)("inlineCode",{parentName:"li"},"TokenPermissions")," array passed in with ",(0,a.kt)("inlineCode",{parentName:"li"},"PermitBatchTransferFrom")," struct. The token to be transferred specified in the ",(0,a.kt)("inlineCode",{parentName:"li"},"TokenPermissions")," array should match the index of the ",(0,a.kt)("inlineCode",{parentName:"li"},"SignatureTransferDetails")," array."),(0,a.kt)("li",{parentName:"ul"},"Note that if a spender is permitted to a token but does not need to transfer that token, they can specify that the ",(0,a.kt)("inlineCode",{parentName:"li"},"requestedAmount")," is 0 so that the transfer is skipped."))),(0,a.kt)("li",{parentName:"ul"},"owner - the signer of the permit message and owner of the tokens")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by ",(0,a.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-2098"},"EIP-2098"),", and contract signatures defined by ",(0,a.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP-1271"))),(0,a.kt)("h3",{id:"single-permitwitnesstransferfrom"},"Single ",(0,a.kt)("inlineCode",{parentName:"h3"},"permitWitnessTransferFrom")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Function Signature")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Parameters")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"permit - constructed with the same type as defined above in the single permitTransferFrom case"),(0,a.kt)("li",{parentName:"ul"},"transferDetails constructed with same type as defined above in the single permitTransferFrom case"),(0,a.kt)("li",{parentName:"ul"},"owner - the signer of the permit message and owner of the tokens"),(0,a.kt)("li",{parentName:"ul"},"witness - arbitrary data passed through that was signed by the user. Is used to reconstruct the signature. Pass through this data if you want the permit signature recovery also to validate other data."),(0,a.kt)("li",{parentName:"ul"},"witnessTypeString - a string that defines the typed data that the witness was hashed from. It must also include the ",(0,a.kt)("inlineCode",{parentName:"li"},"TokenPermissions")," struct and comply with ",(0,a.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-712"},"EIP-712")," struct ordering. See an example below."),(0,a.kt)("li",{parentName:"ul"},"signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by ",(0,a.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-2098"},"EIP-2098"),", and contract signatures defined by ",(0,a.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP-1271"))),(0,a.kt)("h3",{id:"batch-permitwitnesstransferfrom"},"Batch ",(0,a.kt)("inlineCode",{parentName:"h3"},"permitWitnessTransferFrom")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Function Signature")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Parameters")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"permit - constructed with the same type in the batched case of ",(0,a.kt)("inlineCode",{parentName:"li"},"permitTransferFrom")),(0,a.kt)("li",{parentName:"ul"},"transferDetails - constructed with the same type in the batched case of ",(0,a.kt)("inlineCode",{parentName:"li"},"permitTransferFrom")),(0,a.kt)("li",{parentName:"ul"},"owner - the signer of the permit message and owner of the tokens"),(0,a.kt)("li",{parentName:"ul"},"witness - arbitrary data passed through that was signed by the user. Is used to reconstruct the signature. Pass through this data if you want the permit signature recovery to also validate other data."),(0,a.kt)("li",{parentName:"ul"},"witnessTypeString - a string that defines the typed data that the witness was hashed from. It must also include the ",(0,a.kt)("inlineCode",{parentName:"li"},"TokenPermissions")," struct and comply with ",(0,a.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-712"},"EIP-712")," struct ordering. See an example below."),(0,a.kt)("li",{parentName:"ul"},"signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by ",(0,a.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-2098"},"EIP-2098"),", and contract signatures defined by ",(0,a.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP-1271"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example ",(0,a.kt)("inlineCode",{parentName:"strong"},"permitWitnessTransferFrom")," parameters")),(0,a.kt)("p",null,"If an integrating contract would also like the signer to verify information about a trade, an integrating contract may ask the signer to also sign an ",(0,a.kt)("inlineCode",{parentName:"p"},"ExampleTrade")," object that we define below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"struct ExampleTrade {\n    address exampleTokenAddress;\n    uint256 exampleMinimumAmountOut;\n}\n")),(0,a.kt)("p",null,"Following EIP-712, the typehash for the data would be defined by:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes32 _EXAMPLE_TRADE_TYPEHASH = keccak256('ExampleTrade(address exampleTokenAddress,uint256 exampleMinimumAmountOut)');\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"witness")," that should be passed along with the permit message should be:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"}," bytes32 witness = keccak256(\n            abi.encode(_EXAMPLE_TRADE_TYPEHASH, exampleTrade.exampleTokenAddress, exampleTrade.exampleMinimumAmountOut));\n")),(0,a.kt)("p",null,"And the ",(0,a.kt)("inlineCode",{parentName:"p"},"witnessTypeString")," to be passed in should be:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'string constant witnessTypeString = "ExampleTrade witness)ExampleTrade(address exampleTokenAddress,uint256 exampleMinimumAmountOut)TokenPermissions(address token,uint256 amount)"\n')),(0,a.kt)("p",null,"It\u2019s important to note that when hashing multiple typed structs, the ordering of the structs in the type string matters. Referencing EIP-721:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"If the struct type references other struct types (and these in turn reference even more struct types), then the set of referenced struct types is collected, sorted by name and appended to the encoding. An example encoding is\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)"))),(0,a.kt)("h2",{id:"nonce-schema"},"Nonce Schema"),(0,a.kt)("p",null,"Instead of using incrementing nonces, we introduce non-monotonic, or unordered nonces with a ",(0,a.kt)("inlineCode",{parentName:"p"},"nonceBitmap"),". "),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"nonceBitmap")," maps an owner's address to a uint248 value, which we will call ",(0,a.kt)("inlineCode",{parentName:"p"},"wordPos")," which is the index of the desired bitmap. There are 2",(0,a.kt)("sup",null,"248")," possible indices thus 2",(0,a.kt)("sup",null,"248")," possible bitmaps where each bitmap holds 256 bits. A bit must be flipped on to prevent replays of users\u2019 signatures. Bits that are dirtied may not be used again."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// nonceBitmap[ownerAddress][wordPosition] retrieves a uint256 bitmap\nmapping(address => mapping(uint248 => uint256)) public nonceBitmap;\n")),(0,a.kt)("p",null,"Users will sign a ",(0,a.kt)("inlineCode",{parentName:"p"},"uint256 nonce")," value where the first 248 bits correspond to the word position of the bitmap to dirty and the last 8 bits correspond to the actual bit position being flipped on."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"uint248 wordPos = uint248(nonce >> 8);\nuint8 bitPos = uint8(nonce);\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 bitmap = nonceBitmap[wordPos][bitPos]\n")),(0,a.kt)("h2",{id:"security-considerations"},"Security Considerations"),(0,a.kt)("p",null,"An integrating contract must check that tokens are released by a triggering call from the signer, or that the signer meant for their signature to be released by someone else."),(0,a.kt)("aside",null,"\ud83d\udca1 Consider this scenario:",(0,a.kt)("p",null,"A signer called Bob signs a permit to transfer 100 USDC with a router contract as the permissioned spender. The router contract never checks who the caller is but spends any permit messages on the Permit2 contract. An attacker Eve can steal Bob\u2019s signature, pass it through to the router with herself as the recipient, and transfer Bob\u2019s tokens to herself.")),(0,a.kt)("p",null,"Universal Router protects against this by checking that the ",(0,a.kt)("inlineCode",{parentName:"p"},"msg.sender")," from inside the routing contract is the supposed spender by passing ",(0,a.kt)("inlineCode",{parentName:"p"},"msg.sender")," in as the ",(0,a.kt)("inlineCode",{parentName:"p"},"owner"),"  param in any permit calls and by passing in ",(0,a.kt)("inlineCode",{parentName:"p"},"msg.sender")," as the ",(0,a.kt)("inlineCode",{parentName:"p"},"from")," param in any transfer calls."))}u.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>c});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=p(n),c=a,h=d["".concat(l,".").concat(c)]||d[c]||u[c]||i;return n?r.createElement(h,s(s({ref:t},m),{},{components:n})):r.createElement(h,s({ref:t},m))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var p=2;p<i;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);