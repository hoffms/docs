"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[84802],{38301:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(83117),r=(n(67294),n(3905));const o={id:"allowance-transfer",title:"AllowanceTransfer",sidebar_position:2},i=void 0,l={unversionedId:"contracts/permit2/reference/allowance-transfer",id:"contracts/permit2/reference/allowance-transfer",title:"AllowanceTransfer",description:"Source Code",source:"@site/docs/contracts/permit2/reference/allowance-transfer.md",sourceDirName:"contracts/permit2/reference",slug:"/contracts/permit2/reference/allowance-transfer",permalink:"/docs/contracts/permit2/reference/allowance-transfer",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/permit2/reference/allowance-transfer.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"allowance-transfer",title:"AllowanceTransfer",sidebar_position:2},sidebar:"contractsSidebar",previous:{title:"SignatureTransfer",permalink:"/docs/contracts/permit2/reference/signature-transfer"},next:{title:"Overview",permalink:"/docs/contracts/v2/overview"}},s={},p=[{value:"Overview",id:"overview",level:2},{value:"Functions",id:"functions",level:2},{value:"<code>approve</code>",id:"approve",level:3},{value:"Single <code>permit</code>",id:"single-permit",level:3},{value:"Batched <code>permit</code>",id:"batched-permit",level:3},{value:"Single <code>transferFrom</code>",id:"single-transferfrom",level:3},{value:"Batched <code>transferFrom</code>",id:"batched-transferfrom",level:3},{value:"Nonce Schema",id:"nonce-schema",level:2},{value:"Security Considerations",id:"security-considerations",level:2}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/permit2/blob/main/src/AllowanceTransfer.sol"},(0,r.kt)("strong",{parentName:"a"},"Source Code")))),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"The main entry points on this contract are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"approve"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Use approve when you do not want to set token permissions through signature validation."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"permit"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Use permit when you do want to set token permissions through signature validation."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"transferFrom"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Use transferFrom when you want to transfer a token and have the necessary permissions to do so.")))),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("h3",{id:"approve"},(0,r.kt)("inlineCode",{parentName:"h3"},"approve")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Function Signature")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function approve(address token, address spender, uint160 amount, uint48 expiration) external\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"token - the token address to approve"),(0,r.kt)("li",{parentName:"ul"},"spender - the spender address to approve"),(0,r.kt)("li",{parentName:"ul"},"amount - the approved amount of the token, ",(0,r.kt)("inlineCode",{parentName:"li"},"type(uint160).max")," is treated as an unlimited allowance"),(0,r.kt)("li",{parentName:"ul"},"expiration - the timestamp at which the approval is no longer valid, passing in ",(0,r.kt)("inlineCode",{parentName:"li"},"0")," will expire the permissions at ",(0,r.kt)("inlineCode",{parentName:"li"},"block.timestamp"))),(0,r.kt)("h3",{id:"single-permit"},"Single ",(0,r.kt)("inlineCode",{parentName:"h3"},"permit")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Function Signature")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"owner - the address of the token\u2019s owner"),(0,r.kt)("li",{parentName:"ul"},"permitSingle - constructed with the following:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct PermitSingle {\n        // the permit data for a single token allowance\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\nstruct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by ",(0,r.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-2098"},"EIP-2098"),", and contract signatures defined by ",(0,r.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP-1271"))),(0,r.kt)("h3",{id:"batched-permit"},"Batched ",(0,r.kt)("inlineCode",{parentName:"h3"},"permit")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Function Signature")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"owner - the address of the token\u2019s owner"),(0,r.kt)("li",{parentName:"ul"},"permitBatch - constructed with the following:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\nstruct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by ",(0,r.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-2098"},"EIP-2098"),", and contract signatures defined by ",(0,r.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP-1271"))),(0,r.kt)("h3",{id:"single-transferfrom"},"Single ",(0,r.kt)("inlineCode",{parentName:"h3"},"transferFrom")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Function Signature")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function transferFrom(address from, address to, uint160 amount, address token) external;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"from - the address to transfer the token from"),(0,r.kt)("li",{parentName:"ul"},"to -  the address of the recipient"),(0,r.kt)("li",{parentName:"ul"},"amount - the amount of the token to transfer, the maximum amount is ",(0,r.kt)("inlineCode",{parentName:"li"},"type(uint160).max")),(0,r.kt)("li",{parentName:"ul"},"token - the address of the token to be transferred")),(0,r.kt)("h3",{id:"batched-transferfrom"},"Batched ",(0,r.kt)("inlineCode",{parentName:"h3"},"transferFrom")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Function Signature")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"transferDetails - constructed with the following")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n")),(0,r.kt)("h2",{id:"nonce-schema"},"Nonce Schema"),(0,r.kt)("p",null,"The nonces used to protect against replay attacks of signatures are similar to standard incrementing nonces. However, we pack nonces with an allowed amount, and an allowed duration. This means that nonces are incremented ",(0,r.kt)("em",{parentName:"p"},"per owner"),", ",(0,r.kt)("em",{parentName:"p"},"per token"),", and ",(0,r.kt)("em",{parentName:"p"},"per spender.")," Which further implies that you could sign two different permits at the same time with the same nonces and they ",(0,r.kt)("em",{parentName:"p"},"won\u2019t")," cancel each other out so long as the token or spender differ."),(0,r.kt)("p",null,"The mapping nonces are packed in is defined as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(address => mapping(address => mapping(address => PackedAllowance))) public allowance;\n")),(0,r.kt)("p",null,"and indexed as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"PackedAllowance allowanceInformation = allowance[ownerAddress][tokenAddress][spenderAddress];\nuint48 nonce = allowanceInformation.nonce;\n")),(0,r.kt)("h2",{id:"security-considerations"},"Security Considerations"),(0,r.kt)("p",null,"Similar to the security considerations outlined in SignatureTransfer, integrating contracts need to perform valid safety checks on the caller and pass in correct addresses for the ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," argument in any transfer calls."),(0,r.kt)("p",null,"All amounts on the ",(0,r.kt)("inlineCode",{parentName:"p"},"AllowanceTransfer")," contract are of type ",(0,r.kt)("inlineCode",{parentName:"p"},"uint160")," so make sure integrating contracts safely downcast if they have to. See how Permit2Lib downcasts safely."))}d.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,k=m["".concat(s,".").concat(u)]||m[u]||d[u]||o;return n?a.createElement(k,i(i({ref:t},c),{},{components:n})):a.createElement(k,i({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);