"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[5283],{84347:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var o=n(83117),a=(n(67294),n(3905));const i={title:"Building Your First Hook"},r="Introduction",s={unversionedId:"contracts/v4/guides/hooks/your-first-hook",id:"contracts/v4/guides/hooks/your-first-hook",title:"Building Your First Hook",description:"Uniswap introduced the v4 of their protocol introducing several new concepts such as hooks, flash accounting, singleton architecture and more. The most interesting of these for developers is hooks, and that\u2019s what we\u2019ll be learning about today.",source:"@site/docs/contracts/v4/guides/hooks/01-your-first-hook.md",sourceDirName:"contracts/v4/guides/hooks",slug:"/contracts/v4/guides/hooks/your-first-hook",permalink:"/docs/contracts/v4/guides/hooks/your-first-hook",editUrl:"https://github.com/hoffms/docs/tree/main/docs/contracts/v4/guides/hooks/01-your-first-hook.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Building Your First Hook"},sidebar:"contractsSidebar",previous:{title:"Subscriber",permalink:"/docs/contracts/v4/quickstart/subscriber"},next:{title:"Hook Deployment",permalink:"/docs/contracts/v4/guides/hooks/hook-deployment"}},l={},d=[{value:"What are we building?",id:"what-are-we-building",level:2},{value:"Setting things up",id:"setting-things-up",level:2},{value:"Basic Structure",id:"basic-structure",level:2},{value:"Points Logic",id:"points-logic",level:2},{value:"Hook Logic",id:"hook-logic",level:2},{value:"Getting the user address",id:"getting-the-user-address",level:3},{value:"Hook Logic: <code>afterSwap</code>",id:"hook-logic-afterswap",level:3},{value:"Hook Logic: <code>afterAddLiquidity</code>",id:"hook-logic-afteraddliquidity",level:3},{value:"Test Suite",id:"test-suite",level:3}],u={toc:d};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Uniswap introduced the v4 of their protocol introducing several new concepts such as hooks, flash accounting, singleton architecture and more. The most interesting of these for developers is hooks, and that\u2019s what we\u2019ll be learning about today."),(0,a.kt)("p",null,"In this guide, we\u2019ll be conceptualizing, understanding and building a basic points hook, which will give you some idea of how to build your own hook."),(0,a.kt)("h2",{id:"what-are-we-building"},"What are we building?"),(0,a.kt)("p",null,"Let\u2019s start by conceptualizing what we\u2019re building today and why. Let\u2019s say you have a token named ",(0,a.kt)("inlineCode",{parentName:"p"},"TOKEN")," that you want to incentivize people to buy. One way of doing so is awarding people points when they buy your token. Prior to v4, you\u2019d have to do this off-chain or via your own helper contract outside of the swap logic, but in v4 you can enable universal access using hooks."),(0,a.kt)("p",null,"Let\u2019s start by defining when users will be rewarded with these points:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"When the user swaps ",(0,a.kt)("inlineCode",{parentName:"li"},"ETH")," into ",(0,a.kt)("inlineCode",{parentName:"li"},"TOKEN")," they will get awarded points equal to how much ",(0,a.kt)("inlineCode",{parentName:"li"},"ETH")," they swapped the token with."),(0,a.kt)("li",{parentName:"ol"},"When the user adds liquidity, we award them with points equal to the amount of ",(0,a.kt)("inlineCode",{parentName:"li"},"ETH")," they added.")),(0,a.kt)("p",null,"In order to keep track of these points, we\u2019ll mint the ",(0,a.kt)("inlineCode",{parentName:"p"},"POINTS")," token to the user, this has an added benefit for the user to be able to track it in their wallet."),(0,a.kt)("h1",{id:"hook-design"},"Hook Design"),(0,a.kt)("p",null,"Let\u2019s figure out how our hook will work."),(0,a.kt)("p",null,"From the Uniswap v4 Documentation, there are several hooks available for developers to integrate with. In our use case, we specifically need the ability to read swaps and figure out what amounts they are swapping for and who they are."),(0,a.kt)("p",null,"For our hook, we\u2019ll be using ",(0,a.kt)("inlineCode",{parentName:"p"},"afterSwap")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"afterAddLiquidity")," hooks. Why these instead of the ",(0,a.kt)("inlineCode",{parentName:"p"},"before...")," hooks? We\u2019ll dig deeper into this later in this guide."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Note: To initiate the swap in the first place, this is where ",(0,a.kt)("a",{parentName:"em",href:"/docs/contracts/universal-router/overview"},(0,a.kt)("inlineCode",{parentName:"a"},"UniversalRouter"))," comes into play where we will pass in the ",(0,a.kt)("a",{parentName:"em",href:"https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol#L35"},(0,a.kt)("inlineCode",{parentName:"a"},"V4_SWAP"))," command to ",(0,a.kt)("inlineCode",{parentName:"em"},"UniversalRouter.execute"),".")),(0,a.kt)("h1",{id:"lets-create-our-hook"},"Let\u2019s create our hook!"),(0,a.kt)("p",null,"We\u2019ll call this hook ",(0,a.kt)("inlineCode",{parentName:"p"},"PointsHook")," and create it in such a way that any pool paired with ",(0,a.kt)("inlineCode",{parentName:"p"},"TOKEN")," can use it."),(0,a.kt)("h2",{id:"setting-things-up"},"Setting things up"),(0,a.kt)("p",null,"The Uniswap ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/uniswapfoundation/v4-template"},"v4-template repo")," provides a basic foundry environment with required imports already pre-loaded. Click on ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/new?template_name=v4-template&template_owner=uniswapfoundation"},(0,a.kt)("inlineCode",{parentName:"a"},"Use this template"))," to create a new repository with it."),(0,a.kt)("p",null,"Or simply clone it and install the dependencies:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/uniswapfoundation/v4-template.git\ncd v4-template\n# requires foundry\nforge install\nforge test\n")),(0,a.kt)("p",null,"After that let's create a new contract ",(0,a.kt)("inlineCode",{parentName:"p"},"PointsHook.sol")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"src")," folder with the following codes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";\n\nimport {Hooks} from "v4-core/src/libraries/Hooks.sol";\nimport {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";\nimport {PoolKey} from "v4-core/src/types/PoolKey.sol";\nimport {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";\nimport {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";\n\ncontract PointsHook is BaseHook {\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    function getHookPermissions()\n        public\n        pure\n        override\n        returns (Hooks.Permissions memory)\n    {\n        return\n            Hooks.Permissions({\n                beforeInitialize: false,\n                afterInitialize: false,\n                beforeAddLiquidity: false,\n                afterAddLiquidity: true,\n                beforeRemoveLiquidity: false,\n                afterRemoveLiquidity: false,\n                beforeSwap: false,\n                afterSwap: true,\n                beforeDonate: false,\n                afterDonate: false,\n                beforeSwapReturnDelta: false,\n                afterSwapReturnDelta: false,\n                afterAddLiquidityReturnDelta: false,\n                afterRemoveLiquidityReturnDelta: false\n            });\n    }\n}\n')),(0,a.kt)("p",null,"The above code does the following:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"import the relevant dependencies"),(0,a.kt)("li",{parentName:"ul"},"initialize the constructor by passing in the instance of PoolManager"),(0,a.kt)("li",{parentName:"ul"},"override ",(0,a.kt)("inlineCode",{parentName:"li"},"getHookPermissions")," from ",(0,a.kt)("inlineCode",{parentName:"li"},"BaseHook.sol")," to return a struct of permissions to signal which hook functions are to be implemented.\nIt will also be used at deployment to validate the address correctly represents the expected permissions.")),(0,a.kt)("p",null,"Awesome! Now it's all set to start building the hook!"),(0,a.kt)("h2",{id:"basic-structure"},"Basic Structure"),(0,a.kt)("p",null,"So far, we\u2019ve created the file named ",(0,a.kt)("inlineCode",{parentName:"p"},"PointsHook.sol")," which only contains the outline of a hook contract. Let\u2019s add our ",(0,a.kt)("inlineCode",{parentName:"p"},"afterSwap")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"afterAddLiquidity")," hooks to it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"contract PointsHook is BaseHook {\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    function getHookPermissions()\n        public\n        pure\n        override\n        returns (Hooks.Permissions memory)\n    {\n        return\n            Hooks.Permissions({\n                beforeInitialize: false,\n                afterInitialize: false,\n                beforeAddLiquidity: false,\n                afterAddLiquidity: true,\n                beforeRemoveLiquidity: false,\n                afterRemoveLiquidity: false,\n                beforeSwap: false,\n                afterSwap: true,\n                beforeDonate: false,\n                afterDonate: false,\n                beforeSwapReturnDelta: false,\n                afterSwapReturnDelta: false,\n                afterAddLiquidityReturnDelta: false,\n                afterRemoveLiquidityReturnDelta: false\n            });\n    }\n\n    function _afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata,\n        BalanceDelta delta,\n        bytes calldata\n    ) internal override returns (bytes4, int128) {\n        return (BaseHook.afterSwap.selector, 0);\n    }\n\n    function _afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) internal override returns (bytes4, BalanceDelta) {\n        return (BaseHook.afterAddLiquidity.selector, delta);\n    }\n}\n")),(0,a.kt)("p",null,"You\u2019ll notice that both hooks return their own selector in the functions, this is a pattern used by the protocol to signal \u201csuccessful\u201d invocation. We\u2019ll talk about rest of the return parameters when we start adding the functionality."),(0,a.kt)("p",null,"Most of the code at this point should be self-explanatory. It\u2019s not doing anything yet, but it\u2019s a great place to start adding the functionality we need."),(0,a.kt)("h2",{id:"points-logic"},"Points Logic"),(0,a.kt)("p",null,"First, let\u2019s setup the ",(0,a.kt)("inlineCode",{parentName:"p"},"POINTS")," token that we\u2019ll reward users with via creating another contract ",(0,a.kt)("inlineCode",{parentName:"p"},"PointsToken.sol")," and import relevant dependencies like ",(0,a.kt)("inlineCode",{parentName:"p"},"ERC20")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Owned"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'contract PointsToken is ERC20, Owned {\n    constructor() ERC20("Points Token", "POINTS", 18) Owned(msg.sender) {}\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n}\n')),(0,a.kt)("p",null,"Let\u2019s make it so that our hook can mint some!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"contract PointsHook is BaseHook {\n    PointsToken pointsToken;\n\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {\n        pointsToken = new PointsToken();\n    }\n\n    [...]\n}\n")),(0,a.kt)("p",null,"Next, we need to calculate how many points to assign based on the ",(0,a.kt)("inlineCode",{parentName:"p"},"ETH")," value of the swap or liquidity action. We\u2019ll be awarding ",(0,a.kt)("inlineCode",{parentName:"p"},"POINTS")," in 1:1 ratio for the ",(0,a.kt)("inlineCode",{parentName:"p"},"ETH"),", so if the user swapped 1 ",(0,a.kt)("inlineCode",{parentName:"p"},"ETH"),", we\u2019ll give them 1 ",(0,a.kt)("inlineCode",{parentName:"p"},"POINTS"),". Let\u2019s also create a function to award these to the user."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    function getPointsForAmount(\n        uint256 amount\n    ) internal pure returns (uint256) {\n        return amount; // 1:1 with ETH\n    }\n\n    function awardPoints(address to, uint256 amount) internal {\n        pointsToken.mint(to, getPointsForAmount(amount));\n    }\n")),(0,a.kt)("h2",{id:"hook-logic"},"Hook Logic"),(0,a.kt)("p",null,"Now we need to actually get the value that the user is swapping or adding liquidity with. We\u2019ll be using the two hooks to achieve that functionality."),(0,a.kt)("h3",{id:"getting-the-user-address"},"Getting the user address"),(0,a.kt)("p",null,"Before we go into the logic for the hook, we have a side quest! How do we actually get the address of the user? The ",(0,a.kt)("inlineCode",{parentName:"p"},"PositionManager")," doesn\u2019t pass the user address directly to the hook, mainly because of the complexity of getting that data in the first place."),(0,a.kt)("p",null,"You\u2019d have noticed, both of our hooks have a ",(0,a.kt)("inlineCode",{parentName:"p"},"hookData")," field at the end. This allows any arbitrary data to be passed to the hook at the time of invocation, and we\u2019ll use this field to encode the user address."),(0,a.kt)("p",null,"Let\u2019s create some helper functions to encode and decode this data:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    function getHookData(address user) public pure returns (bytes memory) {\n        return abi.encode(user);\n    }\n\n    function parseHookData(\n        bytes calldata data\n    ) public pure returns (address user) {\n        return abi.decode(data, (address));\n    }\n")),(0,a.kt)("h3",{id:"hook-logic-afterswap"},"Hook Logic: ",(0,a.kt)("inlineCode",{parentName:"h3"},"afterSwap")),(0,a.kt)("p",null,"In order for us to award these points to the user, we need a few things and we also need to create a few conditions."),(0,a.kt)("p",null,"Let\u2019s start with the most basic ones. We want the user to be swapping in the ",(0,a.kt)("inlineCode",{parentName:"p"},"ETH/TOKEN")," pool and be buying the ",(0,a.kt)("inlineCode",{parentName:"p"},"TOKEN")," in order to get awarded these ",(0,a.kt)("inlineCode",{parentName:"p"},"POINTS")," token. Next, we need to figure out who the user is and how much ETH they are spending, and finally award the points accordingly."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    function _afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata swapParams,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) internal override onlyPoolManager returns (bytes4, int128) {\n        // We only award points in the ETH/TOKEN pools.\n        if (!key.currency0.isAddressZero()) {\n            return (BaseHook.afterSwap.selector, 0);\n        }\n\n        // We only award points if the user is buying the TOKEN\n        if (!swapParams.zeroForOne) {\n            return (BaseHook.afterSwap.selector, 0);\n        }\n\n        // Let's figure out who's the user\n        address user = parseHookData(hookData);\n\n        // How much ETH are they spending?\n        uint256 ethSpendAmount = uint256(int256(-delta.amount0()));\n\n        // And award the points!\n        awardPoints(user, ethSpendAmount);\n\n        return (BaseHook.afterSwap.selector, 0);\n    }\n")),(0,a.kt)("p",null,"That middle section about figuring out how much ",(0,a.kt)("inlineCode",{parentName:"p"},"ETH")," the user spent seems a little fishy, what\u2019s going on there? Let\u2019s break it down."),(0,a.kt)("p",null,"When ",(0,a.kt)("inlineCode",{parentName:"p"},"amountSpecified")," is less than 0, it means this is an ",(0,a.kt)("inlineCode",{parentName:"p"},"exact input for output")," swap, essentially where the user is coming in with an exact amount of ETH. In the other case, it\u2019s an ",(0,a.kt)("inlineCode",{parentName:"p"},"exact output for input")," swap, where the user is expecting a specific amount out. In our case, we get this from the precalculated ",(0,a.kt)("inlineCode",{parentName:"p"},"delta")," that Uniswap V4 gives us as a part of the ",(0,a.kt)("inlineCode",{parentName:"p"},"afterSwap")," hook."),(0,a.kt)("h3",{id:"hook-logic-afteraddliquidity"},"Hook Logic: ",(0,a.kt)("inlineCode",{parentName:"h3"},"afterAddLiquidity")),(0,a.kt)("p",null,"Similar to what we did for the ",(0,a.kt)("inlineCode",{parentName:"p"},"afterSwap")," hook, now we need to award users for adding liquidity. We\u2019ll do the exact same thing here, except we\u2019ll award the points based on the added liquidity."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    function _afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) internal override onlyPoolManager returns (bytes4, BalanceDelta) {\n        // We only award points in the ETH/TOKEN pools.\n        if (!key.currency0.isAddressZero()) {\n            return (BaseHook.afterAddLiquidity.selector, delta);\n        }\n\n        // Let's figure out who's the user\n        address user = parseHookData(hookData);\n\n        // How much ETH are they spending?\n        uint256 ethSpendAmount = uint256(int256(-delta.amount0()));\n\n        // And award the points!\n        awardPoints(user, ethSpendAmount);\n\n        return (BaseHook.afterAddLiquidity.selector, delta);\n    }\n")),(0,a.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"It is important to note that the delta should be passed to awardPoints function as it avoids amount errors in case of partial fills."))),(0,a.kt)("h1",{id:"testing"},"Testing"),(0,a.kt)("p",null,"We\u2019re using Foundry for building our hook, and we\u2019ll continue using it to write our tests. One of the great things about Foundry is that you can write tests in Solidity itself instead of context switching between another language."),(0,a.kt)("h3",{id:"test-suite"},"Test Suite"),(0,a.kt)("p",null,"The v4-template repo you cloned already has an existing base test file, let\u2019s start by copying it into ",(0,a.kt)("inlineCode",{parentName:"p"},"PointsHook.t.sol"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'contract PointsHookTest is Test, Fixtures {\n    using EasyPosm for IPositionManager;\n    using StateLibrary for IPoolManager;\n\n    PointsHook hook;\n    PointsToken pointsToken;\n    PoolId poolId;\n\n    uint256 tokenId;\n    int24 tickLower;\n    int24 tickUpper;\n\n    function setUp() public {\n        // creates the pool manager, utility routers, and test tokens\n        deployFreshManagerAndRouters();\n        deployMintAndApprove2Currencies();\n\n        deployAndApprovePosm(manager);\n\n        // Deploy the hook to an address with the correct flags\n        address flags = address(\n            uint160(Hooks.AFTER_SWAP_FLAG | Hooks.AFTER_ADD_LIQUIDITY_FLAG) ^\n                (0x4444 << 144) // Namespace the hook to avoid collisions\n        );\n        bytes memory constructorArgs = abi.encode(manager); //Add all the necessary constructor arguments from the hook\n        deployCodeTo("PointsHook.sol:PointsHook", constructorArgs, flags);\n        hook = PointsHook(flags);\n        pointsToken = hook.pointsToken();\n\n        // Create the pool\n        key = PoolKey(\n            Currency.wrap(address(0)),\n            currency1,\n            3000,\n            60,\n            IHooks(hook)\n        );\n        poolId = key.toId();\n        manager.initialize(key, SQRT_PRICE_1_1, ZERO_BYTES);\n\n        // Provide full-range liquidity to the pool\n        tickLower = TickMath.minUsableTick(key.tickSpacing);\n        tickUpper = TickMath.maxUsableTick(key.tickSpacing);\n\n        deal(address(this), 200 ether);\n\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts\n            .getAmountsForLiquidity(\n                SQRT_PRICE_1_1,\n                TickMath.getSqrtPriceAtTick(tickLower),\n                TickMath.getSqrtPriceAtTick(tickUpper),\n                uint128(100e18)\n            );\n\n        (tokenId, ) = posm.mint(\n            key,\n            tickLower,\n            tickUpper,\n            100e18,\n            amount0 + 1,\n            amount1 + 1,\n            address(this),\n            block.timestamp,\n            hook.getHookData(address(this))\n        );\n    }\n\n    function test_PointsHook_Swap() public {\n        // [code here]\n    }\n}\n')),(0,a.kt)("p",null,"So far this test setup is fairly simple, we create a bunch of tokens and deploy v4 along with the position manager inside our test. Then, we create a pool with our hook and add some liquidity using the position manager."),(0,a.kt)("p",null,"Now, let\u2019s write our test. We\u2019ll start by testing the points awarded during the swap."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    function test_PointsHook_Swap() public {\n        // We already have some points because we added some liquidity during setup.\n        // So, we'll subtract those from the total points to get the points awarded for this swap.\n        uint256 startingPoints = pointsToken.balanceOf(address(this));\n\n        // Let's swap some ETH for the token.\n        bool zeroForOne = true;\n        int256 amountSpecified = -1e18; // negative number indicates exact input swap!\n        BalanceDelta swapDelta = swap(\n            key,\n            zeroForOne,\n            amountSpecified,\n            hook.getHookData(address(this))\n        );\n\n        uint256 endingPoints = pointsToken.balanceOf(address(this));\n\n        // Let's make sure we got the right amount of points!\n        assertEq(\n            endingPoints - startingPoints,\n            uint256(-amountSpecified),\n            \"Points awarded for swap should be 1:1 with ETH\"\n        );\n    }\n")),(0,a.kt)("p",null,"This test case is fairly straightforward and simply swaps 1 ETH for the target token and compares if we got the right amount of points awarded for it."),(0,a.kt)("p",null,"Next, we should test our liquidity addition."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function test_PointsHook_Liquidity() public {\n        // We already have some points because we added some liquidity during setup.\n        // So, we'll subtract those from the total points to get the points awarded for this swap.\n        uint256 startingPoints = pointsToken.balanceOf(address(this));\n\n        uint128 liqToAdd = 100e18;\n\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts\n            .getAmountsForLiquidity(\n                SQRT_PRICE_1_1,\n                TickMath.getSqrtPriceAtTick(tickLower),\n                TickMath.getSqrtPriceAtTick(tickUpper),\n                liqToAdd\n            );\n\n        posm.mint(\n            key,\n            tickLower,\n            tickUpper,\n            liqToAdd,\n            amount0 + 1,\n            amount1 + 1,\n            address(this),\n            block.timestamp,\n            hook.getHookData(address(this))\n        );\n\n        uint256 endingPoints = pointsToken.balanceOf(address(this));\n\n        // Let's make sure we got the right amount of points!\n        assertApproxEqAbs(endingPoints - startingPoints, uint256(liqToAdd), 10);\n    }\n")),(0,a.kt)("p",null,"This test case looks very similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"afterSwap")," one, except we\u2019re testing based on the liquidity added. You\u2019ll notice at the end we\u2019re testing for approximate equality within 10 points. This is to account for minor differences in actual liquidity added due to ticks and pricing."),(0,a.kt)("h1",{id:"next-steps"},"Next Steps"),(0,a.kt)("p",null,"Congratulations on building your very first hook! You could explore further by going to ",(0,a.kt)("a",{parentName:"p",href:"/docs/contracts/v4/guides/hooks/hook-deployment"},"Hook Deployment")," to learn about how hook flags work and see how we will deploy a hook in action."))}p.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(n),h=a,k=c["".concat(l,".").concat(h)]||c[h]||p[h]||i;return n?o.createElement(k,r(r({ref:t},u),{},{components:n})):o.createElement(k,r({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var d=2;d<i;d++)r[d]=n[d];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);