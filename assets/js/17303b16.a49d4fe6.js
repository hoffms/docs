"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[24057],{29658:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var n=a(83117),r=(a(67294),a(3905));const l={title:"IPoolManager"},o=void 0,i={unversionedId:"contracts/v4/reference/core/IPoolManager",id:"contracts/v4/reference/core/IPoolManager",title:"IPoolManager",description:"The IPoolManager interface defines the main methods for interacting with the Uniswap V4 pool manager contract. It exposes the core swap lifecycle operations",source:"@site/docs/contracts/v4/reference/core/IPoolManager.mdx",sourceDirName:"contracts/v4/reference/core",slug:"/contracts/v4/reference/core/IPoolManager",permalink:"/docs/contracts/v4/reference/core/IPoolManager",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/v4/reference/core/IPoolManager.mdx",tags:[],version:"current",frontMatter:{title:"IPoolManager"},sidebar:"contractsSidebar",previous:{title:"Exttload",permalink:"/docs/contracts/v4/reference/core/Exttload"},next:{title:"NoDelegateCall",permalink:"/docs/contracts/v4/reference/core/NoDelegateCall"}},p={},u=[{value:"initialize",id:"initialize",level:2},{value:"unlock",id:"unlock",level:2},{value:"modifyLiquidity",id:"modifyliquidity",level:2},{value:"swap",id:"swap",level:2},{value:"donate",id:"donate",level:2}],d={toc:u};function m(t){let{components:e,...a}=t;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"IPoolManager")," interface defines the main methods for interacting with the Uniswap V4 pool manager contract. It exposes the core ",(0,r.kt)("em",{parentName:"p"},"swap lifecycle")," operations"),(0,r.kt)("h1",{id:"modifyliquidityparams"},"ModifyLiquidityParams"),(0,r.kt)("p",null,"Structure used to modify liquidity in a pool."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tickLower"),": Lower tick boundary of the position"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tickUpper"),": Upper tick boundary of the position"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"liquidityDelta"),": Amount of liquidity to add (positive) or remove (negative)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"salt"),": A value to set if you want unique liquidity positions at the same range ")),(0,r.kt)("p",null,"Used in the ",(0,r.kt)("inlineCode",{parentName:"p"},"modifyLiquidity")," function to add or remove liquidity from a specific position in the pool."),(0,r.kt)("h1",{id:"swapparams"},"SwapParams"),(0,r.kt)("p",null,"Structure used to execute a swap in a pool."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"zeroForOne"),": Direction of the swap (true for token0 to token1, false for token1 to token0)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"amountSpecified"),": The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sqrtPriceLimitX96"),": Slippage limit represented as ",(0,r.kt)("a",{parentName:"li",href:"https://uniswapv3book.com/milestone_3/more-on-fixed-point-numbers.html#:~:text=The%20Q64.,and%2018%20signify%20decimal%20places."},"Q64X96")," notation")),(0,r.kt)("p",null,"Used in the ",(0,r.kt)("inlineCode",{parentName:"p"},"swap")," function to define the behavior of our swap."),(0,r.kt)("h1",{id:"methods"},"Methods"),(0,r.kt)("h2",{id:"initialize"},"initialize"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function initialize(PoolKey memory key, uint160 sqrtPriceX96)\n    external\n    returns (int24 tick);\n")),(0,r.kt)("p",null,"Initialize a new pool by defining its parameters: token pair, fee tier, tick spacing, hook contract, and starting price"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key"),(0,r.kt)("td",{parentName:"tr",align:null},"PoolKey"),(0,r.kt)("td",{parentName:"tr",align:null},"The key defining the pool to initialize")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sqrtPriceX96"),(0,r.kt)("td",{parentName:"tr",align:null},"uint160"),(0,r.kt)("td",{parentName:"tr",align:null},"The initial sqrt price of the pool as a Q64.96 value")))),(0,r.kt)("p",null,"Returns the initial tick value of the pool."),(0,r.kt)("h2",{id:"unlock"},"unlock"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function unlock(bytes calldata data) external returns (bytes memory);\n")),(0,r.kt)("p",null,"Provides a single entry point for all pool operations. The provided data is passed to the callback for execution."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data"),(0,r.kt)("td",{parentName:"tr",align:null},"bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"Any data to pass to the callback via ",(0,r.kt)("inlineCode",{parentName:"td"},"IUnlockCallback(msg.sender).unlockCallback(data)"))))),(0,r.kt)("p",null,"Returns the data returned by the callback."),(0,r.kt)("h2",{id:"modifyliquidity"},"modifyLiquidity"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function modifyLiquidity(\n    PoolKey memory key,\n    ModifyLiquidityParams memory params,\n    bytes calldata hookData\n) external returns (BalanceDelta, BalanceDelta);\n")),(0,r.kt)("p",null,"Modifies the liquidity for the given pool. Can be used to add or remove liquidity, or collect fees"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"passing zero will collect fees for the given tick range")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key"),(0,r.kt)("td",{parentName:"tr",align:null},"PoolKey"),(0,r.kt)("td",{parentName:"tr",align:null},"The key of the pool to modify liquidity in")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"params"),(0,r.kt)("td",{parentName:"tr",align:null},"ModifyLiquidityParams"),(0,r.kt)("td",{parentName:"tr",align:null},"The parameters for modifying the liquidity position")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hookData"),(0,r.kt)("td",{parentName:"tr",align:null},"bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"Any data to pass to a hook contract on the before/add liquidity hooks")))),(0,r.kt)("p",null,"Returns the balance delta for the caller (total of principal and fees) and the fee delta generated in the liquidity range."),(0,r.kt)("h2",{id:"swap"},"swap"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n    external\n    returns (BalanceDelta);\n")),(0,r.kt)("p",null,"Executes a swap against the given pool using the provided parameters."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key"),(0,r.kt)("td",{parentName:"tr",align:null},"PoolKey"),(0,r.kt)("td",{parentName:"tr",align:null},"The key of the pool to swap in")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"params"),(0,r.kt)("td",{parentName:"tr",align:null},"SwapParams"),(0,r.kt)("td",{parentName:"tr",align:null},"The parameters for executing the swap")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hookData"),(0,r.kt)("td",{parentName:"tr",align:null},"bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"Any data to pass to a hook contract on the before/afterSwap hooks")))),(0,r.kt)("p",null,"Returns the balance delta for the address initiating the swap. Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified. Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG, the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta."),(0,r.kt)("h2",{id:"donate"},"donate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n    external\n    returns (BalanceDelta);\n")),(0,r.kt)("p",null,"Donates the specified currency amounts to the pool."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key"),(0,r.kt)("td",{parentName:"tr",align:null},"PoolKey"),(0,r.kt)("td",{parentName:"tr",align:null},"The key of the pool to donate to")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"amount0"),(0,r.kt)("td",{parentName:"tr",align:null},"uint256"),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of token0 to donate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"amount1"),(0,r.kt)("td",{parentName:"tr",align:null},"uint256"),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of token1 to donate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hookData"),(0,r.kt)("td",{parentName:"tr",align:null},"bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"Any data to pass to a hook contract  on the before/afterDonate hooks")))),(0,r.kt)("p",null,"Returns the balance delta representing the donated amounts."))}m.isMDXComponent=!0},3905:(t,e,a)=>{a.d(e,{Zo:()=>d,kt:()=>c});var n=a(67294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function o(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function i(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var p=n.createContext({}),u=function(t){var e=n.useContext(p),a=e;return t&&(a="function"==typeof t?t(e):o(o({},e),t)),a},d=function(t){var e=u(t.components);return n.createElement(p.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},s=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,p=t.parentName,d=i(t,["components","mdxType","originalType","parentName"]),s=u(a),c=r,k=s["".concat(p,".").concat(c)]||s[c]||m[c]||l;return a?n.createElement(k,o(o({ref:e},d),{},{components:a})):n.createElement(k,o({ref:e},d))}));function c(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,o=new Array(l);o[0]=s;var i={};for(var p in e)hasOwnProperty.call(e,p)&&(i[p]=e[p]);i.originalType=t,i.mdxType="string"==typeof t?t:r,o[1]=i;for(var u=2;u<l;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}s.displayName="MDXCreateElement"}}]);