"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[25527],{40524:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(83117),o=(n(67294),n(3905));const r={id:"calling-flash",title:"Calling Flash",sidebar_position:2},l=void 0,s={unversionedId:"contracts/v3/guides/flash-integrations/calling-flash",id:"contracts/v3/guides/flash-integrations/calling-flash",title:"Calling Flash",description:"Parameter Structs",source:"@site/docs/contracts/v3/guides/flash-integrations/calling-flash.md",sourceDirName:"contracts/v3/guides/flash-integrations",slug:"/contracts/v3/guides/flash-integrations/calling-flash",permalink:"/docs/contracts/v3/guides/flash-integrations/calling-flash",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/v3/guides/flash-integrations/calling-flash.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"calling-flash",title:"Calling Flash",sidebar_position:2},sidebar:"contractsSidebar",previous:{title:"Getting Started",permalink:"/docs/contracts/v3/guides/flash-integrations/inheritance-constructors"},next:{title:"The Flash Callback",permalink:"/docs/contracts/v3/guides/flash-integrations/flash-callback"}},i={},p=[{value:"Parameter Structs",id:"parameter-structs",level:2},{value:"Pool Key",id:"pool-key",level:2},{value:"Calling Flash",id:"calling-flash",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"parameter-structs"},"Parameter Structs"),(0,o.kt)("p",null,"In order to call ",(0,o.kt)("inlineCode",{parentName:"p"},"flash"),", we will need the flash parameters for the initial call, as well as any parameters we want to pass through to the callback."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"FlashParams")," struct will contain the token addresses and amounts we wish to pull out of the pool, as well as the three fee tiers used to determine which pool we are withdrawing from, and which we will be swapping with."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  struct FlashParams {\n        address token0;\n        address token1;\n        uint24 fee1;\n        uint256 amount0;\n        uint256 amount1;\n        uint24 fee2;\n        uint24 fee3;\n    }\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"FlashCallbackData")," struct will contain the data we want to send to the callback. This includes ",(0,o.kt)("inlineCode",{parentName:"p"},"poolKey"),", which expresses the sorted tokens with the matched fee tier, returned by the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/PoolAddress.sol"},(0,o.kt)("strong",{parentName:"a"},"PoolAddress"))," library."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    struct FlashCallbackData {\n        uint256 amount0;\n        uint256 amount1;\n        address payer;\n        PoolAddress.PoolKey poolKey;\n        uint24 poolFee2;\n        uint24 poolFee3;\n    }\n")),(0,o.kt)("h2",{id:"pool-key"},"Pool Key"),(0,o.kt)("p",null,"Now we'll start our function by assigning the relevant parameters from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Flashparams")," (which we have declared in memory as ",(0,o.kt)("inlineCode",{parentName:"p"},"params"),") to our variable ",(0,o.kt)("inlineCode",{parentName:"p"},"poolKey")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    function initFlash(FlashParams memory params) external {\n        PoolAddress.PoolKey memory poolKey =\n            PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee1});\n    }\n")),(0,o.kt)("p",null,"Next we will declare ",(0,o.kt)("inlineCode",{parentName:"p"},"pool")," as type ","[",(0,o.kt)("strong",{parentName:"p"},"IUniswapV3Pool"),"]",", which allows us to call ",(0,o.kt)("inlineCode",{parentName:"p"},"flash")," on our desired pool contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"        IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));\n")),(0,o.kt)("h2",{id:"calling-flash"},"Calling Flash"),(0,o.kt)("p",null,"Finally, we call ",(0,o.kt)("inlineCode",{parentName:"p"},"flash")," on our previously declared ",(0,o.kt)("inlineCode",{parentName:"p"},"pool"),". In the last parameter, we abi.encode the ",(0,o.kt)("inlineCode",{parentName:"p"},"FlashCallbackData"),", which will be decoded in the callback and used to inform the next steps of the transaction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"        pool.flash(\n            address(this),\n            params.amount0,\n            params.amount1,\n            abi.encode(\n                FlashCallbackData({\n                    amount0: params.amount0,\n                    amount1: params.amount1,\n                    payer: msg.sender,\n                    poolKey: poolKey,\n                    poolFee2: params.fee2,\n                    poolFee3: params.fee3\n                })\n            )\n        );\n")),(0,o.kt)("p",null,"The full function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    //fee1 is the fee of the pool from the initial borrow\n    //fee2 is the fee of the first pool to arb from\n    //fee3 is the fee of the second pool to arb from\n    struct FlashParams {\n        address token0;\n        address token1;\n        uint24 fee1;\n        uint256 amount0;\n        uint256 amount1;\n        uint24 fee2;\n        uint24 fee3;\n    }\n\n    // fee2 and fee3 are the two other fees associated with the two other pools of token0 and token1\n    struct FlashCallbackData {\n        uint256 amount0;\n        uint256 amount1;\n        address payer;\n        PoolAddress.PoolKey poolKey;\n        uint24 poolFee2;\n        uint24 poolFee3;\n    }\n\nfunction initFlash(FlashParams memory params) external {\n        PoolAddress.PoolKey memory poolKey =\n            PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee1});\n        IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));\n        pool.flash(\n            address(this),\n            params.amount0,\n            params.amount1,\n            abi.encode(\n                FlashCallbackData({\n                    amount0: params.amount0,\n                    amount1: params.amount1,\n                    payer: msg.sender,\n                    poolKey: poolKey,\n                    poolFee2: params.fee2,\n                    poolFee3: params.fee3\n                })\n            )\n        );\n    }\n")))}u.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=a.createContext({}),p=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=o,h=d["".concat(i,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,l=new Array(r);l[0]=d;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:o,l[1]=s;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);