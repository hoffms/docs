"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[47777],{18847:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var i=t(83117),o=(t(67294),t(3905));const a={title:"Position Manager"},r="Introduction",s={unversionedId:"contracts/v4/guides/position-manager",id:"contracts/v4/guides/position-manager",title:"Position Manager",description:"The Position Manager in v4 provides a streamlined way to manage liquidity positions through a command-based interface. Unlike previous versions where each operation required separate function calls, v4\u2019s Position Manager uses a batched command pattern that allows multiple operations to be executed in a single transaction.",source:"@site/docs/contracts/v4/guides/11-position-manager.mdx",sourceDirName:"contracts/v4/guides",slug:"/contracts/v4/guides/position-manager",permalink:"/docs/contracts/v4/guides/position-manager",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/v4/guides/11-position-manager.mdx",tags:[],version:"current",sidebarPosition:11,frontMatter:{title:"Position Manager"},sidebar:"contractsSidebar",previous:{title:"ERC-6909",permalink:"/docs/contracts/v4/guides/ERC-6909"},next:{title:"StateView",permalink:"/docs/contracts/v4/guides/state-view"}},l={},d=[{value:"Command-Based Design",id:"command-based-design",level:2},{value:"How Commands Work\xa0Together",id:"how-commands-worktogether",level:2},{value:"Action Types",id:"action-types",level:2},{value:"Understanding the\xa0Flow",id:"understanding-theflow",level:2},{value:"Liquidity Operations",id:"liquidity-operations",level:2},{value:"Delta-Resolving Operations",id:"delta-resolving-operations",level:2},{value:"Operation Order",id:"operation-order",level:2},{value:"Minting New Positions",id:"minting-new-positions",level:2},{value:"<strong>Understanding Position Parameters</strong>",id:"understanding-position-parameters",level:3},{value:"<strong>Implementation</strong>",id:"implementation",level:3},{value:"Increasing Liquidity",id:"increasing-liquidity",level:2},{value:"<strong>Understanding the Operation</strong>",id:"understanding-the-operation",level:3},{value:"<strong>Choosing the Right Delta Resolution</strong>",id:"choosing-the-right-delta-resolution",level:3},{value:"<strong>Implementation</strong>",id:"implementation-1",level:3},{value:"Decreasing Liquidity",id:"decreasing-liquidity",level:2},{value:"<strong>Understanding the Operation</strong>",id:"understanding-the-operation-1",level:3},{value:"<strong>Delta Resolution Options</strong>",id:"delta-resolution-options",level:3},{value:"<strong>Implementation</strong>",id:"implementation-2",level:3},{value:"Collecting Fees",id:"collecting-fees",level:2},{value:"<strong>Understanding Fee Collection</strong>",id:"understanding-fee-collection",level:3},{value:"<strong>Implementation</strong>",id:"implementation-3",level:3},{value:"Burning Positions",id:"burning-positions",level:2},{value:"<strong>Understanding Position Burning</strong>",id:"understanding-position-burning",level:3},{value:"<strong>Implementation</strong>",id:"implementation-4",level:3},{value:"Benefits of Batch Operations",id:"benefits-of-batch-operations",level:2},{value:"Implementation Guide",id:"implementation-guide",level:2},{value:"<strong>CLOSE_CURRENCY: Handling Unknown\xa0Deltas</strong>",id:"close_currency-handling-unknowndeltas",level:2},{value:"<strong>CLEAR_OR_TAKE: Optimizing for\xa0Dust</strong>",id:"clear_or_take-optimizing-fordust",level:2},{value:"<strong>SWEEP: Handling Excess\xa0Payments</strong>",id:"sweep-handling-excesspayments",level:2},{value:"<strong>Understanding modifyLiquiditiesWithoutUnlock</strong>",id:"understanding-modifyliquiditieswithoutunlock",level:2}],u={toc:d};function p(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"The Position Manager in v4 provides a streamlined way to manage liquidity positions through a command-based interface. Unlike previous versions where each operation required separate function calls, v4\u2019s Position Manager uses a batched command pattern that allows multiple operations to be executed in a single transaction."),(0,o.kt)("h2",{id:"command-based-design"},"Command-Based Design"),(0,o.kt)("p",null,"At its core, the Position Manager works by executing a sequence of commands:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Example: Minting a new position requires two commands\nbytes memory actions = abi.encodePacked(\n    Actions.MINT_POSITION,  // Create the position\n    Actions.SETTLE_PAIR     // Provide the tokens\n);\n")),(0,o.kt)("p",null,"Each command (or action) represents a specific operation, and these actions can be:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Liquidity Operations: Creating, modifying, or removing positions"),(0,o.kt)("li",{parentName:"ul"},"Delta-Resolving Operations: Handling token transfers and settlements")),(0,o.kt)("h2",{id:"how-commands-worktogether"},"How Commands Work\xa0Together"),(0,o.kt)("p",null,"When executing operations through the Position Manager, you\u2019ll always:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Define what actions to perform"),(0,o.kt)("li",{parentName:"ol"},"Provide the parameters for each action"),(0,o.kt)("li",{parentName:"ol"},"Execute them through a single function call")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// 1. Define actions\nbytes memory actions = abi.encodePacked(action1, action2);\n\n// 2. Encode parameters for each action\nbytes[] memory params = new bytes[](2);\nparams[0] = abi.encode(/* parameters for action1 */);\nparams[1] = abi.encode(/* parameters for action2 */);\n\n// 3. Execute through modifyLiquidities\npositionManager.modifyLiquidities(\n    abi.encode(actions, params),\n    deadline\n);\n")),(0,o.kt)("p",null,"This design enables efficient operations by:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Minimizing transaction costs through batching"),(0,o.kt)("li",{parentName:"ul"},"Allowing complex position management in single transactions"),(0,o.kt)("li",{parentName:"ul"},"Providing flexibility in how operations are combined")),(0,o.kt)("p",null,"In the following sections, we\u2019ll explore how to work with these commands and implement common liquidity management operations."),(0,o.kt)("h1",{id:"core-concepts"},"Core Concepts"),(0,o.kt)("p",null,"Before diving into specific operations, let\u2019s understand the key concepts that make up the Position Manager\u2019s architecture."),(0,o.kt)("h2",{id:"action-types"},"Action Types"),(0,o.kt)("p",null,"The Position Manager operates through a system of actions that work in pairs: when you perform a liquidity operation that changes position balances, you must also include actions to handle the resulting token movements."),(0,o.kt)("h2",{id:"understanding-theflow"},"Understanding the\xa0Flow"),(0,o.kt)("p",null,"When you execute a liquidity operation:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The operation creates deltas (token obligations)"),(0,o.kt)("li",{parentName:"ol"},"These deltas represent tokens that need to be paid or received"),(0,o.kt)("li",{parentName:"ol"},"Delta-resolving operations are then used to handle these token movements")),(0,o.kt)("h2",{id:"liquidity-operations"},"Liquidity Operations"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/contracts/v4/reference/periphery/libraries/Actions"},"Actions")," that modify positions in the pool:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Common liquidity operations\nuint256 constant MINT_POSITION = 0x02;       // Creates negative deltas (tokens needed for position)\nuint256 constant INCREASE_LIQUIDITY = 0x00;  // Creates negative deltas (tokens to add)\nuint256 constant DECREASE_LIQUIDITY = 0x01;  // Creates positive deltas (tokens to receive)\nuint256 constant BURN_6909 = 0x18;           // Creates positive deltas (tokens to receive)\n")),(0,o.kt)("p",null,"Each operation creates specific deltas that must be resolved:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Negative deltas when you need to provide tokens (mint, increase)"),(0,o.kt)("li",{parentName:"ul"},"Positive deltas when you\u2019re receiving tokens (decrease, burn)")),(0,o.kt)("h2",{id:"delta-resolving-operations"},"Delta-Resolving Operations"),(0,o.kt)("p",null,"Actions that handle the token transfers needed to resolve deltas:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Common delta-resolving operations\nuint256 constant SETTLE_PAIR = 0x0d;    // For negative deltas: Pay two tokens to the pool\nuint256 constant TAKE_PAIR = 0x11;      // For positive deltas: Receive two tokens from the pool\nuint256 constant CLOSE_CURRENCY = 0x12; // Handles either direction based on final delta\nuint256 constant CLEAR_OR_TAKE = 0x13;  // For small amounts: Take if worth it, else ignore\n")),(0,o.kt)("h2",{id:"operation-order"},"Operation Order"),(0,o.kt)("p",null,"Understanding how operations create and resolve deltas helps in ordering them efficiently:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Efficient: Group operations that create deltas, then resolve them together\nbytes memory actions = abi.encodePacked(\n    Actions.MINT_POSITION,      // First delta: -100 tokens\n    Actions.INCREASE_LIQUIDITY, // Second delta: -50 tokens\n    Actions.SETTLE_PAIR        // Resolve total: -150 tokens at once\n);\n\n// Less efficient: Resolving deltas multiple times\nbytes memory actions = abi.encodePacked(\n    Actions.MINT_POSITION,      // Delta: -100 tokens\n    Actions.SETTLE_PAIR,        // Resolve: -100 tokens\n    Actions.INCREASE_LIQUIDITY, // New delta: -50 tokens\n    Actions.SETTLE_PAIR        // Resolve again: -50 tokens\n);\n")),(0,o.kt)("p",null,"Best practices for ordering:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Group liquidity operations that create similar deltas (e.g., all negative or all positive)"),(0,o.kt)("li",{parentName:"ol"},"Resolve all deltas together at the end when possible"),(0,o.kt)("li",{parentName:"ol"},"Use ",(0,o.kt)("inlineCode",{parentName:"li"},"CLOSE_CURRENCY")," when you can't predict the final delta")),(0,o.kt)("h1",{id:"working-with-liquidity-positions"},"Working with Liquidity Positions"),(0,o.kt)("p",null,"When building on v4, you\u2019ll need to manage liquidity positions through the Position Manager. Let\u2019s walk through each operation, starting with creating new positions."),(0,o.kt)("h2",{id:"minting-new-positions"},"Minting New Positions"),(0,o.kt)("p",null,"To create a new liquidity position in v4, you\u2019ll need to:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Define your position parameters (pool, price range, amount)"),(0,o.kt)("li",{parentName:"ol"},"Mint the position NFT"),(0,o.kt)("li",{parentName:"ol"},"Provide the initial tokens")),(0,o.kt)("h3",{id:"understanding-position-parameters"},(0,o.kt)("strong",{parentName:"h3"},"Understanding Position Parameters")),(0,o.kt)("p",null,"Before minting, you need to determine:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Which pool you\u2019re providing liquidity to"),(0,o.kt)("li",{parentName:"ul"},"Your price range (defined by tick bounds)"),(0,o.kt)("li",{parentName:"ul"},"How much liquidity to provide"),(0,o.kt)("li",{parentName:"ul"},"Maximum amounts of tokens you\u2019re willing to spend")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Example position parameters\nPoolKey poolKey = // Your pool key\nint24 tickLower = -887272;   // Price range lower bound\nint24 tickUpper = 887272;    // Price range upper bound\nuint128 liquidity = 1000000; // Liquidity amount\nuint256 amount0Max = 1e18;   // Max 1 token0\nuint256 amount1Max = 1e18;   // Max 1 token1\n")),(0,o.kt)("h3",{id:"implementation"},(0,o.kt)("strong",{parentName:"h3"},"Implementation")),(0,o.kt)("p",null,"Let\u2019s implement a function to mint new liquidity positions step by step:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @notice Mints a new liquidity position\n/// @param poolKey The pool to provide liquidity to\n/// @param tickLower Lower bound of the price range\n/// @param tickUpper Upper bound of the price range\n/// @param liquidity Amount of liquidity to provide\n/// @param amount0Max Maximum amount of token0 to spend\n/// @param amount1Max Maximum amount of token1 to spend\n/// @param recipient Address that will own the position\nfunction mintNewPosition(\n    PoolKey calldata poolKey,\n    int24 tickLower,\n    int24 tickUpper,\n    uint256 liquidity,\n    uint128 amount0Max,\n    uint128 amount1Max,\n    address recipient\n) external returns (uint256 tokenId) {\n")),(0,o.kt)("p",null,"Define the sequence of operations needed for minting:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Define the sequence of operations:\n// 1. MINT_POSITION - Creates the position and calculates token requirements\n// 2. SETTLE_PAIR - Provides the tokens needed\nbytes memory actions = abi.encodePacked(\n    Actions.MINT_POSITION,\n    Actions.SETTLE_PAIR\n);\n")),(0,o.kt)("p",null,"Set up parameters for each action:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes[] memory params = new bytes[](2);\n\n// Parameters for MINT_POSITION\nparams[0] = abi.encode(\n    poolKey,     // Which pool to mint in\n    tickLower,   // Position's lower price bound\n    tickUpper,   // Position's upper price bound\n    liquidity,   // Amount of liquidity to mint\n    amount0Max,  // Maximum amount of token0 to use\n    amount1Max,  // Maximum amount of token1 to use\n    recipient,   // Who receives the NFT\n    \"\"           // No hook data needed\n);\n\n// Parameters for SETTLE_PAIR - specify tokens to provide\nparams[1] = abi.encode(\n    poolKey.currency0,  // First token to settle\n    poolKey.currency1   // Second token to settle\n);\n")),(0,o.kt)("p",null,"Finally, execute the mint operation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Execute the mint operation\npositionManager.modifyLiquidities(\n    abi.encode(actions, params),\n    block.timestamp + 60  // 60 second deadline\n);\n")),(0,o.kt)("h2",{id:"increasing-liquidity"},"Increasing Liquidity"),(0,o.kt)("p",null,"After a position is created, you might want to add more liquidity to it. This operation requires understanding how fee accumulation works since fees are credited to your position during an increase."),(0,o.kt)("h3",{id:"understanding-the-operation"},(0,o.kt)("strong",{parentName:"h3"},"Understanding the Operation")),(0,o.kt)("p",null,"When increasing liquidity:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The operation calculates the tokens needed based on current prices"),(0,o.kt)("li",{parentName:"ol"},"Any accumulated fees are ",(0,o.kt)("strong",{parentName:"li"},"automatically credited")," to your position"),(0,o.kt)("li",{parentName:"ol"},"In some cases, fee revenue might partially or fully cover the tokens needed")),(0,o.kt)("h3",{id:"choosing-the-right-delta-resolution"},(0,o.kt)("strong",{parentName:"h3"},"Choosing the Right Delta Resolution")),(0,o.kt)("p",null,"Unlike minting where we always use SETTLE_PAIR, increasing liquidity has different delta-resolving options depending on your scenario:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Standard Case"),": When you\u2019re providing new tokens")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes memory actions = abi.encodePacked(\n    Actions.INCREASE_LIQUIDITY,\n    Actions.SETTLE_PAIR\n);\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"2. Fee Conversion"),": When converting accumulated fees to liquidity"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes memory actions = abi.encodePacked(\n    Actions.INCREASE_LIQUIDITY,\n    Actions.CLOSE_CURRENCY,  // For token0\n    Actions.CLOSE_CURRENCY   // For token1\n);\n")),(0,o.kt)("h3",{id:"implementation-1"},(0,o.kt)("strong",{parentName:"h3"},"Implementation")),(0,o.kt)("p",null,"Here\u2019s how to implement a flexible increase liquidity function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @notice Increases liquidity in an existing position\n/// @param tokenId The ID of the position\n/// @param liquidityIncrease Amount of liquidity to add\n/// @param amount0Max Maximum amount of token0 to spend\n/// @param amount1Max Maximum amount of token1 to spend\n/// @param useFeesAsLiquidity Whether to use accumulated fees\nfunction increaseLiquidity(\n    uint256 tokenId,\n    uint128 liquidityIncrease,\n    uint256 amount0Max,\n    uint256 amount1Max,\n    bool useFeesAsLiquidity\n) external {\n")),(0,o.kt)("p",null,"Choose the appropriate delta resolution based on whether we\u2019re using fees:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Define the sequence of operations:\n// If using fees: Handle potential fee conversion\n// If not: Standard liquidity addition\nbytes memory actions;\nif (useFeesAsLiquidity) {\n    actions = abi.encodePacked(\n        Actions.INCREASE_LIQUIDITY,  // Add liquidity\n        Actions.CLOSE_CURRENCY,      // Handle token0 (might need to pay or receive)\n        Actions.CLOSE_CURRENCY       // Handle token1 (might need to pay or receive)\n    );\n} else {\n    actions = abi.encodePacked(\n        Actions.INCREASE_LIQUIDITY,  // Add liquidity\n        Actions.SETTLE_PAIR          // Provide tokens\n    );\n}\n")),(0,o.kt)("p",null,"Prepare parameters based on our chosen strategy:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// Number of parameters depends on our strategy\nbytes[] memory params = new bytes[](\n    useFeesAsLiquidity ? 3 : 2\n);\n\n// Parameters for INCREASE_LIQUIDITY\nparams[0] = abi.encode(\n    tokenId,           // Position to increase\n    liquidityIncrease, // Amount to add\n    amount0Max,        // Maximum token0 to spend\n    amount1Max,        // Maximum token1 to spend\n    ""                // No hook data needed\n);\n')),(0,o.kt)("p",null,"Set up delta resolution parameters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"if (useFeesAsLiquidity) {\n    // Using CLOSE_CURRENCY for automatic handling of each token\n    params[1] = abi.encode(currency0);  // Handle token0\n    params[2] = abi.encode(currency1);  // Handle token1\n} else {\n    // Standard SETTLE_PAIR for providing tokens\n    params[1] = abi.encode(currency0, currency1);\n}\n")),(0,o.kt)("p",null,"Execute the operation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Execute the increase\npositionManager.modifyLiquidities(\n    abi.encode(actions, params),\n    block.timestamp + 60  // 60 second deadline\n);\n}\n")),(0,o.kt)("h2",{id:"decreasing-liquidity"},"Decreasing Liquidity"),(0,o.kt)("p",null,"When you want to remove liquidity from a position, you\u2019ll need to handle both the liquidity reduction and any accumulated fees. Let\u2019s understand how to implement this effectively."),(0,o.kt)("h3",{id:"understanding-the-operation-1"},(0,o.kt)("strong",{parentName:"h3"},"Understanding the Operation")),(0,o.kt)("p",null,"Decreasing liquidity involves:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Specifying how much liquidity to remove"),(0,o.kt)("li",{parentName:"ol"},"Setting minimum amounts to receive (slippage protection)"),(0,o.kt)("li",{parentName:"ol"},"Collecting both the removed liquidity and any accumulated fees")),(0,o.kt)("h3",{id:"delta-resolution-options"},(0,o.kt)("strong",{parentName:"h3"},"Delta Resolution Options")),(0,o.kt)("p",null,"When decreasing liquidity, you\u2019ll receive tokens, so it's most common to receive a pair of tokens:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes memory actions = abi.encodePacked(\n    Actions.DECREASE_LIQUIDITY,\n    Actions.TAKE_PAIR\n);\n")),(0,o.kt)("h3",{id:"implementation-2"},(0,o.kt)("strong",{parentName:"h3"},"Implementation")),(0,o.kt)("p",null,"When removing liquidity from a position, you\u2019ll be able to receive tokens and any accumulated fees. Let\u2019s break down the implementation step by step."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @notice Removes liquidity from a position\n/// @param tokenId The ID of the position\n/// @param liquidityDecrease Amount of liquidity to remove\n/// @param amount0Min Minimum amount of token0 to receive\n/// @param amount1Min Minimum amount of token1 to receive\n/// @param recipient Address to receive the tokens\nfunction decreaseLiquidity(\n    uint256 tokenId,\n    uint128 liquidityDecrease,\n    uint256 amount0Min,\n    uint256 amount1Min,\n    address recipient\n) external {\n")),(0,o.kt)("p",null,"Prepare the parameters array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// Number of parameters depends on our strategy\nbytes[] memory params = new bytes[](2);\n\n// Parameters for DECREASE_LIQUIDITY\nparams[0] = abi.encode(\n    tokenId,           // Position to decrease\n    liquidityDecrease, // Amount to remove\n    amount0Min,        // Minimum token0 to receive\n    amount1Min,        // Minimum token1 to receive\n    ""                // No hook data needed\n);\n')),(0,o.kt)("p",null,"Set up delta resolution parameters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Parameters for TAKE_PAIR\nparams[1] = abi.encode(\n    currency0,\n    currency1,\n    recipient\n);\n")),(0,o.kt)("p",null,"Execute the operation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Execute the decrease\npositionManager.modifyLiquidities(\n    abi.encode(actions, params),\n    block.timestamp + 60  // 60 second deadline\n);\n")),(0,o.kt)("h2",{id:"collecting-fees"},"Collecting Fees"),(0,o.kt)("p",null,"In v4\u2019s Position Manager, there isn\u2019t a dedicated COLLECT command. Instead, ",(0,o.kt)("strong",{parentName:"p"},"fees are collected by using DECREASE_LIQUIDITY with zero liquidity"),". This pattern leverages the fact that fees are automatically credited during liquidity operations."),(0,o.kt)("h3",{id:"understanding-fee-collection"},(0,o.kt)("strong",{parentName:"h3"},"Understanding Fee Collection")),(0,o.kt)("p",null,"When collecting fees, you need to:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Perform a DECREASE_LIQUIDITY operation with zero liquidity"),(0,o.kt)("li",{parentName:"ol"},"Handle the positive deltas (the fees you\u2019re collecting)"),(0,o.kt)("li",{parentName:"ol"},"Specify where the fees should go")),(0,o.kt)("h3",{id:"implementation-3"},(0,o.kt)("strong",{parentName:"h3"},"Implementation")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @notice Collects accumulated fees from a position\n/// @param tokenId The ID of the position to collect fees from\n/// @param recipient Address that will receive the fees\nfunction collectFees(\n    uint256 tokenId,\n    address recipient\n) external {\n    // Define the sequence of operations\n    bytes memory actions = abi.encodePacked(\n        Actions.DECREASE_LIQUIDITY, // Remove liquidity\n        Actions.TAKE_PAIR           // Receive both tokens\n    );\n\n    // Prepare parameters array\n    bytes[] memory params = new bytes[](2);\n\n    // Parameters for DECREASE_LIQUIDITY\n    // All zeros since we're only collecting fees\n    params[0] = abi.encode(\n        tokenId,    // Position to collect from\n        0,          // No liquidity change\n        0,          // No minimum for token0 (fees can't be manipulated)\n        0,          // No minimum for token1\n        \"\"          // No hook data needed\n    );\n")),(0,o.kt)("p",null,"When collecting fees, we use a zero-liquidity decrease operation - this means we're not actually removing any liquidity from the position, we're just collecting accumulated fees."),(0,o.kt)("p",null,"And note that we set minimums to 0 for fee collection because fees cannot be manipulated in a front-run attack. This is different from other liquidity operations where setting appropriate minimum amounts is crucial for slippage protection."),(0,o.kt)("p",null,"Set up the fee collection parameters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    // Standard TAKE_PAIR for receiving all fees\n    params[1] = abi.encode(\n        currency0,\n        currency1,\n        recipient\n    );\n}\n")),(0,o.kt)("p",null,"Execute the fee collection:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Execute fee collection\npositionManager.modifyLiquidities(\n    abi.encode(actions, params),\n    block.timestamp + 60  // 60 second deadline\n);\n")),(0,o.kt)("h2",{id:"burning-positions"},"Burning Positions"),(0,o.kt)("p",null,"When you want to completely exit a position, burning is more efficient than removing liquidity and collecting fees separately. The BURN_POSITION command handles everything in a single operation."),(0,o.kt)("h3",{id:"understanding-position-burning"},(0,o.kt)("strong",{parentName:"h3"},"Understanding Position Burning")),(0,o.kt)("p",null,"A burn operation:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Removes all remaining liquidity from the pool"),(0,o.kt)("li",{parentName:"ul"},"Collects any accumulated fees"),(0,o.kt)("li",{parentName:"ul"},"Burns the position NFT"),(0,o.kt)("li",{parentName:"ul"},"Settles all tokens to a specified recipient")),(0,o.kt)("h3",{id:"implementation-4"},(0,o.kt)("strong",{parentName:"h3"},"Implementation")),(0,o.kt)("p",null,"Let\u2019s implement a position burning function step by step:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @notice Burns a position and receives all tokens\n/// @param tokenId The ID of the position to burn\n/// @param recipient Address that will receive the tokens\n/// @param amount0Min Minimum amount of token0 to receive\n/// @param amount1Min Minimum amount of token1 to receive\nfunction burnPosition(\n    uint256 tokenId,\n    address recipient,\n    uint256 amount0Min,\n    uint256 amount1Min\n) external {\n    // Define the sequence of operations:\n    // 1. BURN_POSITION - Removes the position and creates positive deltas\n    // 2. TAKE_PAIR - Sends all tokens to the recipient\n    bytes memory actions = abi.encodePacked(\n        Actions.BURN_POSITION,\n        Actions.TAKE_PAIR\n    );\n")),(0,o.kt)("p",null,"The burn operation requires two sets of parameters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'bytes[] memory params = new bytes[](2);\n\n// Parameters for BURN_POSITION\nparams[0] = abi.encode(\n    tokenId,      // Position to burn\n    amount0Min,   // Minimum token0 to receive\n    amount1Min,   // Minimum token1 to receive\n    ""            // No hook data needed\n);\n\n// Parameters for TAKE_PAIR - where tokens will go\nparams[1] = abi.encode(\n    currency0,   // First token\n    currency1,   // Second token\n    recipient    // Who receives the tokens\n);\n')),(0,o.kt)("p",null,"Finally, execute the operation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"positionManager.modifyLiquidities(\n    abi.encode(actions, params),\n    block.timestamp + 60\n);\n")),(0,o.kt)("h1",{id:"batch-operating-liquidity"},"Batch-Operating Liquidity"),(0,o.kt)("p",null,"The Position Manager\u2019s command-based design enables you to perform multiple liquidity operations in a single transaction. This is particularly valuable when managing multiple positions or performing complex liquidity management strategies, such as taking tokens from one position to increase liquidity of another position."),(0,o.kt)("h2",{id:"benefits-of-batch-operations"},"Benefits of Batch Operations"),(0,o.kt)("p",null,"When managing liquidity across multiple positions, batching operations provides significant advantages:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Reduced gas costs by combining token settlements"),(0,o.kt)("li",{parentName:"ul"},"Atomic execution of related operations"),(0,o.kt)("li",{parentName:"ul"},"Simplified token handling through combined delta resolution")),(0,o.kt)("h2",{id:"implementation-guide"},"Implementation Guide"),(0,o.kt)("p",null,"Let\u2019s implement a common scenario: rebalancing liquidity by creating a new position while closing an old one and collecting its fees. We\u2019ll go through it step by step."),(0,o.kt)("p",null,"First, let\u2019s define our parameters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @notice Rebalances liquidity by creating a new position and closing an old one\n/// @param newPositionParams Parameters for the new position\n/// @param oldPositionId Position to close and collect fees from\n/// @param recipient Address to receive tokens from closed position\nstruct NewPositionParams {\n    PoolKey poolKey;\n    int24 tickLower;\n    int24 tickUpper;\n    uint128 liquidity;\n    uint256 amount0Max;\n    uint256 amount1Max;\n}\n")),(0,o.kt)("p",null,"In this example, we will rebalance liquidity by closing the old position and opening a new position. For the sake of example, let's assume the user will have to transfer additional tokens. Note that capital from the first position is automatically used towards the second position through flash accounting."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function rebalanceLiquidity(\n    NewPositionParams calldata newPositionParams,\n    uint256 oldPositionId,\n    address recipient\n) external {\n    // Group liquidity operations first, then delta resolutions\n    bytes memory actions = abi.encodePacked(\n        Actions.BURN_POSITION,    // Remove old position\n        Actions.MINT_POSITION,    // Create new position\n        Actions.SETTLE_PAIR       // Provide tokens for new position\n    );\n")),(0,o.kt)("p",null,"Notice how we order our operations: liquidity operations first (MINT and BURN), followed by delta resolutions (SETTLE and TAKE). This ordering is crucial for gas efficiency."),(0,o.kt)("p",null,"Next, let\u2019s prepare our parameters array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// We need one parameter set for each action\nbytes[] memory params = new bytes[](3);\n")),(0,o.kt)("p",null,"Now, let\u2019s encode parameters for the old position:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// Parameters for BURN_POSITION\nparams[0] = abi.encode(\n    oldPositionId,\n    0,  // No minimum for token0 (consider adding slippage protection)\n    0,  // No minimum for token1\n    ""  // No hook data\n);\n')),(0,o.kt)("p",null,"Then for minting the new position:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// Parameters for MINT_POSITION\nparams[1] = abi.encode(\n    newPositionParams.poolKey,\n    newPositionParams.tickLower,\n    newPositionParams.tickUpper,\n    newPositionParams.liquidity,\n    newPositionParams.amount0Max,\n    newPositionParams.amount1Max,\n    address(this),  // New position owner\n    ""              // No hook data\n);\n')),(0,o.kt)("p",null,"Next, we handle token settlements. First for the new position:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Parameters for SETTLE_PAIR (providing tokens for new position)\nparams[2] = abi.encode(\n  newPositionParams.poolKey.currency0,\n  newPositionParams.poolKey.currency1\n);\n")),(0,o.kt)("p",null,"With everything prepared, we can execute our batch operation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Execute all operations atomically\npositionManager.modifyLiquidities(\n    abi.encode(actions, params),\n    block.timestamp + 60\n);\n    positionManager.modifyLiquidities(\n        abi.encode(actions, params),\n        block.timestamp + 60\n    );\n}\n")),(0,o.kt)("h1",{id:"delta-resolving-operations-1"},"Delta-Resolving Operations"),(0,o.kt)("p",null,"While we\u2019ve seen basic delta resolution using SETTLE_PAIR and TAKE_PAIR in previous sections, v4\u2019s Position Manager provides additional operations for handling more complex scenarios. Let\u2019s understand when and how to use each one."),(0,o.kt)("h2",{id:"close_currency-handling-unknowndeltas"},(0,o.kt)("strong",{parentName:"h2"},"CLOSE_CURRENCY: Handling Unknown\xa0Deltas")),(0,o.kt)("p",null,"When you can\u2019t predict whether you\u2019ll need to pay or receive tokens, CLOSE_CURRENCY automatically handles either case."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// Example scenario: Converting fees to liquidity\nbytes memory actions = abi.encodePacked(\n    Actions.INCREASE_LIQUIDITY,\n    Actions.CLOSE_CURRENCY  // Will automatically settle or take based on final delta\n);\n\nbytes[] memory params = new bytes[](2);\n\n// Parameters for INCREASE_LIQUIDITY\nparams[0] = abi.encode(\n    tokenId,\n    liquidityIncrease,\n    amount0Max,\n    amount1Max,\n    ""\n);\n\n// CLOSE_CURRENCY only needs the currency\nparams[1] = abi.encode(currency0);\n')),(0,o.kt)("p",null,"This is particularly useful when:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Converting fees to liquidity (fees might fully cover the increase)"),(0,o.kt)("li",{parentName:"ul"},"Complex operations where final deltas are uncertain"),(0,o.kt)("li",{parentName:"ul"},"Reducing code complexity by letting the protocol handle the direction")),(0,o.kt)("h2",{id:"clear_or_take-optimizing-fordust"},(0,o.kt)("strong",{parentName:"h2"},"CLEAR_OR_TAKE: Optimizing for\xa0Dust")),(0,o.kt)("p",null,"Sometimes receiving small token amounts costs more in gas than they\u2019re worth. CLEAR_OR_TAKE lets you specify a threshold:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Parameters for CLEAR_OR_TAKE\nparams[0] = abi.encode(\n    currency,     // The token to handle\n    threshold     // Minimum amount worth taking\n);\n")),(0,o.kt)("p",null,"If the amount to receive is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Above threshold: Tokens are taken (like TAKE_PAIR)"),(0,o.kt)("li",{parentName:"ul"},"Below threshold: Amount is forfeited, saving gas")),(0,o.kt)("p",null,"This is valuable for:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Operations where dust amounts can be ignored"),(0,o.kt)("li",{parentName:"ul"},"Gas optimization in production systems")),(0,o.kt)("h2",{id:"sweep-handling-excesspayments"},(0,o.kt)("strong",{parentName:"h2"},"SWEEP: Handling Excess\xa0Payments")),(0,o.kt)("p",null,"SWEEP helps recover any excess tokens sent to the PoolManager:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes memory actions = abi.encodePacked(\n    Actions.YOUR_MAIN_OPERATION,\n    Actions.SWEEP  // Add at the end to collect any excess\n);\n\n// Parameters for SWEEP\nparams[1] = abi.encode(\n    currency,   // Token to sweep\n    recipient   // Where to send excess tokens\n);\n")),(0,o.kt)("p",null,"Use SWEEP when:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Dealing with native ETH operations")),(0,o.kt)("li",{parentName:"ul"},"Conservative token approvals might result in excess"),(0,o.kt)("li",{parentName:"ul"},"Need to ensure all tokens are properly accounted for")),(0,o.kt)("h2",{id:"understanding-modifyliquiditieswithoutunlock"},(0,o.kt)("strong",{parentName:"h2"},"Understanding modifyLiquiditiesWithoutUnlock")),(0,o.kt)("p",null,"This function follows the same encoding and command patterns as ",(0,o.kt)("inlineCode",{parentName:"p"},"modifyLiquidity"),", but serves a specific purpose: it's used when the PoolManager is already unlocked. This is particularly useful in certain scenarios:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When called from hooks that are already executing within the PoolManager's lock/unlock cycle"),(0,o.kt)("li",{parentName:"ul"},"For operations like automatic fee compounding, where a hook might want to reinvest fees for users")),(0,o.kt)("p",null,"For example, a hook that automatically compounds fees for users would use ",(0,o.kt)("inlineCode",{parentName:"p"},"modifyLiquiditiesWithoutUnlock")," because the hook is already executing within the PoolManager's unlock context, and cannot re-unlock the PoolManager"))}p.isMDXComponent=!0},3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var i=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=i.createContext({}),d=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=d(e.components);return i.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},c=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(t),m=o,k=c["".concat(l,".").concat(m)]||c[m]||p[m]||a;return t?i.createElement(k,r(r({ref:n},u),{},{components:t})):i.createElement(k,r({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,r=new Array(a);r[0]=c;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var d=2;d<a;d++)r[d]=t[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}c.displayName="MDXCreateElement"}}]);