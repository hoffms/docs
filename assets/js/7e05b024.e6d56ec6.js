"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[40654],{58413:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(83117),o=(n(67294),n(3905));const i={title:"Swap"},r="Swapping on Uniswap v4",s={unversionedId:"contracts/v4/quickstart/swap",id:"contracts/v4/quickstart/swap",title:"Swap",description:"The Universal Router is a flexible, gas-efficient contract designed to execute complex swap operations across various protocols, including Uniswap v4. It serves as an intermediary between users and the Uniswap v4 PoolManager, handling the intricacies of swap execution.",source:"@site/docs/contracts/v4/quickstart/03-swap.mdx",sourceDirName:"contracts/v4/quickstart",slug:"/contracts/v4/quickstart/swap",permalink:"/docs/contracts/v4/quickstart/swap",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/v4/quickstart/03-swap.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Swap"},sidebar:"contractsSidebar",previous:{title:"Batch Modify",permalink:"/docs/contracts/v4/quickstart/manage-liquidity/batch-liquidity"},next:{title:"Set Up Local Environment",permalink:"/docs/contracts/v4/quickstart/hooks/setup"}},p={},l=[{value:"Step 1: Set Up the Project",id:"step-1-set-up-the-project",level:2},{value:"Step 2: Implement Token Approval with Permit2",id:"step-2-implement-token-approval-with-permit2",level:2},{value:"Step 3: Implementing a Swap\xa0Function",id:"step-3-implementing-a-swapfunction",level:2},{value:"3.1: Function Signature",id:"31-function-signature",level:3},{value:"3.2: Encoding the Swap Command",id:"32-encoding-the-swap-command",level:3},{value:"3.3: Action Encoding",id:"33-action-encoding",level:3},{value:"3.4: Preparing the Swap Inputs",id:"34-preparing-the-swap-inputs",level:3},{value:"3.5: Executing the Swap",id:"35-executing-the-swap",level:3},{value:"3.6: (Optional) Verifying the Swap Output",id:"36-optional-verifying-the-swap-output",level:3},{value:"3.7: Returning the Result",id:"37-returning-the-result",level:3}],u={toc:l};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"swapping-on-uniswap-v4"},"Swapping on Uniswap v4"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Universal Router")," is a flexible, gas-efficient contract designed to execute complex swap operations across various protocols, including Uniswap v4. It serves as an intermediary between users and the Uniswap v4 ",(0,o.kt)("inlineCode",{parentName:"p"},"PoolManager"),", handling the intricacies of swap execution."),(0,o.kt)("p",null,"Although it's technically possible to interact directly with the PoolManager contract for swaps, this approach is not recommended due to its complexity and potential inefficiencies. Instead, the Universal Router is the preferred method, as it abstracts away these complexities. By using the Universal Router, developers and users can ensure a more straightforward, efficient, and standardized approach to executing swaps on v4 pools, aligning with best practices for Uniswap interactions."),(0,o.kt)("h1",{id:"configuring-universal-router-for-uniswap-v4swaps"},"Configuring Universal Router for Uniswap v4\xa0Swaps"),(0,o.kt)("p",null,"Set up a foundry project and install the necessary dependencies:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"forge install uniswap/v4-core\nforge install uniswap/v4-periphery\nforge install uniswap/permit2\nforge install uniswap/universal-router\nforge install uniswap/v3-core\nforge install uniswap/v2-core\nforge install OpenZeppelin/openzeppelin-contracts\n")),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"remappings.txt"),", add the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"@uniswap/v4-core/=lib/v4-core/\n@uniswap/v4-periphery/=lib/v4-periphery/\n@uniswap/permit2/=lib/permit2/\n@uniswap/universal-router/=lib/universal-router/\n@uniswap/v3-core/=lib/v3-core/\n@uniswap/v2-core/=lib/v2-core/\n@openzeppelin/contracts/=lib/openzeppelin-contracts/\n[...]\n")),(0,o.kt)("h2",{id:"step-1-set-up-the-project"},"Step 1: Set Up the Project"),(0,o.kt)("p",null,"First, we need to set up our project and import the necessary dependencies. We'll create a new Solidity contract for our example."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport { UniversalRouter } from "@uniswap/universal-router/contracts/UniversalRouter.sol";\nimport { Commands } from "@uniswap/universal-router/contracts/libraries/Commands.sol";\nimport { IPoolManager } from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";\nimport { IV4Router } from "@uniswap/v4-periphery/src/interfaces/IV4Router.sol";\nimport { Actions } from "@uniswap/v4-periphery/src/libraries/Actions.sol";\nimport { IPermit2 } from "@uniswap/permit2/src/interfaces/IPermit2.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\ncontract Example {\n    using StateLibrary for IPoolManager;\n\n    UniversalRouter public immutable router;\n    IPoolManager public immutable poolManager;\n    IPermit2 public immutable permit2;\n\n    constructor(address _router, address _poolManager, address _permit2) {\n        router = UniversalRouter(_router);\n        poolManager = IPoolManager(_poolManager);\n        permit2 = IPermit2(_permit2);\n    }\n\n    // We\'ll add more functions here\n}\n')),(0,o.kt)("p",null,"In this step, we're importing the necessary contracts and interfaces:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"UniversalRouter"),": This will be our main interface for executing swaps. It provides a flexible way to interact with various Uniswap versions and other protocols."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Commands"),": This library contains the command definitions used by the UniversalRouter."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"IPoolManager"),": This interface is needed for interacting with Uniswap v4 pools. While we don't directly use it in our simple example, it's often necessary for more complex interactions with v4 pools."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"IPermit2"),": This interface allows us to interact with the Permit2 contract, which provides enhanced token approval functionality."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"StateLibrary"),": This provides optimized functions for interacting with the PoolManager's state. By using ",(0,o.kt)("inlineCode",{parentName:"li"},"StateLibrary"),", we can more efficiently read and manipulate pool states, which is crucial for many operations in Uniswap v4.")),(0,o.kt)("h2",{id:"step-2-implement-token-approval-with-permit2"},"Step 2: Implement Token Approval with Permit2"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"UniversalRouter")," integrates with ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/permit2"},"Permit2"),", to enable users to have more safety, flexibility, and control over their ERC20 token approvals."),(0,o.kt)("p",null,"Before we can execute swaps, we need to ensure our contract can transfer tokens. We\u2019ll implement a function to approve the Universal Router to spend tokens on behalf of our contract."),(0,o.kt)("p",null,"Here, for testing purposes, we set up our contract to use Permit2 with the UniversalRouter:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function approveTokenWithPermit2(\n    address token,\n    uint160 amount,\n    uint48 expiration\n) external {\n    IERC20(token).approve(address(permit2), type(uint256).max);\n    permit2.approve(token, address(router), amount, expiration);\n}\n")),(0,o.kt)("p",null,"This function first approves Permit2 to spend the token, then uses Permit2 to approve the UniversalRouter with a specific amount and expiration time."),(0,o.kt)("h2",{id:"step-3-implementing-a-swapfunction"},"Step 3: Implementing a Swap\xa0Function"),(0,o.kt)("h3",{id:"31-function-signature"},"3.1: Function Signature"),(0,o.kt)("p",null,"First, let\u2019s define our function signature:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function swapExactInputSingle(\n    PoolKey calldata key, // PoolKey struct that identifies the v4 pool\n    uint128 amountIn, // Exact amount of tokens to swap\n    uint128 minAmountOut, // Minimum amount of output tokens expected\n    uint256 deadline // Timestamp after which the transaction will revert\n) external returns (uint256 amountOut) {\n    // Implementation will follow\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Important note:")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The deadline parameter allows users to specify when their transaction should expire. This protects against unfavorable execution due to network delays or MEV attacks."),(0,o.kt)("li",{parentName:"ol"},"When swapping tokens involving native ETH, we use ",(0,o.kt)("inlineCode",{parentName:"li"},"Currency.wrap(address(0))")," to represent ETH in the ",(0,o.kt)("inlineCode",{parentName:"li"},"PoolKey")," struct.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"struct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically.\n    ///         For native ETH, Currency currency0 = Currency.wrap(address(0));\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n")),(0,o.kt)("h3",{id:"32-encoding-the-swap-command"},"3.2: Encoding the Swap Command"),(0,o.kt)("p",null,"When encoding a swap command for the Universal Router, we need to choose between two types of swaps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Exact Input Swaps:")),(0,o.kt)("p",null,"Use this swap-type when you know the exact amount of tokens you want to swap in, and you're willing to accept any amount of output tokens above your minimum. This is common when you want to sell a specific amount of tokens."),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Exact Output Swaps:")),(0,o.kt)("p",null,"Use this swap-type when you need a specific amount of output tokens, and you're willing to spend up to a maximum amount of input tokens. This is useful when you need to acquire a precise amount of tokens, for example, to repay a loan or meet a specific requirement."),(0,o.kt)("p",null,"Next, we encode the swap command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));\n")),(0,o.kt)("p",null,"Here, we're using ",(0,o.kt)("inlineCode",{parentName:"p"},"V4_SWAP"),", which tells the Universal Router that we want to perform a swap on a Uniswap v4 pool. The specific type of swap (exact input or exact output) will be determined by the V4Router actions we encode later. As we saw earlier, we encode this as a single byte, which is how the Universal Router expects to receive commands."),(0,o.kt)("p",null,"Check the complete list of ",(0,o.kt)("a",{parentName:"p",href:"https://docs.uniswap.org/contracts/universal-router/technical-reference#command"},"commands"),"."),(0,o.kt)("h3",{id:"33-action-encoding"},"3.3: Action Encoding"),(0,o.kt)("p",null,"Now, let\u2019s encode the actions for the swap:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Encode V4Router actions\nbytes memory actions = abi.encodePacked(\n    uint8(Actions.SWAP_EXACT_IN_SINGLE),\n    uint8(Actions.SETTLE_ALL),\n    uint8(Actions.TAKE_ALL)\n);\n")),(0,o.kt)("p",null,"These actions define the sequence of operations that will be performed in our v4 swap:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"SWAP_EXACT_IN_SINGLE"),": This action specifies that we want to perform an exact input swap using a single pool."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"SETTLE_ALL"),": This action ensures all input tokens involved in the swap are properly paid. This is part of v4's settlement pattern for handling token transfers."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"TAKE_ALL"),": This final action collects all output tokens after the swap is complete.")),(0,o.kt)("p",null,"The sequence of these actions is important as they define the complete flow of our swap operation from start to finish."),(0,o.kt)("h3",{id:"34-preparing-the-swap-inputs"},"3.4: Preparing the Swap Inputs"),(0,o.kt)("p",null,"For our v4 swap, we need to prepare three parameters that correspond to our encoded actions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes[] memory params = new bytes[](3);\n\n// First parameter: swap configuration\nparams[0] = abi.encode(\n    IV4Router.ExactInputSingleParams({\n        poolKey: key,\n        zeroForOne: true,            // true if we're swapping token0 for token1\n        amountIn: amountIn,          // amount of tokens we're swapping\n        amountOutMinimum: minAmountOut, // minimum amount we expect to receive\n        hookData: bytes(\"\")             // no hook data needed\n    })\n);\n\n// Second parameter: specify input tokens for the swap\n// encode SETTLE_ALL parameters\nparams[1] = abi.encode(key.currency0, amountIn);\n\n// Third parameter: specify output tokens from the swap\nparams[2] = abi.encode(key.currency1, minAmountOut);\n")),(0,o.kt)("p",null,"Each encoded parameter corresponds to a specific action in our swap:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The first parameter configures how the swap should be executed, defining the pool, amounts, and other swap-specific details"),(0,o.kt)("li",{parentName:"ol"},"The second parameter defines what tokens we're putting into the swap"),(0,o.kt)("li",{parentName:"ol"},"The third parameter defines what tokens we expect to receive from the swap")),(0,o.kt)("p",null,"The sequence of these parameters must match the sequence of actions we defined earlier (",(0,o.kt)("inlineCode",{parentName:"p"},"SWAP_EXACT_IN_SINGLE"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"SETTLE_ALL"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"TAKE_ALL"),")."),(0,o.kt)("h3",{id:"35-executing-the-swap"},"3.5: Executing the Swap"),(0,o.kt)("p",null,"Now we can execute the swap using the Universal Router:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes[] memory inputs = new bytes[](1);\n\n// Combine actions and params into inputs\ninputs[0] = abi.encode(actions, params);\n\n// Execute the swap\nuint256 deadline = block.timestamp + 20;\nrouter.execute(commands, inputs, deadline);\n")),(0,o.kt)("p",null,"This prepares and executes the swap based on our encoded commands, actions, and parameters."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note"),":  Never use block.timestamp or type(uint256).max as the deadline parameter.")),(0,o.kt)("h3",{id:"36-optional-verifying-the-swap-output"},"3.6: (Optional) Verifying the Swap Output"),(0,o.kt)("p",null,"After the swap, we need to verify that we received at least the minimum amount of tokens we specified:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'amountOut = IERC20(key.currency1).balanceOf(address(this));\nrequire(amountOut >= minAmountOut, "Insufficient output amount");\n')),(0,o.kt)("h3",{id:"37-returning-the-result"},"3.7: Returning the Result"),(0,o.kt)("p",null,"Finally, we return the amount of tokens we received:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"return amountOut;\n")),(0,o.kt)("p",null,"This allows the caller of the function to know exactly how many tokens were received in the swap."),(0,o.kt)("p",null,"Here's the complete swap function that combines all the steps we've covered:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'function swapExactInputSingle(\n    PoolKey calldata key,\n    uint128 amountIn,\n    uint128 minAmountOut\n) external returns (uint256 amountOut) {\n    // Encode the Universal Router command\n    bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));\n    bytes[] memory inputs = new bytes[](1);\n\n    // Encode V4Router actions\n    bytes memory actions = abi.encodePacked(\n        uint8(Actions.SWAP_EXACT_IN_SINGLE),\n        uint8(Actions.SETTLE_ALL),\n        uint8(Actions.TAKE_ALL)\n    );\n\n    // Prepare parameters for each action\n    bytes[] memory params = new bytes[](3);\n    params[0] = abi.encode(\n        IV4Router.ExactInputSingleParams({\n            poolKey: key,\n            zeroForOne: true,\n            amountIn: amountIn,\n            amountOutMinimum: minAmountOut,\n            hookData: bytes("")\n        })\n    );\n    params[1] = abi.encode(key.currency0, amountIn);\n    params[2] = abi.encode(key.currency1, minAmountOut);\n\n    // Combine actions and params into inputs\n    inputs[0] = abi.encode(actions, params);\n\n    // Execute the swap\n    uint256 deadline = block.timestamp + 20;\n    router.execute(commands, inputs, deadline);\n\n    // Verify and return the output amount\n    amountOut = IERC20(key.currency1).balanceOf(address(this));\n    require(amountOut >= minAmountOut, "Insufficient output amount");\n    return amountOut;\n}\n')))}c.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=l(n),d=o,h=m["".concat(p,".").concat(d)]||m[d]||c[d]||i;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var l=2;l<i;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);