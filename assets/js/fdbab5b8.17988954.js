"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[3349],{34057:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=n(83117),o=(n(67294),n(3905));const r={title:"Unlock Callback & Deltas"},i=void 0,l={unversionedId:"contracts/v4/guides/unlock-callback",id:"contracts/v4/guides/unlock-callback",title:"Unlock Callback & Deltas",description:"Refresher",source:"@site/docs/contracts/v4/guides/06-unlock-callback.mdx",sourceDirName:"contracts/v4/guides",slug:"/contracts/v4/guides/unlock-callback",permalink:"/docs/contracts/v4/guides/unlock-callback",editUrl:"https://github.com/hoffms/docs/tree/main/docs/contracts/v4/guides/06-unlock-callback.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Unlock Callback & Deltas"},sidebar:"contractsSidebar",previous:{title:"Hook Deployment",permalink:"/docs/contracts/v4/guides/hooks/hook-deployment"},next:{title:"Reading Pool State",permalink:"/docs/contracts/v4/guides/read-pool-state"}},c={},s=[{value:"Refresher",id:"refresher",level:3},{value:"Implementing the unlock callback",id:"implementing-the-unlock-callback",level:3},{value:"Calling the unlock function",id:"calling-the-unlock-function",level:3},{value:"Deltas",id:"deltas",level:3},{value:"Liquidity-accessing",id:"liquidity-accessing",level:3},{value:"Delta-resolving",id:"delta-resolving",level:3}],u={toc:s};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",{id:"refresher"},"Refresher"),(0,o.kt)("p",null,"In order to have access to the liquidity inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"PoolManager"),",\nit needs to be ",(0,o.kt)("em",{parentName:"p"},"unlocked")," to begin with. After being unlocked, any\nnumber of operations can be executed, which at the end of must be ",(0,o.kt)("em",{parentName:"p"},"locked"),"\nagain. At this point, if there are any ",(0,o.kt)("em",{parentName:"p"},"non-zero deltas"),", meaning the\nPoolManager is owed or owes tokens back to some address, the whole\nexecution reverts. Otherwise, both parties have paid or received\nthe right amount of tokens and the operations have successfully\ncarried out."),(0,o.kt)("h1",{id:"unlocking-the-poolmanager"},"Unlocking the PoolManager"),(0,o.kt)("h3",{id:"implementing-the-unlock-callback"},"Implementing the unlock callback"),(0,o.kt)("p",null,"Prior to unlocking the PoolManager, the integrating contract must\nimplement the ",(0,o.kt)("inlineCode",{parentName:"p"},"unlockCallback")," function. This function will be\ncalled by the PoolManager after being unlocked. An easy way to\ndo this is to inherit the ",(0,o.kt)("inlineCode",{parentName:"p"},"SafeCallback")," abstract contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'import {SafeCallback} from "v4-periphery/src/base/SafeCallback.sol";\n\ncontract IntegratingContract is SafeCallback {\n    constructor(IPoolManager _poolManager) SafeCallback(_poolManager) {}\n}\n')),(0,o.kt)("h3",{id:"calling-the-unlock-function"},"Calling the unlock function"),(0,o.kt)("p",null,"After implementing the callback, the integrating contract can now\ninvoke the ",(0,o.kt)("inlineCode",{parentName:"p"},"unlock()")," function. It receives a ",(0,o.kt)("em",{parentName:"p"},"bytes")," parameter\nthat is further passed to your callback function as an argument.\nThis parameter is used to encode the sequence of operations to be\nexecuted in the context of the ",(0,o.kt)("inlineCode",{parentName:"p"},"PoolManager"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes memory unlockData = abi.encode(encode_operations_here);\nbytes memory unlockResultData = poolManager.unlock(unlockData);\n")),(0,o.kt)("p",null,"Next, we must override the ",(0,o.kt)("inlineCode",{parentName:"p"},"_unlockCallback")," function inherited from\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"SafeCallback")," contract. In your implementation, you should\ndecode your operations and continue with the desired logic."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function _unlockCallback(bytes calldata data) internal override returns (bytes memory) {\n    (...) = abi.decode(data, (...));\n}\n")),(0,o.kt)("h1",{id:"operations"},"Operations"),(0,o.kt)("p",null,"There are ",(0,o.kt)("strong",{parentName:"p"},"9")," operations that can be done in the ",(0,o.kt)("inlineCode",{parentName:"p"},"PoolManager"),"\nwhich fall in two categories: ",(0,o.kt)("em",{parentName:"p"},"liquidity-accessing")," and ",(0,o.kt)("em",{parentName:"p"},"delta-resolving"),"."),(0,o.kt)("h3",{id:"deltas"},"Deltas"),(0,o.kt)("p",null,"Deltas are the ",(0,o.kt)("inlineCode",{parentName:"p"},"PoolManager"),"'s method to keep track of token amounts it\nneeds to receive, respectively to distribute. A negative delta signals that\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"PoolManager")," is owed tokens, while a positive one expresses a\ntoken balance that needs to be paid to its user."),(0,o.kt)("h3",{id:"liquidity-accessing"},"Liquidity-accessing"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Liquidity-accessing")," operations will create non-zero ",(0,o.kt)("em",{parentName:"p"},"deltas")," and\nproduce a state transition of the selected pool.\nThey are the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"modify liquidity")," - used to increase or decrease liquidity; increasing\nliquidity will result in a negative token delta, while decreasing yields a positive one"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"swap")," - used to trade one token for another; will result in a negative tokenA delta\nand a positive tokenB delta"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"donate")," - used to provide direct token revenue to positions in range;\nwill result in a negative delta for the pool's tokens the user wishes\nto provide")),(0,o.kt)("h3",{id:"delta-resolving"},"Delta-resolving"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Delta-resolving")," operations are used to even out the deltas created\nby the ",(0,o.kt)("em",{parentName:"p"},"liquidity-accessing")," operations.\nThey are the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"settle")," - used following token transfers to the manager\nor burning of ERC6909 claims to resolve negative deltas"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"take")," - transfer tokens from the manager, used to resolve\npositive deltas but also provide token loans, producing negative deltas"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"mint")," - used to create ERC6909 claims, creating a negative delta\nthat needs to be resolved by transferring the corresponding token and\n",(0,o.kt)("em",{parentName:"li"},"settling")," afterwards"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"burn")," - removes ERC6909 claims, creating a positive delta for tokens to\nbe transferred back to the owner or used in settling negative balances"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"clear")," - used to zero out positive token deltas, helpful to forfeit\ninsignificant token amounts in order to avoid paying further transfer costs")))}p.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(n),k=o,m=d["".concat(c,".").concat(k)]||d[k]||p[k]||r;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function k(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);