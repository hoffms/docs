"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[4443],{24798:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(83117),r=(n(67294),n(3905));const l={},i="SqrtPriceMath",o={unversionedId:"contracts/v4/reference/core/libraries/SqrtPriceMath",id:"contracts/v4/reference/core/libraries/SqrtPriceMath",title:"SqrtPriceMath",description:"Git Source - Generated with forge doc",source:"@site/docs/contracts/v4/reference/core/libraries/SqrtPriceMath.md",sourceDirName:"contracts/v4/reference/core/libraries",slug:"/contracts/v4/reference/core/libraries/SqrtPriceMath",permalink:"/docs/contracts/v4/reference/core/libraries/SqrtPriceMath",editUrl:"https://github.com/hoffms/docs/tree/main/docs/contracts/v4/reference/core/libraries/SqrtPriceMath.md",tags:[],version:"current",frontMatter:{},sidebar:"contractsSidebar",previous:{title:"SafeCast",permalink:"/docs/contracts/v4/reference/core/libraries/SafeCast"},next:{title:"StateLibrary",permalink:"/docs/contracts/v4/reference/core/libraries/StateLibrary"}},u={},p=[{value:"Functions",id:"functions",level:2},{value:"getNextSqrtPriceFromAmount0RoundingUp",id:"getnextsqrtpricefromamount0roundingup",level:3},{value:"getNextSqrtPriceFromAmount1RoundingDown",id:"getnextsqrtpricefromamount1roundingdown",level:3},{value:"getNextSqrtPriceFromInput",id:"getnextsqrtpricefrominput",level:3},{value:"getNextSqrtPriceFromOutput",id:"getnextsqrtpricefromoutput",level:3},{value:"getAmount0Delta",id:"getamount0delta",level:3},{value:"absDiff",id:"absdiff",level:3},{value:"getAmount1Delta",id:"getamount1delta",level:3},{value:"getAmount0Delta",id:"getamount0delta-1",level:3},{value:"getAmount1Delta",id:"getamount1delta-1",level:3},{value:"Errors",id:"errors",level:2},{value:"InvalidPriceOrLiquidity",id:"invalidpriceorliquidity",level:3},{value:"InvalidPrice",id:"invalidprice",level:3},{value:"NotEnoughLiquidity",id:"notenoughliquidity",level:3},{value:"PriceOverflow",id:"priceoverflow",level:3}],d={toc:p};function m(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"sqrtpricemath"},"SqrtPriceMath"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/SqrtPriceMath.sol"},"Git Source")," - Generated with ",(0,r.kt)("a",{parentName:"p",href:"https://book.getfoundry.sh/reference/forge/forge-doc"},"forge doc")),(0,r.kt)("p",null,"Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas"),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("h3",{id:"getnextsqrtpricefromamount0roundingup"},"getNextSqrtPriceFromAmount0RoundingUp"),(0,r.kt)("p",null,"Gets the next sqrt price given a delta of currency0"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Always rounds up, because in the exact output case (increasing price) we need to move the price at least\nfar enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\nprice less in order to not send too much output.\nThe most precise formula for this is liquidity ")," sqrtPX96 / (liquidity +- amount ",(0,r.kt)("em",{parentName:"p"}," sqrtPX96),\nif this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n    internal\n    pure\n    returns (uint160);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"The starting price, i.e. before accounting for the currency0 delta")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint128")),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of usable liquidity")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"amount")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"How much of currency0 to add or remove from virtual reserves")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"add")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to add or remove the amount of currency0")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<none>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"The price after adding or removing amount, depending on add")))),(0,r.kt)("h3",{id:"getnextsqrtpricefromamount1roundingdown"},"getNextSqrtPriceFromAmount1RoundingDown"),(0,r.kt)("p",null,"Gets the next sqrt price given a delta of currency1"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\nfar enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\nprice less in order to not send too much output.\nThe formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n    internal\n    pure\n    returns (uint160);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"The starting price, i.e., before accounting for the currency1 delta")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint128")),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of usable liquidity")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"amount")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"How much of currency1 to add, or remove, from virtual reserves")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"add")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to add, or remove, the amount of currency1")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<none>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"The price after adding or removing ",(0,r.kt)("inlineCode",{parentName:"td"},"amount"))))),(0,r.kt)("h3",{id:"getnextsqrtpricefrominput"},"getNextSqrtPriceFromInput"),(0,r.kt)("p",null,"Gets the next sqrt price given an input amount of currency0 or currency1"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Throws if price or liquidity are 0, or if the next price is out of bounds")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)\n    internal\n    pure\n    returns (uint160);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"The starting price, i.e., before accounting for the input amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint128")),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of usable liquidity")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"amountIn")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"How much of currency0, or currency1, is being swapped in")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"zeroForOne")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether the amount in is currency0 or currency1")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<none>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"uint160 The price after adding the input amount to currency0 or currency1")))),(0,r.kt)("h3",{id:"getnextsqrtpricefromoutput"},"getNextSqrtPriceFromOutput"),(0,r.kt)("p",null,"Gets the next sqrt price given an output amount of currency0 or currency1"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Throws if price or liquidity are 0 or the next price is out of bounds")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)\n    internal\n    pure\n    returns (uint160);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"The starting price before accounting for the output amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint128")),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of usable liquidity")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"amountOut")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"How much of currency0, or currency1, is being swapped out")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"zeroForOne")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether the amount out is currency1 or currency0")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<none>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"uint160 The price after removing the output amount of currency0 or currency1")))),(0,r.kt)("h3",{id:"getamount0delta"},"getAmount0Delta"),(0,r.kt)("p",null,"Gets the amount0 delta between two prices"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\ni.e. liquidity ")," (sqrt(upper) - sqrt(lower)) / (sqrt(upper) ",(0,r.kt)("em",{parentName:"p"}," sqrt(lower))")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity, bool roundUp)\n    internal\n    pure\n    returns (uint256);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPriceAX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"A sqrt price")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPriceBX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"Another sqrt price")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint128")),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of usable liquidity")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"roundUp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to round the amount up or down")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<none>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"uint256 Amount of currency0 required to cover a position of size liquidity between the two passed prices")))),(0,r.kt)("h3",{id:"absdiff"},"absDiff"),(0,r.kt)("p",null,"Equivalent to: ",(0,r.kt)("inlineCode",{parentName:"p"},"a >= b ? a - b : b - a")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function absDiff(uint160 a, uint160 b) internal pure returns (uint256 res);\n")),(0,r.kt)("h3",{id:"getamount1delta"},"getAmount1Delta"),(0,r.kt)("p",null,"Gets the amount1 delta between two prices"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Calculates liquidity ")," (sqrt(upper) - sqrt(lower))*"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity, bool roundUp)\n    internal\n    pure\n    returns (uint256 amount1);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPriceAX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"A sqrt price")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPriceBX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"Another sqrt price")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint128")),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of usable liquidity")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"roundUp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to round the amount up, or down")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"amount1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Amount of currency1 required to cover a position of size liquidity between the two passed prices")))),(0,r.kt)("h3",{id:"getamount0delta-1"},"getAmount0Delta"),(0,r.kt)("p",null,"Equivalent to:\namount1 = roundUp\n? FullMath.mulDivRoundingUp(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96)\n: FullMath.mulDiv(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96);\nCannot overflow because ",(0,r.kt)("inlineCode",{parentName:"p"},"type(uint128).max * type(uint160).max >> 96 < (1 << 192)"),"."),(0,r.kt)("p",null,"Helper that gets signed currency0 delta"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)\n    internal\n    pure\n    returns (int256);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPriceAX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"A sqrt price")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPriceBX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"Another sqrt price")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int128")),(0,r.kt)("td",{parentName:"tr",align:null},"The change in liquidity for which to compute the amount0 delta")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<none>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int256")),(0,r.kt)("td",{parentName:"tr",align:null},"int256 Amount of currency0 corresponding to the passed liquidityDelta between the two prices")))),(0,r.kt)("h3",{id:"getamount1delta-1"},"getAmount1Delta"),(0,r.kt)("p",null,"Helper that gets signed currency1 delta"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)\n    internal\n    pure\n    returns (int256);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPriceAX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"A sqrt price")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sqrtPriceBX96")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint160")),(0,r.kt)("td",{parentName:"tr",align:null},"Another sqrt price")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int128")),(0,r.kt)("td",{parentName:"tr",align:null},"The change in liquidity for which to compute the amount1 delta")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<none>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int256")),(0,r.kt)("td",{parentName:"tr",align:null},"int256 Amount of currency1 corresponding to the passed liquidityDelta between the two prices")))),(0,r.kt)("h2",{id:"errors"},"Errors"),(0,r.kt)("h3",{id:"invalidpriceorliquidity"},"InvalidPriceOrLiquidity"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"error InvalidPriceOrLiquidity();\n")),(0,r.kt)("h3",{id:"invalidprice"},"InvalidPrice"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"error InvalidPrice();\n")),(0,r.kt)("h3",{id:"notenoughliquidity"},"NotEnoughLiquidity"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"error NotEnoughLiquidity();\n")),(0,r.kt)("h3",{id:"priceoverflow"},"PriceOverflow"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"error PriceOverflow();\n")))}m.isMDXComponent=!0},3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>N});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var u=a.createContext({}),p=function(t){var e=a.useContext(u),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},d=function(t){var e=p(t.components);return a.createElement(u.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},k=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,l=t.originalType,u=t.parentName,d=o(t,["components","mdxType","originalType","parentName"]),k=p(n),N=r,c=k["".concat(u,".").concat(N)]||k[N]||m[N]||l;return n?a.createElement(c,i(i({ref:e},d),{},{components:n})):a.createElement(c,i({ref:e},d))}));function N(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=n.length,i=new Array(l);i[0]=k;var o={};for(var u in e)hasOwnProperty.call(e,u)&&(o[u]=e[u]);o.originalType=t,o.mdxType="string"==typeof t?t:r,i[1]=o;for(var p=2;p<l;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"}}]);