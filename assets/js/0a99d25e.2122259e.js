"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[57123],{37868:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var n=a(83117),l=(a(67294),a(3905));const r={title:"BalanceDelta Guide"},i=void 0,o={unversionedId:"contracts/v4/reference/core/types/balancedelta-guide",id:"contracts/v4/reference/core/types/balancedelta-guide",title:"BalanceDelta Guide",description:"BalanceDelta is a type used in Uniswap V4 to represent the balance changes of two tokens (token0 and token1). It tightly packs the two values in a single 256 bits. It is designed to efficiently store and manipulate these balance deltas, with the upper 128 bits representing the change in token0 (amount0) and the lower 128 bits representing the change in token1 (amount1).",source:"@site/docs/contracts/v4/reference/core/types/balancedelta-guide.mdx",sourceDirName:"contracts/v4/reference/core/types",slug:"/contracts/v4/reference/core/types/balancedelta-guide",permalink:"/docs/contracts/v4/reference/core/types/balancedelta-guide",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/v4/reference/core/types/balancedelta-guide.mdx",tags:[],version:"current",frontMatter:{title:"BalanceDelta Guide"},sidebar:"contractsSidebar",previous:{title:"Slot0",permalink:"/docs/contracts/v4/reference/core/types/Slot0"},next:{title:"BeforeSwapDelta Guide",permalink:"/docs/contracts/v4/reference/core/types/beforeswapdelta-guide"}},p={},u=[{value:"toBalanceDelta",id:"tobalancedelta",level:2},{value:"add",id:"add",level:2},{value:"sub",id:"sub",level:2},{value:"eq",id:"eq",level:2},{value:"neq",id:"neq",level:2},{value:"amount0",id:"amount0",level:2},{value:"amount1",id:"amount1",level:2}],c={toc:u};function d(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," is a type used in Uniswap V4 to represent the balance changes of two tokens (token0 and token1). It tightly packs the two values in a single 256 bits. It is designed to efficiently store and manipulate these balance deltas, with the upper 128 bits representing the change in token0 (",(0,l.kt)("inlineCode",{parentName:"p"},"amount0"),") and the lower 128 bits representing the change in token1 (",(0,l.kt)("inlineCode",{parentName:"p"},"amount1"),")."),(0,l.kt)("h1",{id:"purpose"},"Purpose"),(0,l.kt)("p",null,"The main purpose of ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," is to keep track of the net balance changes in the two tokens of a pool after various operations such as swaps, liquidity modifications, and interactions with hooks. It provides a compact and efficient way to store and update these balance deltas throughout the execution flow of the pool."),(0,l.kt)("p",null,"In the context of hooks, ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," is used to ensure that the net balance change for each token is zero after the hook's functionality is executed. This is important for maintaining the integrity of the pool's balances and ensuring that the hooks do not introduce any unexpected or unauthorized balance changes."),(0,l.kt)("h1",{id:"type-definition"},"Type Definition"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"type BalanceDelta is int256;\n")),(0,l.kt)("h1",{id:"using-directives"},"Using Directives"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"using {add as +, sub as -, eq as ==, neq as !=} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\nusing SafeCast for int256;\n")),(0,l.kt)("p",null,"These using directives enable arithmetic operations, equality comparisons, and library functions to be used directly on ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," values."),(0,l.kt)("h1",{id:"functions"},"Functions"),(0,l.kt)("h2",{id:"tobalancedelta"},"toBalanceDelta"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function toBalanceDelta(int128 amount0, int128 amount1) pure returns (BalanceDelta balanceDelta);\n")),(0,l.kt)("p",null,"Creates a ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," value from two ",(0,l.kt)("inlineCode",{parentName:"p"},"int128")," values representing ",(0,l.kt)("inlineCode",{parentName:"p"},"amount0")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"amount1"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"amount0"),(0,l.kt)("td",{parentName:"tr",align:null},"int128"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount for the first token")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"amount1"),(0,l.kt)("td",{parentName:"tr",align:null},"int128"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount for the second token")))),(0,l.kt)("p",null,"Returns the created ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," value."),(0,l.kt)("h2",{id:"add"},"add"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta);\n")),(0,l.kt)("p",null,"Adds two ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," values."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a"),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"The first ",(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")," value")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"b"),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"The second ",(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")," value")))),(0,l.kt)("p",null,"Returns the sum of the two ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," values."),(0,l.kt)("h2",{id:"sub"},"sub"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta);\n")),(0,l.kt)("p",null,"Subtracts one ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," value from another."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a"),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"The first ",(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")," value")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"b"),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"The second ",(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")," value")))),(0,l.kt)("p",null,"Returns the difference of the two ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," values."),(0,l.kt)("h2",{id:"eq"},"eq"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function eq(BalanceDelta a, BalanceDelta b) pure returns (bool);\n")),(0,l.kt)("p",null,"Checks if two ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," values are equal."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a"),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"The first ",(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")," value")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"b"),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"The second ",(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")," value")))),(0,l.kt)("p",null,"Returns ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," if the values are equal, ",(0,l.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,l.kt)("h2",{id:"neq"},"neq"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function neq(BalanceDelta a, BalanceDelta b) pure returns (bool);\n")),(0,l.kt)("p",null,"Checks if two ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," values are not equal."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a"),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"The first ",(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")," value")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"b"),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"The second ",(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")," value")))),(0,l.kt)("p",null,"Returns ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," if the values are not equal, ",(0,l.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,l.kt)("h1",{id:"library-functions"},"Library Functions"),(0,l.kt)("h2",{id:"amount0"},"amount0"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0);\n")),(0,l.kt)("p",null,"Extracts the ",(0,l.kt)("inlineCode",{parentName:"p"},"amount0")," value from a ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"balanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"The ",(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")," value")))),(0,l.kt)("p",null,"Returns the extracted ",(0,l.kt)("inlineCode",{parentName:"p"},"amount0")," value as an ",(0,l.kt)("inlineCode",{parentName:"p"},"int128"),"."),(0,l.kt)("h2",{id:"amount1"},"amount1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1);\n")),(0,l.kt)("p",null,"Extracts the ",(0,l.kt)("inlineCode",{parentName:"p"},"amount1")," value from a ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"balanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta"),(0,l.kt)("td",{parentName:"tr",align:null},"The ",(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")," value")))),(0,l.kt)("p",null,"Returns the extracted ",(0,l.kt)("inlineCode",{parentName:"p"},"amount1")," value as an ",(0,l.kt)("inlineCode",{parentName:"p"},"int128"),"."),(0,l.kt)("h1",{id:"usage-in-hooks"},"Usage in Hooks"),(0,l.kt)("p",null,"When a hook is called during a swap or liquidity modification, it can perform custom logic and interact with the pool's balances. However, to maintain the correctness of the pool's state, the hook must ensure that any balance changes it introduces are properly accounted for and net to zero at the end of its execution.\nThe BalanceDelta is forwarded to the ",(0,l.kt)("inlineCode",{parentName:"p"},"afterSwap")," & ",(0,l.kt)("inlineCode",{parentName:"p"},"afterAddliquidity"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"afterRemoveLiquidity")," hooks.  "),(0,l.kt)("h1",{id:"usage-in-the-pool-library"},"Usage in the Pool Library"),(0,l.kt)("p",null,"In the ",(0,l.kt)("inlineCode",{parentName:"p"},"Pool")," library, ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," is used extensively to track balance changes during various operations such as swaps, liquidity modifications, and donations. The library functions ",(0,l.kt)("inlineCode",{parentName:"p"},"swap"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"modifyLiquidity"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"donate")," all return ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," values representing the net balance changes resulting from these operations."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"Pool")," library uses ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," to efficiently update and manage the pool's balances, ensuring that the net balance changes are accurately accounted for and that the pool remains in a consistent state."),(0,l.kt)("p",null,"By leveraging the compact representation and efficient arithmetic operations provided by ",(0,l.kt)("inlineCode",{parentName:"p"},"BalanceDelta"),", the ",(0,l.kt)("inlineCode",{parentName:"p"},"Pool")," library can perform complex balance calculations and updates in a gas-optimized manner, reducing the overall cost of executing pool-related operations."))}d.isMDXComponent=!0},3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var p=n.createContext({}),u=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},s=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),s=u(a),m=l,k=s["".concat(p,".").concat(m)]||s[m]||d[m]||r;return a?n.createElement(k,i(i({ref:t},c),{},{components:a})):n.createElement(k,i({ref:t},c))}));function m(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,i=new Array(r);i[0]=s;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var u=2;u<r;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}s.displayName="MDXCreateElement"}}]);