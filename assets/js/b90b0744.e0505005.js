"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[675],{1373:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=t(3117),r=(t(7294),t(3905));const i={},o="Dynamic Actions",s={unversionedId:"api/Actions/dynamic-actions",id:"api/Actions/dynamic-actions",title:"Dynamic Actions",description:"The Most Powerful Action Type",source:"@site/docs/api/Actions/dynamic-actions.mdx",sourceDirName:"api/Actions",slug:"/api/Actions/dynamic-actions",permalink:"/docs/api/Actions/dynamic-actions",editUrl:"https://github.com/hoffms/docs/tree/main/docs/api/Actions/dynamic-actions.mdx",tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Blockchain Actions",permalink:"/docs/api/Actions/blockchain-actions"},next:{title:"Transfer Actions",permalink:"/docs/api/Actions/transfer-actions"}},l={},c=[{value:"The Most Powerful Action Type",id:"the-most-powerful-action-type",level:2},{value:"Why Dynamic Actions?",id:"why-dynamic-actions",level:2},{value:"Interface",id:"interface",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"API Endpoint Requirements",id:"api-endpoint-requirements",level:2},{value:"Complete Example: Optimal DeFi Yield Strategy",id:"complete-example-optimal-defi-yield-strategy",level:2},{value:"Frontend Configuration",id:"frontend-configuration",level:3},{value:"Backend Implementation (Next.js API Route)",id:"backend-implementation-nextjs-api-route",level:3},{value:"Advanced Use Cases",id:"advanced-use-cases",level:2},{value:"1. <strong>Multi-Protocol Arbitrage</strong>",id:"1-multi-protocol-arbitrage",level:3},{value:"2. <strong>Dynamic NFT Pricing</strong>",id:"2-dynamic-nft-pricing",level:3},{value:"3. <strong>Cross-Chain Optimization</strong>",id:"3-cross-chain-optimization",level:3},{value:"Parameter Processing",id:"parameter-processing",level:2},{value:"Accessing Parameters",id:"accessing-parameters",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. <strong>Validate Inputs</strong>",id:"1-validate-inputs",level:3},{value:"2. <strong>Handle Rate Limits</strong>",id:"2-handle-rate-limits",level:3},{value:"3. <strong>Cache When Possible</strong>",id:"3-cache-when-possible",level:3},{value:"4. <strong>Provide Rich Feedback</strong>",id:"4-provide-rich-feedback",level:3},{value:"5. <strong>Security Considerations</strong>",id:"5-security-considerations",level:3},{value:"When to Use Dynamic Actions",id:"when-to-use-dynamic-actions",level:2},{value:"\u2705 <strong>Perfect for:</strong>",id:"-perfect-for",level:3},{value:"\u274c <strong>Overkill for:</strong>",id:"-overkill-for",level:3},{value:"Deployment Considerations",id:"deployment-considerations",level:2},{value:"Production Checklist:",id:"production-checklist",level:3},{value:"Next Steps",id:"next-steps",level:2}],p={toc:c};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"dynamic-actions"},"Dynamic Actions"),(0,r.kt)("h2",{id:"the-most-powerful-action-type"},"The Most Powerful Action Type"),(0,r.kt)("p",null,"Dynamic Actions are the ",(0,r.kt)("strong",{parentName:"p"},"most sophisticated")," action type in the Sherry SDK. They enable complex Web3 operations by leveraging server-side computation to determine the optimal transaction based on user inputs, market conditions, and complex business logic."),(0,r.kt)("h2",{id:"why-dynamic-actions"},"Why Dynamic Actions?"),(0,r.kt)("p",null,"Unlike Blockchain Actions where you call a specific contract function directly, Dynamic Actions let your server:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\ud83e\udde0 ",(0,r.kt)("strong",{parentName:"li"},"Analyze market conditions")," in real-time"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udd04 ",(0,r.kt)("strong",{parentName:"li"},"Calculate optimal routes")," across multiple protocols"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udcca ",(0,r.kt)("strong",{parentName:"li"},"Process complex strategies")," that require multiple steps"),(0,r.kt)("li",{parentName:"ul"},"\ud83c\udfaf ",(0,r.kt)("strong",{parentName:"li"},"Personalize transactions")," based on user profile"),(0,r.kt)("li",{parentName:"ul"},"\u26a1 ",(0,r.kt)("strong",{parentName:"li"},"Adapt to changing conditions")," before execution")),(0,r.kt)("h2",{id:"interface"},"Interface"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface DynamicAction {\n  type: 'dynamic';\n  label: string; // Button text shown to users\n  description?: string; // Optional help text\n  chains: ChainContext; // Source blockchain\n  path: string; // Your API endpoint\n  params?: Parameter[]; // User input parameters\n}\n")),(0,r.kt)("h2",{id:"how-it-works"},"How It Works"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-mermaid"},"graph TD\n    A[User fills parameters] --\x3e B[SDK calls your API endpoint]\n    B --\x3e C[Your server processes inputs]\n    C --\x3e D[Server analyzes market/conditions]\n    D --\x3e E[Server calculates optimal strategy]\n    E --\x3e F[Server returns serialized transaction]\n    F --\x3e G[User signs & executes transaction]\n")),(0,r.kt)("h2",{id:"api-endpoint-requirements"},"API Endpoint Requirements"),(0,r.kt)("p",null,"Your endpoint must return an ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutionResponse"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ExecutionResponse {\n  serializedTransaction: string; // Ready-to-execute transaction\n  chainId: string; // Chain name (e.g., 'avalanche')\n  abi?: any[]; // Optional: for verification\n  params?: {\n    // Optional: for better UX\n    functionName: string;\n    args: Record<string, any>;\n  };\n}\n")),(0,r.kt)("h2",{id:"complete-example-optimal-defi-yield-strategy"},"Complete Example: Optimal DeFi Yield Strategy"),(0,r.kt)("h3",{id:"frontend-configuration"},"Frontend Configuration"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { DynamicAction } from '@sherrylinks/sdk';\n\nconst optimalYieldAction: DynamicAction = {\n  type: 'dynamic',\n  label: 'Find Best Yield',\n  description: 'AI-powered yield optimization across 15+ protocols',\n  path: '/api/optimize-yield',\n  chains: { source: 'avalanche' },\n  params: [\n    {\n      name: 'amount',\n      label: 'Investment Amount (USDC)',\n      type: 'number',\n      required: true,\n      min: 100,\n      max: 1000000,\n      description: 'Minimum $100 for optimal routing',\n    },\n    {\n      name: 'riskTolerance',\n      label: 'Risk Tolerance',\n      type: 'select',\n      required: true,\n      options: [\n        {\n          label: 'Conservative (3-5% APY)',\n          value: 'low',\n          description: 'Stable protocols only',\n        },\n        {\n          label: 'Moderate (5-12% APY)',\n          value: 'medium',\n          description: 'Balanced risk/reward',\n        },\n        {\n          label: 'Aggressive (12%+ APY)',\n          value: 'high',\n          description: 'Higher risk, higher reward',\n        },\n      ],\n    },\n    {\n      name: 'duration',\n      label: 'Investment Duration',\n      type: 'radio',\n      required: true,\n      options: [\n        { label: '1 week', value: 7 },\n        { label: '1 month', value: 30 },\n        { label: '3 months', value: 90 },\n        { label: '1 year', value: 365 },\n      ],\n    },\n    {\n      name: 'autoCompound',\n      label: 'Auto-compound rewards',\n      type: 'boolean',\n      value: true,\n      description: 'Automatically reinvest rewards for compound growth',\n    },\n  ],\n};\n")),(0,r.kt)("h3",{id:"backend-implementation-nextjs-api-route"},"Backend Implementation (Next.js API Route)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// pages/api/optimize-yield.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { serialize } from 'wagmi';\nimport { avalancheFuji } from 'viem/chains';\n\nexport async function POST(req: NextRequest) {\n  try {\n    // Get parameters from URL query\n    const { searchParams } = new URL(req.url);\n    const amount = parseFloat(searchParams.get('amount') || '0');\n    const riskTolerance = searchParams.get('riskTolerance');\n    const duration = parseInt(searchParams.get('duration') || '30');\n    const autoCompound = searchParams.get('autoCompound') === 'true';\n\n    // Validate inputs\n    if (amount < 100) {\n      return NextResponse.json({ error: 'Minimum investment is $100' }, { status: 400 });\n    }\n\n    // \ud83e\udde0 COMPLEX SERVER-SIDE LOGIC STARTS HERE\n\n    // 1. Fetch current yields from multiple protocols\n    const protocolYields = await fetchProtocolYields([\n      'AAVE',\n      'Compound',\n      'Yearn',\n      'Convex',\n      'Curve',\n      'TraderJoe',\n    ]);\n\n    // 2. Filter by risk tolerance\n    const filteredProtocols = filterByRisk(protocolYields, riskTolerance);\n\n    // 3. Calculate optimal allocation\n    const optimalAllocation = calculateOptimalAllocation(\n      filteredProtocols,\n      amount,\n      duration,\n      autoCompound,\n    );\n\n    // 4. Determine best execution strategy\n    const strategy = await planExecutionStrategy(optimalAllocation);\n\n    // 5. Build the optimal transaction\n    const transaction = await buildOptimalTransaction(strategy, {\n      amount,\n      userAddress: req.headers.get('x-wallet-address'),\n      slippageTolerance: 0.5, // 0.5%\n    });\n\n    // 6. Serialize the transaction\n    const serializedTx = serialize({\n      to: transaction.to,\n      data: transaction.data,\n      value: BigInt(transaction.value || 0),\n      chainId: avalancheFuji.id,\n    });\n\n    // 7. Return the response\n    const response: ExecutionResponse = {\n      serializedTransaction: serializedTx,\n      chainId: 'fuji',\n      abi: strategy.contractAbi,\n      params: {\n        functionName: strategy.functionName,\n        args: {\n          amount: amount.toString(),\n          strategy: strategy.name,\n          expectedAPY: `${strategy.projectedAPY}%`,\n          protocols: strategy.protocols.map(p => p.name),\n        },\n      },\n    };\n\n    return NextResponse.json(response, {\n      headers: {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Methods': 'POST',\n      },\n    });\n  } catch (error) {\n    console.error('Yield optimization error:', error);\n    return NextResponse.json({ error: 'Failed to optimize yield strategy' }, { status: 500 });\n  }\n}\n\n// Helper functions for complex logic\nasync function fetchProtocolYields(protocols: string[]) {\n  // Fetch real-time APY data from multiple DeFi protocols\n  const yields = await Promise.all(\n    protocols.map(async protocol => {\n      const response = await fetch(`https://api.${protocol.toLowerCase()}.com/yields`);\n      return response.json();\n    }),\n  );\n  return yields;\n}\n\nfunction filterByRisk(yields: any[], riskTolerance: string) {\n  switch (riskTolerance) {\n    case 'low':\n      return yields.filter(y => y.riskScore <= 3 && y.apy >= 3);\n    case 'medium':\n      return yields.filter(y => y.riskScore <= 6 && y.apy >= 5);\n    case 'high':\n      return yields.filter(y => y.apy >= 12);\n    default:\n      return yields;\n  }\n}\n\nfunction calculateOptimalAllocation(\n  protocols: any[],\n  amount: number,\n  duration: number,\n  autoCompound: boolean,\n) {\n  // Complex portfolio optimization algorithm\n  // Consider correlation, expected returns, volatility, etc.\n\n  const allocation = portfolioOptimizer.optimize({\n    protocols,\n    totalAmount: amount,\n    timeHorizon: duration,\n    autoCompound,\n    objective: 'maximize_sharpe_ratio',\n  });\n\n  return allocation;\n}\n\nasync function planExecutionStrategy(allocation: any) {\n  // Determine the most gas-efficient way to execute the allocation\n  // Could involve batch transactions, optimal ordering, etc.\n\n  return {\n    contractAddress: '0xOptimalYieldManager...',\n    functionName: 'executeOptimalStrategy',\n    contractAbi: optimizerAbi,\n    data: encodeStrategyData(allocation),\n    protocols: allocation.protocols,\n    projectedAPY: allocation.expectedReturn,\n    name: allocation.strategyName,\n  };\n}\n\nasync function buildOptimalTransaction(strategy: any, config: any) {\n  // Build the final transaction data\n  return {\n    to: strategy.contractAddress,\n    data: strategy.data,\n    value: config.amount,\n  };\n}\n")),(0,r.kt)("h2",{id:"advanced-use-cases"},"Advanced Use Cases"),(0,r.kt)("h3",{id:"1-multi-protocol-arbitrage"},"1. ",(0,r.kt)("strong",{parentName:"h3"},"Multi-Protocol Arbitrage")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const arbitrageAction: DynamicAction = {\n  type: 'dynamic',\n  label: 'Execute Arbitrage',\n  path: '/api/find-arbitrage',\n  chains: { source: 'avalanche' },\n  params: [\n    {\n      name: 'token',\n      label: 'Token to Arbitrage',\n      type: 'select',\n      options: [\n        { label: 'USDC', value: 'usdc' },\n        { label: 'USDT', value: 'usdt' },\n        { label: 'DAI', value: 'dai' },\n      ],\n    },\n    {\n      name: 'maxSlippage',\n      label: 'Max Slippage (%)',\n      type: 'number',\n      value: 0.5,\n      min: 0.1,\n      max: 5,\n    },\n  ],\n};\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Server Logic:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Scans 10+ DEXs for price differences"),(0,r.kt)("li",{parentName:"ul"},"Calculates optimal route considering gas costs"),(0,r.kt)("li",{parentName:"ul"},"Executes flash loan arbitrage if profitable"),(0,r.kt)("li",{parentName:"ul"},"Returns single transaction that captures profit")),(0,r.kt)("h3",{id:"2-dynamic-nft-pricing"},"2. ",(0,r.kt)("strong",{parentName:"h3"},"Dynamic NFT Pricing")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const dynamicMintAction: DynamicAction = {\n  type: 'dynamic',\n  label: 'Mint at Current Price',\n  path: '/api/nft-current-price',\n  chains: { source: 'avalanche' },\n  params: [\n    {\n      name: 'tier',\n      label: 'NFT Tier',\n      type: 'select',\n      options: [\n        { label: 'Common', value: 'common' },\n        { label: 'Rare', value: 'rare' },\n        { label: 'Legendary', value: 'legendary' },\n      ],\n    },\n  ],\n};\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Server Logic:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Analyzes current market conditions"),(0,r.kt)("li",{parentName:"ul"},"Adjusts price based on demand/supply"),(0,r.kt)("li",{parentName:"ul"},"Considers whale wallet activity"),(0,r.kt)("li",{parentName:"ul"},"Sets optimal mint price dynamically")),(0,r.kt)("h3",{id:"3-cross-chain-optimization"},"3. ",(0,r.kt)("strong",{parentName:"h3"},"Cross-Chain Optimization")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const crossChainAction: DynamicAction = {\n  type: 'dynamic',\n  label: 'Optimal Cross-Chain Swap',\n  path: '/api/cross-chain-optimize',\n  chains: { source: 'avalanche', destination: 'celo' },\n  params: [\n    {\n      name: 'fromToken',\n      label: 'From Token',\n      type: 'select',\n      options: [\n        /* tokens on Avalanche */\n      ],\n    },\n    {\n      name: 'toToken',\n      label: 'To Token',\n      type: 'select',\n      options: [\n        /* tokens on Celo */\n      ],\n    },\n    {\n      name: 'amount',\n      label: 'Amount',\n      type: 'number',\n      required: true,\n    },\n  ],\n};\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Server Logic:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Compares direct bridge vs multi-hop routes"),(0,r.kt)("li",{parentName:"ul"},"Considers bridge fees, slippage, time"),(0,r.kt)("li",{parentName:"ul"},"Finds optimal path across chains"),(0,r.kt)("li",{parentName:"ul"},"Executes complex cross-chain transaction")),(0,r.kt)("h2",{id:"parameter-processing"},"Parameter Processing"),(0,r.kt)("p",null,"Dynamic Actions receive parameters as URL query parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Frontend config\nparams: [\n  { name: 'amount', label: 'Amount', type: 'number' },\n  { name: 'strategy', label: 'Strategy', type: 'select', options: [...] }\n]\n\n// Your API receives:\n// POST /api/your-endpoint?amount=1000&strategy=aggressive&userAddress=0x...\n")),(0,r.kt)("h3",{id:"accessing-parameters"},"Accessing Parameters"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export async function POST(req: NextRequest) {\n  const { searchParams } = new URL(req.url);\n\n  // Get user inputs\n  const amount = parseFloat(searchParams.get('amount') || '0');\n  const strategy = searchParams.get('strategy');\n\n  // Get additional context\n  const userAddress = searchParams.get('userAddress');\n  const chainId = searchParams.get('chain');\n\n  // Your logic here...\n}\n")),(0,r.kt)("h2",{id:"error-handling"},"Error Handling"),(0,r.kt)("p",null,"Handle errors gracefully in your Dynamic Actions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export async function POST(req: NextRequest) {\n  try {\n    // Your logic\n    return NextResponse.json(response);\n  } catch (error) {\n    console.error('Dynamic action error:', error);\n\n    // Return user-friendly error\n    return NextResponse.json(\n      {\n        error: 'Unable to calculate optimal strategy. Please try again.',\n        details: process.env.NODE_ENV === 'development' ? error.message : undefined,\n      },\n      { status: 500 },\n    );\n  }\n}\n")),(0,r.kt)("h2",{id:"best-practices"},"Best Practices"),(0,r.kt)("h3",{id:"1-validate-inputs"},"1. ",(0,r.kt)("strong",{parentName:"h3"},"Validate Inputs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Always validate user inputs\nif (amount < minimumAmount) {\n  return NextResponse.json({ error: 'Amount too low' }, { status: 400 });\n}\n")),(0,r.kt)("h3",{id:"2-handle-rate-limits"},"2. ",(0,r.kt)("strong",{parentName:"h3"},"Handle Rate Limits")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Implement rate limiting for expensive calculations\nconst rateLimiter = new RateLimit({\n  windowMs: 60 * 1000, // 1 minute\n  max: 10, // 10 requests per minute\n});\n")),(0,r.kt)("h3",{id:"3-cache-when-possible"},"3. ",(0,r.kt)("strong",{parentName:"h3"},"Cache When Possible")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Cache expensive calculations\nconst cacheKey = `strategy-${amount}-${risk}-${duration}`;\nconst cached = await redis.get(cacheKey);\nif (cached) {\n  return NextResponse.json(JSON.parse(cached));\n}\n")),(0,r.kt)("h3",{id:"4-provide-rich-feedback"},"4. ",(0,r.kt)("strong",{parentName:"h3"},"Provide Rich Feedback")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Include useful info in the response\nparams: {\n  functionName: 'executeStrategy',\n  args: {\n    expectedAPY: '12.5%',\n    protocols: ['Aave', 'Compound'],\n    riskLevel: 'Medium',\n    projectedValue: '$1,125 after 1 year'\n  }\n}\n")),(0,r.kt)("h3",{id:"5-security-considerations"},"5. ",(0,r.kt)("strong",{parentName:"h3"},"Security Considerations")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Validate user address if needed\nconst userAddress = req.headers.get('x-wallet-address');\nif (!isValidAddress(userAddress)) {\n  return NextResponse.json({ error: 'Invalid wallet' }, { status: 401 });\n}\n\n// Sanitize inputs\nconst sanitizedAmount = Math.max(0, Math.min(amount, MAX_AMOUNT));\n")),(0,r.kt)("h2",{id:"when-to-use-dynamic-actions"},"When to Use Dynamic Actions"),(0,r.kt)("h3",{id:"-perfect-for"},"\u2705 ",(0,r.kt)("strong",{parentName:"h3"},"Perfect for:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Multi-protocol yield optimization"),(0,r.kt)("li",{parentName:"ul"},"Real-time price calculations"),(0,r.kt)("li",{parentName:"ul"},"Complex arbitrage opportunities"),(0,r.kt)("li",{parentName:"ul"},"Cross-chain route optimization"),(0,r.kt)("li",{parentName:"ul"},"AI-powered trading strategies"),(0,r.kt)("li",{parentName:"ul"},"Market-dependent decisions"),(0,r.kt)("li",{parentName:"ul"},"Multi-step transaction planning")),(0,r.kt)("h3",{id:"-overkill-for"},"\u274c ",(0,r.kt)("strong",{parentName:"h3"},"Overkill for:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Simple token transfers (use Transfer Actions)"),(0,r.kt)("li",{parentName:"ul"},"Fixed-price NFT minting (use Blockchain Actions)"),(0,r.kt)("li",{parentName:"ul"},"Static contract calls (use Blockchain Actions)"),(0,r.kt)("li",{parentName:"ul"},"Simple approve/transfer flows")),(0,r.kt)("h2",{id:"deployment-considerations"},"Deployment Considerations"),(0,r.kt)("h3",{id:"production-checklist"},"Production Checklist:"),(0,r.kt)("ul",{className:"contains-task-list"},(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ",(0,r.kt)("strong",{parentName:"li"},"Performance"),": API responds in ${'<2'} seconds"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ",(0,r.kt)("strong",{parentName:"li"},"Error Handling"),": Graceful error messages"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ",(0,r.kt)("strong",{parentName:"li"},"Rate Limiting"),": Prevent abuse"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ",(0,r.kt)("strong",{parentName:"li"},"Monitoring"),": Log important events"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ",(0,r.kt)("strong",{parentName:"li"},"Caching"),": Cache expensive calculations"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ",(0,r.kt)("strong",{parentName:"li"},"Security"),": Validate all inputs"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ",(0,r.kt)("strong",{parentName:"li"},"Testing"),": Test with various scenarios")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"next-steps"},"Next Steps"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./blockchain-actions"},(0,r.kt)("strong",{parentName:"a"},"Blockchain Actions"))," - When direct contract calls are sufficient"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./transfer-actions"},(0,r.kt)("strong",{parentName:"a"},"Transfer Actions"))," - For simple native token transfers"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./action-flows"},(0,r.kt)("strong",{parentName:"a"},"Action Flows"))," - Combine Dynamic Actions in multi-step workflows"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"../parameters/parameters"},(0,r.kt)("strong",{parentName:"a"},"Parameters Guide"))," - Master parameter configuration")))}u.isMDXComponent=!0},3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(t),d=r,k=m["".concat(l,".").concat(d)]||m[d]||u[d]||i;return t?a.createElement(k,o(o({ref:n},p),{},{components:t})):a.createElement(k,o({ref:n},p))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);