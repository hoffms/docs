"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[7208],{22943:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var r=n(83117),a=(n(67294),n(3905));const i={},l="SwapMath",o={unversionedId:"contracts/v4/reference/core/libraries/SwapMath",id:"contracts/v4/reference/core/libraries/SwapMath",title:"SwapMath",description:"Git Source - Generated with forge doc",source:"@site/docs/contracts/v4/reference/core/libraries/SwapMath.md",sourceDirName:"contracts/v4/reference/core/libraries",slug:"/contracts/v4/reference/core/libraries/SwapMath",permalink:"/docs/contracts/v4/reference/core/libraries/SwapMath",editUrl:"https://github.com/hoffms/docs/tree/main/docs/contracts/v4/reference/core/libraries/SwapMath.md",tags:[],version:"current",frontMatter:{},sidebar:"contractsSidebar",previous:{title:"StateLibrary",permalink:"/docs/contracts/v4/reference/core/libraries/StateLibrary"},next:{title:"TickBitmap",permalink:"/docs/contracts/v4/reference/core/libraries/TickBitmap"}},p={},u=[{value:"State Variables",id:"state-variables",level:2},{value:"MAX_SWAP_FEE",id:"max_swap_fee",level:3},{value:"Functions",id:"functions",level:2},{value:"getSqrtPriceTarget",id:"getsqrtpricetarget",level:3},{value:"computeSwapStep",id:"computeswapstep",level:3}],c={toc:u};function m(t){let{components:e,...n}=t;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"swapmath"},"SwapMath"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/SwapMath.sol"},"Git Source")," - Generated with ",(0,a.kt)("a",{parentName:"p",href:"https://book.getfoundry.sh/reference/forge/forge-doc"},"forge doc")),(0,a.kt)("p",null,"Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick."),(0,a.kt)("h2",{id:"state-variables"},"State Variables"),(0,a.kt)("h3",{id:"max_swap_fee"},"MAX_SWAP_FEE"),(0,a.kt)("p",null,"the swap fee is represented in hundredths of a bip, so the max is 100%"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"the swap fee is the total fee on a swap, including both LP and Protocol fee")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 internal constant MAX_SWAP_FEE = 1e6;\n")),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("h3",{id:"getsqrtpricetarget"},"getSqrtPriceTarget"),(0,a.kt)("p",null,"Computes the sqrt price target for the next swap step"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160 sqrtPriceLimitX96)\n    internal\n    pure\n    returns (uint160 sqrtPriceTargetX96);\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Parameters")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"zeroForOne")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"bool")),(0,a.kt)("td",{parentName:"tr",align:null},"The direction of the swap, true for currency0 to currency1, false for currency1 to currency0")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"sqrtPriceNextX96")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint160")),(0,a.kt)("td",{parentName:"tr",align:null},"The Q64.96 sqrt price for the next initialized tick")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"sqrtPriceLimitX96")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint160")),(0,a.kt)("td",{parentName:"tr",align:null},"The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"sqrtPriceTargetX96")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint160")),(0,a.kt)("td",{parentName:"tr",align:null},"The price target for the next swap step")))),(0,a.kt)("h3",{id:"computeswapstep"},"computeSwapStep"),(0,a.kt)("p",null,"Computes the result of swapping some amount in, or amount out, given the parameters of the swap"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"If the swap's amountSpecified is negative, the combined fee and input amount will never exceed the absolute value of the remaining amount.")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"feePips must be no larger than MAX_SWAP_FEE for this function. We ensure that before setting a fee using LPFeeLibrary.isValid.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function computeSwapStep(\n    uint160 sqrtPriceCurrentX96,\n    uint160 sqrtPriceTargetX96,\n    uint128 liquidity,\n    int256 amountRemaining,\n    uint24 feePips\n) internal pure returns (uint160 sqrtPriceNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount);\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Parameters")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"sqrtPriceCurrentX96")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint160")),(0,a.kt)("td",{parentName:"tr",align:null},"The current sqrt price of the pool")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"sqrtPriceTargetX96")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint160")),(0,a.kt)("td",{parentName:"tr",align:null},"The price that cannot be exceeded, from which the direction of the swap is inferred")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint128")),(0,a.kt)("td",{parentName:"tr",align:null},"The usable liquidity")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"amountRemaining")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"int256")),(0,a.kt)("td",{parentName:"tr",align:null},"How much input or output amount is remaining to be swapped in/out")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"feePips")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint24")),(0,a.kt)("td",{parentName:"tr",align:null},"The fee taken from the input amount, expressed in hundredths of a bip")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"sqrtPriceNextX96")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint160")),(0,a.kt)("td",{parentName:"tr",align:null},"The price after swapping the amount in/out, not to exceed the price target")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"amountIn")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint256")),(0,a.kt)("td",{parentName:"tr",align:null},"The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"amountOut")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint256")),(0,a.kt)("td",{parentName:"tr",align:null},"The amount to be received, of either currency0 or currency1, based on the direction of the swap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"feeAmount")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"uint256")),(0,a.kt)("td",{parentName:"tr",align:null},"The amount of input that will be taken as a fee")))))}m.isMDXComponent=!0},3905:(t,e,n)=>{n.d(e,{Zo:()=>c,kt:()=>s});var r=n(67294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},i=Object.keys(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var p=r.createContext({}),u=function(t){var e=r.useContext(p),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},c=function(t){var e=u(t.components);return r.createElement(p.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(t,e){var n=t.components,a=t.mdxType,i=t.originalType,p=t.parentName,c=o(t,["components","mdxType","originalType","parentName"]),d=u(n),s=a,k=d["".concat(p,".").concat(s)]||d[s]||m[s]||i;return n?r.createElement(k,l(l({ref:e},c),{},{components:n})):r.createElement(k,l({ref:e},c))}));function s(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var i=n.length,l=new Array(i);l[0]=d;var o={};for(var p in e)hasOwnProperty.call(e,p)&&(o[p]=e[p]);o.originalType=t,o.mdxType="string"==typeof t?t:a,l[1]=o;for(var u=2;u<i;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);