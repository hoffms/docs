"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[69697],{94384:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>u,toc:()=>p});var r=n(83117),a=(n(67294),n(3905));const i={title:"LiquidityAmounts"},l=void 0,u={unversionedId:"contracts/v4/reference/core/libraries/liquidity-amounts",id:"contracts/v4/reference/core/libraries/liquidity-amounts",title:"LiquidityAmounts",description:"The LiquidityAmounts library provides functions for computing liquidity amounts from token amounts and prices in Uniswap V4.",source:"@site/docs/contracts/v4/reference/core/libraries/liquidity-amounts.mdx",sourceDirName:"contracts/v4/reference/core/libraries",slug:"/contracts/v4/reference/core/libraries/liquidity-amounts",permalink:"/docs/contracts/v4/reference/core/libraries/liquidity-amounts",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/v4/reference/core/libraries/liquidity-amounts.mdx",tags:[],version:"current",frontMatter:{title:"LiquidityAmounts"},sidebar:"contractsSidebar",previous:{title:"UnsafeMath",permalink:"/docs/contracts/v4/reference/core/libraries/UnsafeMath"},next:{title:"TransientStateLibrary",permalink:"/docs/contracts/v4/reference/core/libraries/transient-state-library"}},o={},p=[{value:"getLiquidityForAmount0",id:"getliquidityforamount0",level:2},{value:"getLiquidityForAmount1",id:"getliquidityforamount1",level:2},{value:"getLiquidityForAmounts",id:"getliquidityforamounts",level:2},{value:"getAmount0ForLiquidity",id:"getamount0forliquidity",level:2},{value:"getAmount1ForLiquidity",id:"getamount1forliquidity",level:2},{value:"getAmountsForLiquidity",id:"getamountsforliquidity",level:2}],m={toc:p};function d(t){let{components:e,...n}=t;return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"LiquidityAmounts")," library provides functions for computing liquidity amounts from token amounts and prices in Uniswap V4."),(0,a.kt)("h1",{id:"key-concept-sqrtpricex96"},"Key Concept: sqrtPriceX96"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96")," represents the square root of the price ratio of token1 to token0, multiplied by 2^96. This representation allows for precise price calculations across a wide range of values while using fixed-point arithmetic. It's more efficient than using ticks for intermediate calculations, as it avoids frequent conversions between prices and ticks."),(0,a.kt)("h1",{id:"functions"},"Functions"),(0,a.kt)("h2",{id:"getliquidityforamount0"},"getLiquidityForAmount0"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function getLiquidityForAmount0(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount0)\ninternal\npure\nreturns (uint128 liquidity)\n")),(0,a.kt)("p",null,"Computes the amount of liquidity received for a given amount of token0 and price range."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceAX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at first tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceBX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at second tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"amount0"),(0,a.kt)("td",{parentName:"tr",align:null},"uint256"),(0,a.kt)("td",{parentName:"tr",align:null},"The amount of token0 being sent in")))),(0,a.kt)("p",null,"Returns the amount of liquidity received."),(0,a.kt)("h2",{id:"getliquidityforamount1"},"getLiquidityForAmount1"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function getLiquidityForAmount1(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount1)\ninternal\npure\nreturns (uint128 liquidity)\n")),(0,a.kt)("p",null,"Computes the amount of liquidity received for a given amount of token1 and price range."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceAX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at first tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceBX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at second tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"amount1"),(0,a.kt)("td",{parentName:"tr",align:null},"uint256"),(0,a.kt)("td",{parentName:"tr",align:null},"The amount of token1 being sent in")))),(0,a.kt)("p",null,"Returns the amount of liquidity received."),(0,a.kt)("h2",{id:"getliquidityforamounts"},"getLiquidityForAmounts"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function getLiquidityForAmounts(\nuint160 sqrtPriceX96,\nuint160 sqrtPriceAX96,\nuint160 sqrtPriceBX96,\nuint256 amount0,\nuint256 amount1\n) internal pure returns (uint128 liquidity)\n")),(0,a.kt)("p",null,"Computes the maximum amount of liquidity received for given amounts of token0 and token1, the current pool prices, and the prices at the tick boundaries."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Current square root price of the pool")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceAX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at first tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceBX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at second tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"amount0"),(0,a.kt)("td",{parentName:"tr",align:null},"uint256"),(0,a.kt)("td",{parentName:"tr",align:null},"The amount of token0 being sent in")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"amount1"),(0,a.kt)("td",{parentName:"tr",align:null},"uint256"),(0,a.kt)("td",{parentName:"tr",align:null},"The amount of token1 being sent in")))),(0,a.kt)("p",null,"Returns the maximum amount of liquidity received."),(0,a.kt)("h2",{id:"getamount0forliquidity"},"getAmount0ForLiquidity"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function getAmount0ForLiquidity(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity)\ninternal\npure\nreturns (uint256 amount0)\n")),(0,a.kt)("p",null,"Computes the amount of token0 for a given amount of liquidity and a price range."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceAX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at first tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceBX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at second tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"liquidity"),(0,a.kt)("td",{parentName:"tr",align:null},"uint128"),(0,a.kt)("td",{parentName:"tr",align:null},"The liquidity being valued")))),(0,a.kt)("p",null,"Returns the amount of token0."),(0,a.kt)("h2",{id:"getamount1forliquidity"},"getAmount1ForLiquidity"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function getAmount1ForLiquidity(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity)\ninternal\npure\nreturns (uint256 amount1)\n")),(0,a.kt)("p",null,"Computes the amount of token1 for a given amount of liquidity and a price range."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceAX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at first tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceBX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at second tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"liquidity"),(0,a.kt)("td",{parentName:"tr",align:null},"uint128"),(0,a.kt)("td",{parentName:"tr",align:null},"The liquidity being valued")))),(0,a.kt)("p",null,"Returns the amount of token1."),(0,a.kt)("h2",{id:"getamountsforliquidity"},"getAmountsForLiquidity"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function getAmountsForLiquidity(\nuint160 sqrtPriceX96,\nuint160 sqrtPriceAX96,\nuint160 sqrtPriceBX96,\nuint128 liquidity\n) internal pure returns (uint256 amount0, uint256 amount1)\n")),(0,a.kt)("p",null,"Computes the token0 and token1 value for a given amount of liquidity, the current pool prices, and the prices at the tick boundaries."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Param Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Current square root price of the pool")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceAX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at first tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sqrtPriceBX96"),(0,a.kt)("td",{parentName:"tr",align:null},"uint160"),(0,a.kt)("td",{parentName:"tr",align:null},"Square root of price at second tick boundary")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"liquidity"),(0,a.kt)("td",{parentName:"tr",align:null},"uint128"),(0,a.kt)("td",{parentName:"tr",align:null},"The liquidity being valued")))),(0,a.kt)("p",null,"Returns the amount of token0 and token1."))}d.isMDXComponent=!0},3905:(t,e,n)=>{n.d(e,{Zo:()=>m,kt:()=>s});var r=n(67294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function u(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},i=Object.keys(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var o=r.createContext({}),p=function(t){var e=r.useContext(o),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},m=function(t){var e=p(t.components);return r.createElement(o.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},c=r.forwardRef((function(t,e){var n=t.components,a=t.mdxType,i=t.originalType,o=t.parentName,m=u(t,["components","mdxType","originalType","parentName"]),c=p(n),s=a,k=c["".concat(o,".").concat(s)]||c[s]||d[s]||i;return n?r.createElement(k,l(l({ref:e},m),{},{components:n})):r.createElement(k,l({ref:e},m))}));function s(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var i=n.length,l=new Array(i);l[0]=c;var u={};for(var o in e)hasOwnProperty.call(e,o)&&(u[o]=e[o]);u.originalType=t,u.mdxType="string"==typeof t?t:a,l[1]=u;for(var p=2;p<i;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);