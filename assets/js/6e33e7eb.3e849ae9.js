"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[78249],{61999:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>i,default:()=>k,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var n=a(83117),l=(a(67294),a(3905));const r={},i="IPoolManager",o={unversionedId:"contracts/v4/reference/core/interfaces/IPoolManager",id:"contracts/v4/reference/core/interfaces/IPoolManager",title:"IPoolManager",description:"Git Source - Generated with forge doc",source:"@site/docs/contracts/v4/reference/core/interfaces/IPoolManager.md",sourceDirName:"contracts/v4/reference/core/interfaces",slug:"/contracts/v4/reference/core/interfaces/IPoolManager",permalink:"/docs/contracts/v4/reference/core/interfaces/IPoolManager",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/v4/reference/core/interfaces/IPoolManager.md",tags:[],version:"current",frontMatter:{},sidebar:"contractsSidebar",previous:{title:"IHooks",permalink:"/docs/contracts/v4/reference/core/interfaces/IHooks"},next:{title:"IProtocolFees",permalink:"/docs/contracts/v4/reference/core/interfaces/IProtocolFees"}},d={},p=[{value:"Functions",id:"functions",level:2},{value:"unlock",id:"unlock",level:3},{value:"initialize",id:"initialize",level:3},{value:"modifyLiquidity",id:"modifyliquidity",level:3},{value:"swap",id:"swap",level:3},{value:"donate",id:"donate",level:3},{value:"sync",id:"sync",level:3},{value:"take",id:"take",level:3},{value:"settle",id:"settle",level:3},{value:"settleFor",id:"settlefor",level:3},{value:"clear",id:"clear",level:3},{value:"mint",id:"mint",level:3},{value:"burn",id:"burn",level:3},{value:"updateDynamicLPFee",id:"updatedynamiclpfee",level:3},{value:"Events",id:"events",level:2},{value:"Initialize",id:"initialize-1",level:3},{value:"ModifyLiquidity",id:"modifyliquidity-1",level:3},{value:"Swap",id:"swap-1",level:3},{value:"Donate",id:"donate-1",level:3},{value:"Errors",id:"errors",level:2},{value:"CurrencyNotSettled",id:"currencynotsettled",level:3},{value:"PoolNotInitialized",id:"poolnotinitialized",level:3},{value:"AlreadyUnlocked",id:"alreadyunlocked",level:3},{value:"ManagerLocked",id:"managerlocked",level:3},{value:"TickSpacingTooLarge",id:"tickspacingtoolarge",level:3},{value:"TickSpacingTooSmall",id:"tickspacingtoosmall",level:3},{value:"CurrenciesOutOfOrderOrEqual",id:"currenciesoutoforderorequal",level:3},{value:"UnauthorizedDynamicLPFeeUpdate",id:"unauthorizeddynamiclpfeeupdate",level:3},{value:"SwapAmountCannotBeZero",id:"swapamountcannotbezero",level:3},{value:"NonzeroNativeValue",id:"nonzeronativevalue",level:3},{value:"MustClearExactPositiveDelta",id:"mustclearexactpositivedelta",level:3},{value:"Structs",id:"structs",level:2},{value:"ModifyLiquidityParams",id:"modifyliquidityparams",level:3},{value:"SwapParams",id:"swapparams",level:3}],m={toc:p};function k(t){let{components:e,...a}=t;return(0,l.kt)("wrapper",(0,n.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"ipoolmanager"},"IPoolManager"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IPoolManager.sol"},"Git Source")," - Generated with ",(0,l.kt)("a",{parentName:"p",href:"https://book.getfoundry.sh/reference/forge/forge-doc"},"forge doc")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Inherits:"),"\n",(0,l.kt)("a",{parentName:"p",href:"/docs/contracts/v4/reference/core/interfaces/IProtocolFees"},"IProtocolFees"),", ",(0,l.kt)("a",{parentName:"p",href:"/docs/contracts/v4/reference/core/interfaces/IERC6909Claims"},"IERC6909Claims"),", ",(0,l.kt)("a",{parentName:"p",href:"/docs/contracts/v4/reference/core/interfaces/IExtsload"},"IExtsload"),", ",(0,l.kt)("a",{parentName:"p",href:"/docs/contracts/v4/reference/core/interfaces/IExttload"},"IExttload")),(0,l.kt)("p",null,"Interface for the PoolManager"),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("h3",{id:"unlock"},"unlock"),(0,l.kt)("p",null,"All interactions on the contract that account deltas require unlocking. A caller that calls ",(0,l.kt)("inlineCode",{parentName:"p"},"unlock")," must implement\n",(0,l.kt)("inlineCode",{parentName:"p"},"IUnlockCallback(msg.sender).unlockCallback(data)"),", where they interact with the remaining functions on this contract."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"The only functions callable without an unlocking are ",(0,l.kt)("inlineCode",{parentName:"em"},"initialize")," and ",(0,l.kt)("inlineCode",{parentName:"em"},"updateDynamicLPFee"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function unlock(bytes calldata data) external returns (bytes memory);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"data")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bytes")),(0,l.kt)("td",{parentName:"tr",align:null},"Any data to pass to the callback, via ",(0,l.kt)("inlineCode",{parentName:"td"},"IUnlockCallback(msg.sender).unlockCallback(data)"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"<none>")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bytes")),(0,l.kt)("td",{parentName:"tr",align:null},"The data returned by the call to ",(0,l.kt)("inlineCode",{parentName:"td"},"IUnlockCallback(msg.sender).unlockCallback(data)"))))),(0,l.kt)("h3",{id:"initialize"},"initialize"),(0,l.kt)("p",null,"Initialize the state for a given pool ID"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function initialize(PoolKey memory key, uint160 sqrtPriceX96) external returns (int24 tick);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"key")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"PoolKey")),(0,l.kt)("td",{parentName:"tr",align:null},"The pool key for the pool to initialize")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"sqrtPriceX96")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint160")),(0,l.kt)("td",{parentName:"tr",align:null},"The initial square root price")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"tick")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int24")),(0,l.kt)("td",{parentName:"tr",align:null},"The initial tick of the pool")))),(0,l.kt)("h3",{id:"modifyliquidity"},"modifyLiquidity"),(0,l.kt)("p",null,"Modify the liquidity for the given pool"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Poke by calling with a zero liquidityDelta")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Note that feesAccrued can be artificially inflated by a malicious actor and integrators should be careful using the value\nFor pools with a single liquidity position, actors can donate to themselves to inflate feeGrowthGlobal (and consequently feesAccrued)\natomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes calldata hookData)\n    external\n    returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"key")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"PoolKey")),(0,l.kt)("td",{parentName:"tr",align:null},"The pool to modify liquidity in")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"params")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ModifyLiquidityParams")),(0,l.kt)("td",{parentName:"tr",align:null},"The parameters for modifying the liquidity")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"hookData")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bytes")),(0,l.kt)("td",{parentName:"tr",align:null},"The data to pass through to the add/removeLiquidity hooks")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"callerDelta")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")),(0,l.kt)("td",{parentName:"tr",align:null},"The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"feesAccrued")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")),(0,l.kt)("td",{parentName:"tr",align:null},"The balance delta of the fees generated in the liquidity range. Returned for informational purposes")))),(0,l.kt)("h3",{id:"swap"},"swap"),(0,l.kt)("p",null,"Swap against the given pool"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.\nAdditionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG\nthe hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n    external\n    returns (BalanceDelta swapDelta);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"key")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"PoolKey")),(0,l.kt)("td",{parentName:"tr",align:null},"The pool to swap in")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"params")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"SwapParams")),(0,l.kt)("td",{parentName:"tr",align:null},"The parameters for swapping")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"hookData")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bytes")),(0,l.kt)("td",{parentName:"tr",align:null},"The data to pass through to the swap hooks")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"swapDelta")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")),(0,l.kt)("td",{parentName:"tr",align:null},"The balance delta of the address swapping")))),(0,l.kt)("h3",{id:"donate"},"donate"),(0,l.kt)("p",null,"Donate the given currency amounts to the in-range liquidity providers of a pool"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds.\nDonors should keep this in mind when designing donation mechanisms.")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"This function donates to in-range LPs at slot0.tick. In certain edge-cases of the swap algorithm, the ",(0,l.kt)("inlineCode",{parentName:"em"},"sqrtPrice")," of\na pool can be at the lower boundary of tick ",(0,l.kt)("inlineCode",{parentName:"em"},"n"),", but the ",(0,l.kt)("inlineCode",{parentName:"em"},"slot0.tick")," of the pool is already ",(0,l.kt)("inlineCode",{parentName:"em"},"n - 1"),". In this case a call to\n",(0,l.kt)("inlineCode",{parentName:"em"},"donate")," would donate to tick ",(0,l.kt)("inlineCode",{parentName:"em"},"n - 1")," (slot0.tick) not tick ",(0,l.kt)("inlineCode",{parentName:"em"},"n")," (getTickAtSqrtPrice(slot0.sqrtPriceX96)).\nRead the comments in ",(0,l.kt)("inlineCode",{parentName:"em"},"Pool.swap()")," for more information about this.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n    external\n    returns (BalanceDelta);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"key")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"PoolKey")),(0,l.kt)("td",{parentName:"tr",align:null},"The key of the pool to donate to")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"amount0")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of currency0 to donate")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"amount1")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of currency1 to donate")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"hookData")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bytes")),(0,l.kt)("td",{parentName:"tr",align:null},"The data to pass through to the donate hooks")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"<none>")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"BalanceDelta")),(0,l.kt)("td",{parentName:"tr",align:null},"BalanceDelta The delta of the caller after the donate")))),(0,l.kt)("h3",{id:"sync"},"sync"),(0,l.kt)("p",null,"Writes the current ERC20 balance of the specified currency to transient storage\nThis is used to checkpoint balances for the manager and derive deltas for the caller."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped\nfor native tokens because the amount to settle is determined by the sent value.\nHowever, if an ERC20 token has been synced and not settled, and the caller instead wants to settle\nnative funds, this function can be called with the native currency to then be able to settle the native currency")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function sync(Currency currency) external;\n")),(0,l.kt)("h3",{id:"take"},"take"),(0,l.kt)("p",null,"Called by the user to net out some value owed to the user"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Will revert if the requested amount is not available, consider using ",(0,l.kt)("inlineCode",{parentName:"em"},"mint")," instead")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Can also be used as a mechanism for free flash loans")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function take(Currency currency, address to, uint256 amount) external;\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"currency")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Currency")),(0,l.kt)("td",{parentName:"tr",align:null},"The currency to withdraw from the pool manager")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"to")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"address")),(0,l.kt)("td",{parentName:"tr",align:null},"The address to withdraw to")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"amount")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of currency to withdraw")))),(0,l.kt)("h3",{id:"settle"},"settle"),(0,l.kt)("p",null,"Called by the user to pay what is owed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function settle() external payable returns (uint256 paid);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"paid")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of currency settled")))),(0,l.kt)("h3",{id:"settlefor"},"settleFor"),(0,l.kt)("p",null,"Called by the user to pay on behalf of another address"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function settleFor(address recipient) external payable returns (uint256 paid);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"recipient")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"address")),(0,l.kt)("td",{parentName:"tr",align:null},"The address to credit for the payment")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"paid")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of currency settled")))),(0,l.kt)("h3",{id:"clear"},"clear"),(0,l.kt)("p",null,"WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently.\nA call to clear will zero out a positive balance WITHOUT a corresponding transfer."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"This could be used to clear a balance that is considered dust.\nAdditionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function clear(Currency currency, uint256 amount) external;\n")),(0,l.kt)("h3",{id:"mint"},"mint"),(0,l.kt)("p",null,"Called by the user to move value into ERC6909 balance"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"The id is converted to a uint160 to correspond to a currency address\nIf the upper 12 bytes are not 0, they will be 0-ed out")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function mint(address to, uint256 id, uint256 amount) external;\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"to")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"address")),(0,l.kt)("td",{parentName:"tr",align:null},"The address to mint the tokens to")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"id")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The currency address to mint to ERC6909s, as a uint256")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"amount")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of currency to mint")))),(0,l.kt)("h3",{id:"burn"},"burn"),(0,l.kt)("p",null,"Called by the user to move value from ERC6909 balance"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"The id is converted to a uint160 to correspond to a currency address\nIf the upper 12 bytes are not 0, they will be 0-ed out")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function burn(address from, uint256 id, uint256 amount) external;\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"from")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"address")),(0,l.kt)("td",{parentName:"tr",align:null},"The address to burn the tokens from")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"id")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The currency address to burn from ERC6909s, as a uint256")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"amount")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of currency to burn")))),(0,l.kt)("h3",{id:"updatedynamiclpfee"},"updateDynamicLPFee"),(0,l.kt)("p",null,"Updates the pools lp fees for the a pool that has enabled dynamic lp fees."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"key")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"PoolKey")),(0,l.kt)("td",{parentName:"tr",align:null},"The key of the pool to update dynamic LP fees for")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"newDynamicLPFee")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint24")),(0,l.kt)("td",{parentName:"tr",align:null},"The new dynamic pool LP fee")))),(0,l.kt)("h2",{id:"events"},"Events"),(0,l.kt)("h3",{id:"initialize-1"},"Initialize"),(0,l.kt)("p",null,"Emitted when a new pool is initialized"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event Initialize(\n    PoolId indexed id,\n    Currency indexed currency0,\n    Currency indexed currency1,\n    uint24 fee,\n    int24 tickSpacing,\n    IHooks hooks,\n    uint160 sqrtPriceX96,\n    int24 tick\n);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"id")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"PoolId")),(0,l.kt)("td",{parentName:"tr",align:null},"The abi encoded hash of the pool key struct for the new pool")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"currency0")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Currency")),(0,l.kt)("td",{parentName:"tr",align:null},"The first currency of the pool by address sort order")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"currency1")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Currency")),(0,l.kt)("td",{parentName:"tr",align:null},"The second currency of the pool by address sort order")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"fee")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint24")),(0,l.kt)("td",{parentName:"tr",align:null},"The fee collected upon every swap in the pool, denominated in hundredths of a bip")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"tickSpacing")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int24")),(0,l.kt)("td",{parentName:"tr",align:null},"The minimum number of ticks between initialized ticks")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"hooks")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"IHooks")),(0,l.kt)("td",{parentName:"tr",align:null},"The hooks contract address for the pool, or address(0) if none")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"sqrtPriceX96")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint160")),(0,l.kt)("td",{parentName:"tr",align:null},"The price of the pool on initialization")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"tick")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int24")),(0,l.kt)("td",{parentName:"tr",align:null},"The initial tick of the pool corresponding to the initialized price")))),(0,l.kt)("h3",{id:"modifyliquidity-1"},"ModifyLiquidity"),(0,l.kt)("p",null,"Emitted when a liquidity position is modified"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event ModifyLiquidity(\n    PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt\n);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"id")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"PoolId")),(0,l.kt)("td",{parentName:"tr",align:null},"The abi encoded hash of the pool key struct for the pool that was modified")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"sender")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"address")),(0,l.kt)("td",{parentName:"tr",align:null},"The address that modified the pool")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"tickLower")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int24")),(0,l.kt)("td",{parentName:"tr",align:null},"The lower tick of the position")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"tickUpper")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int24")),(0,l.kt)("td",{parentName:"tr",align:null},"The upper tick of the position")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"liquidityDelta")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int256")),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of liquidity that was added or removed")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"salt")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bytes32")),(0,l.kt)("td",{parentName:"tr",align:null},"The extra data to make positions unique")))),(0,l.kt)("h3",{id:"swap-1"},"Swap"),(0,l.kt)("p",null,"Emitted for swaps between currency0 and currency1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event Swap(\n    PoolId indexed id,\n    address indexed sender,\n    int128 amount0,\n    int128 amount1,\n    uint160 sqrtPriceX96,\n    uint128 liquidity,\n    int24 tick,\n    uint24 fee\n);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"id")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"PoolId")),(0,l.kt)("td",{parentName:"tr",align:null},"The abi encoded hash of the pool key struct for the pool that was modified")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"sender")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"address")),(0,l.kt)("td",{parentName:"tr",align:null},"The address that initiated the swap call, and that received the callback")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"amount0")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int128")),(0,l.kt)("td",{parentName:"tr",align:null},"The delta of the currency0 balance of the pool")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"amount1")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int128")),(0,l.kt)("td",{parentName:"tr",align:null},"The delta of the currency1 balance of the pool")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"sqrtPriceX96")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint160")),(0,l.kt)("td",{parentName:"tr",align:null},"The sqrt(price) of the pool after the swap, as a Q64.96")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint128")),(0,l.kt)("td",{parentName:"tr",align:null},"The liquidity of the pool after the swap")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"tick")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int24")),(0,l.kt)("td",{parentName:"tr",align:null},"The log base 1.0001 of the price of the pool after the swap")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"fee")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint24")),(0,l.kt)("td",{parentName:"tr",align:null},"The swap fee in hundredths of a bip")))),(0,l.kt)("h3",{id:"donate-1"},"Donate"),(0,l.kt)("p",null,"Emitted for donations"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"id")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"PoolId")),(0,l.kt)("td",{parentName:"tr",align:null},"The abi encoded hash of the pool key struct for the pool that was donated to")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"sender")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"address")),(0,l.kt)("td",{parentName:"tr",align:null},"The address that initiated the donate call")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"amount0")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The amount donated in currency0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"amount1")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint256")),(0,l.kt)("td",{parentName:"tr",align:null},"The amount donated in currency1")))),(0,l.kt)("h2",{id:"errors"},"Errors"),(0,l.kt)("h3",{id:"currencynotsettled"},"CurrencyNotSettled"),(0,l.kt)("p",null,"Thrown when a currency is not netted out after the contract is unlocked"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error CurrencyNotSettled();\n")),(0,l.kt)("h3",{id:"poolnotinitialized"},"PoolNotInitialized"),(0,l.kt)("p",null,"Thrown when trying to interact with a non-initialized pool"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error PoolNotInitialized();\n")),(0,l.kt)("h3",{id:"alreadyunlocked"},"AlreadyUnlocked"),(0,l.kt)("p",null,"Thrown when unlock is called, but the contract is already unlocked"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error AlreadyUnlocked();\n")),(0,l.kt)("h3",{id:"managerlocked"},"ManagerLocked"),(0,l.kt)("p",null,"Thrown when a function is called that requires the contract to be unlocked, but it is not"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error ManagerLocked();\n")),(0,l.kt)("h3",{id:"tickspacingtoolarge"},"TickSpacingTooLarge"),(0,l.kt)("p",null,"Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error TickSpacingTooLarge(int24 tickSpacing);\n")),(0,l.kt)("h3",{id:"tickspacingtoosmall"},"TickSpacingTooSmall"),(0,l.kt)("p",null,"Pools must have a positive non-zero tickSpacing passed to #initialize"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error TickSpacingTooSmall(int24 tickSpacing);\n")),(0,l.kt)("h3",{id:"currenciesoutoforderorequal"},"CurrenciesOutOfOrderOrEqual"),(0,l.kt)("p",null,"PoolKey must have currencies where address(currency0) < address(currency1)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);\n")),(0,l.kt)("h3",{id:"unauthorizeddynamiclpfeeupdate"},"UnauthorizedDynamicLPFeeUpdate"),(0,l.kt)("p",null,"Thrown when a call to updateDynamicLPFee is made by an address that is not the hook,\nor on a pool that does not have a dynamic swap fee."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error UnauthorizedDynamicLPFeeUpdate();\n")),(0,l.kt)("h3",{id:"swapamountcannotbezero"},"SwapAmountCannotBeZero"),(0,l.kt)("p",null,"Thrown when trying to swap amount of 0"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error SwapAmountCannotBeZero();\n")),(0,l.kt)("h3",{id:"nonzeronativevalue"},"NonzeroNativeValue"),(0,l.kt)("p",null,"Thrown when native currency is passed to a non native settlement"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error NonzeroNativeValue();\n")),(0,l.kt)("h3",{id:"mustclearexactpositivedelta"},"MustClearExactPositiveDelta"),(0,l.kt)("p",null,"Thrown when ",(0,l.kt)("inlineCode",{parentName:"p"},"clear")," is called with an amount that is not exactly equal to the open currency delta."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error MustClearExactPositiveDelta();\n")),(0,l.kt)("h2",{id:"structs"},"Structs"),(0,l.kt)("h3",{id:"modifyliquidityparams"},"ModifyLiquidityParams"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct ModifyLiquidityParams {\n    int24 tickLower;\n    int24 tickUpper;\n    int256 liquidityDelta;\n    bytes32 salt;\n}\n")),(0,l.kt)("h3",{id:"swapparams"},"SwapParams"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct SwapParams {\n    bool zeroForOne;\n    int256 amountSpecified;\n    uint160 sqrtPriceLimitX96;\n}\n")))}k.isMDXComponent=!0},3905:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>s});var n=a(67294);function l(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){l(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,l=function(t,e){if(null==t)return{};var a,n,l={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(l[a]=t[a]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(l[a]=t[a])}return l}var d=n.createContext({}),p=function(t){var e=n.useContext(d),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},m=function(t){var e=p(t.components);return n.createElement(d.Provider,{value:e},t.children)},k={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},u=n.forwardRef((function(t,e){var a=t.components,l=t.mdxType,r=t.originalType,d=t.parentName,m=o(t,["components","mdxType","originalType","parentName"]),u=p(a),s=l,c=u["".concat(d,".").concat(s)]||u[s]||k[s]||r;return a?n.createElement(c,i(i({ref:e},m),{},{components:a})):n.createElement(c,i({ref:e},m))}));function s(t,e){var a=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=a.length,i=new Array(r);i[0]=u;var o={};for(var d in e)hasOwnProperty.call(e,d)&&(o[d]=e[d]);o.originalType=t,o.mdxType="string"==typeof t?t:l,i[1]=o;for(var p=2;p<r;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);