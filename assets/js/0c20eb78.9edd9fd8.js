"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[6820],{7477:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(83117),o=(a(67294),a(3905));const r={title:"Custom Accounting"},i="Introduction",s={unversionedId:"contracts/v4/guides/custom-accounting",id:"contracts/v4/guides/custom-accounting",title:"Custom Accounting",description:"Uniswap v4 introduces a set of powerful, interconnected features that proposes a new way automated market makers (AMMs) can function. Custom accounting, hook fees, custom curves, and return deltas might seem like distinct concepts, but they form a cohesive system that enables unprecedented flexibility in decentralized exchange mechanisms.",source:"@site/docs/contracts/v4/guides/08-custom-accounting.mdx",sourceDirName:"contracts/v4/guides",slug:"/contracts/v4/guides/custom-accounting",permalink:"/docs/contracts/v4/guides/custom-accounting",editUrl:"https://github.com/hoffms/docs/tree/main/docs/contracts/v4/guides/08-custom-accounting.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"Custom Accounting"},sidebar:"contractsSidebar",previous:{title:"Reading Pool State",permalink:"/docs/contracts/v4/guides/read-pool-state"},next:{title:"Swap routing",permalink:"/docs/contracts/v4/guides/swap-routing"}},l={},p=[{value:"Delta Accounting in\xa0v4",id:"delta-accounting-inv4",level:2},{value:"Hook Fees in\xa0v4",id:"hook-fees-inv4",level:2},{value:"Custom Curves in\xa0v4",id:"custom-curves-inv4",level:2},{value:"Return Deltas in\xa0v4",id:"return-deltas-inv4",level:2},{value:"Step 1: Setting Up the Hook",id:"step-1-setting-up-the-hook",level:2},{value:"Step 2: Implementing the beforeSwap Function",id:"step-2-implementing-the-beforeswap-function",level:2},{value:"Step 2.1: Calculate the swap amount and fee",id:"step-21-calculate-the-swap-amount-and-fee",level:3},{value:"Step 2.2: Collect the fee",id:"step-22-collect-the-fee",level:3},{value:"Step 2.3: Create the BeforeSwapDelta",id:"step-23-create-the-beforeswapdelta",level:3},{value:"Step 2.4: Return values",id:"step-24-return-values",level:3},{value:"Step 3: Understanding the BeforeSwapDelta Mechanism",id:"step-3-understanding-the-beforeswapdelta-mechanism",level:2},{value:"Conclusion",id:"conclusion",level:2}],c={toc:p};function u(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"Uniswap v4 introduces a set of powerful, interconnected features that proposes a new way automated market makers (AMMs) can function. Custom accounting, hook fees, custom curves, and return deltas might seem like distinct concepts, but they form a cohesive system that enables unprecedented flexibility in decentralized exchange mechanisms."),(0,o.kt)("p",null,"These features are grouped together because they collectively represent the core of Uniswap v4\u2019s customizability. They all relate to how pool state is managed and modified, working in tandem to allow developers to create highly tailored AMM experiences. From dynamic fee structures to unique bonding curves."),(0,o.kt)("h1",{id:"brief-overview-ofconcepts"},"Brief Overview of\xa0Concepts"),(0,o.kt)("p",null,"Before we dive into the details of custom accounting, hook fees, custom curves, and return deltas, let\u2019s explore how these features work in Uniswap v4."),(0,o.kt)("h2",{id:"delta-accounting-inv4"},"Delta Accounting in\xa0v4"),(0,o.kt)("p",null,"As described in ",(0,o.kt)("a",{parentName:"p",href:"/contracts/v4/concepts/flash-accounting"},"Flash Accounting")," Uniswap v4 tracks net token transfers with transient storage. Unlike previous versions that tracked absolute token balances, v4 records changes to these balances (",(0,o.kt)("em",{parentName:"p"},"deltas"),"). This approach is at the core of v4\u2019s enhanced flexibility and efficiency."),(0,o.kt)("p",null,"In the v4 architecture, the ",(0,o.kt)("a",{parentName:"p",href:"/contracts/v4/concepts/PoolManager"},(0,o.kt)("inlineCode",{parentName:"a"},"PoolManager"))," manages credits or debits per address. After a swap router contract interacts with the PoolManager, the core contract determines that the swap router owes input tokens and must claim output tokens. Token balances are tracked as accumulated deltas in transient storage; and only the final deltas incur token transfers"),(0,o.kt)("p",null,"Delta accounting provides several key benefits:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"More efficient state management, especially for complex operations involving multiple steps."),(0,o.kt)("li",{parentName:"ol"},"Easier integration with hooks, allowing for custom logic to be applied to state changes."),(0,o.kt)("li",{parentName:"ol"},"Improved gas efficiency for many operations, as it reduces the number of storage writes.")),(0,o.kt)("p",null,"This system forms the foundation upon which other v4 features, such as hook fees and custom curves, are built. It allows for more complex pool behaviors while maintaining efficiency and flexibility."),(0,o.kt)("h2",{id:"hook-fees-inv4"},"Hook Fees in\xa0v4"),(0,o.kt)("p",null,"Hook fees are a feature in Uniswap v4 that allow hook developers to monetize their hooks or implement custom value distribution mechanisms. Unlike pool fees or dynamic fees, hook fees are entirely separate and are implemented through custom logic in the hook itself."),(0,o.kt)("p",null,"Key characteristics of hook fees in Uniswap v4:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Separate from Pool Fees")),(0,o.kt)("p",null,"Hook fees are distinct from the standard pool fees. They can be implemented alongside pool fees without interfering with the core fee structure."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Implemented in beforeSwap")),(0,o.kt)("p",null,"Hook fees are typically calculated and applied in the ",(0,o.kt)("inlineCode",{parentName:"p"},"beforeSwap")," function, allowing them to modify the swap parameters before the core swap logic is executed."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Use of BeforeSwapDelta")),(0,o.kt)("p",null,"Hook fees often utilize the ",(0,o.kt)("a",{parentName:"p",href:"/contracts/v4/reference/core/types/beforeswapdelta"},(0,o.kt)("inlineCode",{parentName:"a"},"BeforeSwapDelta"))," mechanism to adjust swap amounts and transfer deltas from the hook to the swap router, enabling precise control over how the fee affects the swap."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Flexible Implementation")),(0,o.kt)("p",null,"Developers have full control over how hook fees are calculated, collected, and distributed. This allows for complex fee structures tailored to specific use cases. In other words, developers can implement static fees, percentage-based fees, or even a fee that changes."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Potential Use Cases")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Monetization of hook development"),(0,o.kt)("li",{parentName:"ul"},"Implementation of withdrawal penalties (e.g., to penalize just-in-time liquidity provision)"),(0,o.kt)("li",{parentName:"ul"},"Custom value distribution for liquidity providers")),(0,o.kt)("p",null,"Keep reading because at the bottom we are providing a step by step guide on how to implement hook fees."),(0,o.kt)("h2",{id:"custom-curves-inv4"},"Custom Curves in\xa0v4"),(0,o.kt)("p",null,"Custom Curves in Uniswap v4 represent a big change in AMM design flexibility. Unlike ",(0,o.kt)("a",{parentName:"p",href:"/contracts/v2/concepts/protocol-overview/how-uniswap-works"},"Uniswap v2")," where the x*y=k formula was hardcoded, v4 allows developers to implement a wide variety of pricing models."),(0,o.kt)("p",null,"This is made possible through the hook system, particularly hooks that can interact with the swap process. Custom curves allow developers to eject the native concentrated liquidity pricing mechanism. These hooks can intercept swap requests, apply custom pricing logic, and return modified swap parameters. This enables the creation of pools with unique characteristics, such as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Stable asset pairs with minimal price impact"),(0,o.kt)("li",{parentName:"ul"},"Curves for special token types like rebasing tokens, RWAs, vault tokens")),(0,o.kt)("p",null,"For example, creating a custom curve for a stable swap pool would involve designing a pricing function that maintains tighter price ranges when assets are near parity. This could be achieved by implementing a curve that's flatter in the middle (where assets are at their expected 1:1 ratio) and steeper at the edges (to discourage large imbalances)."),(0,o.kt)("p",null,"This type of custom curve could significantly improve capital efficiency for stable asset pairs, reducing slippage for traders and potentially attracting more liquidity to the pool. It showcases how Uniswap v4's flexible architecture allows for tailored solutions to specific trading scenarios, opening up new possibilities in decentralized exchange design."),(0,o.kt)("h2",{id:"return-deltas-inv4"},"Return Deltas in\xa0v4"),(0,o.kt)("p",null,"Return deltas are a fundamental mechanism in Uniswap v4's custom accounting system. They allow for precise, programmatic adjustments to the outcomes of operations within the protocol."),(0,o.kt)("p",null,"Key aspects of return deltas:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Dual Adjustment"),": Return deltas simultaneously modify the balance changes (deltas) for both the hook contract and the swap router. This dual nature ensures that custom logic is accurately reflected across the entire system."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Credits and Debts Modification"),": By adjusting these deltas, return deltas effectively alter the credits and debts owed by the hook and the swap router. This allows for complex economic models to be implemented directly within the protocol."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Native Pricing Bypass"),": Return deltas enable hooks to implement custom curves that can completely bypass Uniswap's native pricing mechanism. This opens up possibilities for entirely new types of automated market makers within the Uniswap ecosystem."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Hook Fee Implementation"),": Through return deltas, hooks can implement their own fee structures, separate from the core protocol fees.")),(0,o.kt)("p",null,"In essence, return deltas allow for bespoke modification of an operation's result -- enabling features that were previously impossible in earlier versions of the protocol."),(0,o.kt)("h1",{id:"implementing-hook-fees-a-step-by-step-guide"},"Implementing Hook Fees: A Step-by-Step Guide"),(0,o.kt)("p",null,"In this guide, we'll walk through the process of implementing a custom fee hook in Uniswap v4. We'll not only show you how to write the code but also explain what's happening under the hood at each step."),(0,o.kt)("h2",{id:"step-1-setting-up-the-hook"},"Step 1: Setting Up the Hook"),(0,o.kt)("p",null,"First, let's create our basic hook structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {BaseHook} from "v4-periphery/src/BaseHook.sol";\nimport {Hooks} from "v4-core/src/libraries/Hooks.sol";\nimport {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";\nimport {PoolKey} from "v4-core/src/types/PoolKey.sol";\nimport {Currency} from "v4-core/src/types/Currency.sol";\nimport {BeforeSwapDelta, toBeforeSwapDelta} from "v4-core/src/types/BeforeSwapDelta.sol";\n\ncontract HookFeeExample is BaseHook {\n    uint256 public constant HOOK_FEE_PERCENTAGE = 10;// 0.01% fee\n    uint256 public constant FEE_DENOMINATOR = 100000;\n\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterAddLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: true,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n\n')),(0,o.kt)("p",null,"Here, we're setting up our hook with a constant fee of 0.01% and enabling the ",(0,o.kt)("inlineCode",{parentName:"p"},"beforeSwap")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"beforeSwapReturnDelta")," permissions."),(0,o.kt)("h2",{id:"step-2-implementing-the-beforeswap-function"},"Step 2: Implementing the beforeSwap Function"),(0,o.kt)("p",null,"Now, let's implement our ",(0,o.kt)("inlineCode",{parentName:"p"},"beforeSwap")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function _beforeSwap(\n    address,\n    PoolKey calldata key,\n    IPoolManager.SwapParams calldata params,\n    bytes calldata\n) internal override returns (bytes4, BeforeSwapDelta, uint24) {\n    // Implementation details will be explained in the following sub-steps\n}\n\n")),(0,o.kt)("h3",{id:"step-21-calculate-the-swap-amount-and-fee"},"Step 2.1: Calculate the swap amount and fee"),(0,o.kt)("p",null,"We determine the absolute swap amount and calculate our fee based on it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 swapAmount = params.amountSpecified < 0\n    ? uint256(-params.amountSpecified)\n    : uint256(params.amountSpecified);\nuint256 feeAmount = (swapAmount * HOOK_FEE_PERCENTAGE) / FEE_DENOMINATOR;\n\n")),(0,o.kt)("h3",{id:"step-22-collect-the-fee"},"Step 2.2: Collect the fee"),(0,o.kt)("p",null,"We use ",(0,o.kt)("inlineCode",{parentName:"p"},"poolManager.take")," to collect the fee. This creates a debt for our hook in the specified currency."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"Currency feeCurrency = params.zeroForOne ? key.currency0 : key.currency1;\npoolManager.take(feeCurrency, address(this), feeAmount);\n\n")),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("blockquote",{parentName:"div"},(0,o.kt)("p",{parentName:"blockquote"},"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"poolManager.take()")," requires an ERC20 balance on the PoolManager, i.e. via other liquidity pools. If the ",(0,o.kt)("inlineCode",{parentName:"p"},".take()")," amount exceeds the ERC20 balance, the code will revert. As a workaround, use either:"),(0,o.kt)("ol",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"poolManager.mint()")," to obtain ERC6909, which are also more gas efficient"),(0,o.kt)("li",{parentName:"ol"},"A custom swap router, where input tokens are transferred to PoolManager before the router calls ",(0,o.kt)("inlineCode",{parentName:"li"},"poolManager.swap()")))))),(0,o.kt)("h3",{id:"step-23-create-the-beforeswapdelta"},"Step 2.3: Create the BeforeSwapDelta"),(0,o.kt)("p",null,"This is where the magic happens. We create a ",(0,o.kt)("inlineCode",{parentName:"p"},"BeforeSwapDelta")," that represents our fee. The ",(0,o.kt)("inlineCode",{parentName:"p"},"toBeforeSwapDelta")," function takes two parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The specified delta: This is our fee amount. It's positive because we're adding it to the hook's balance."),(0,o.kt)("li",{parentName:"ul"},"The unspecified delta: We set this to 0 as we're not affecting the other currency.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"BeforeSwapDelta returnDelta = toBeforeSwapDelta(\n    int128(int256(feeAmount)), // Specified delta (fee amount)\n    0 // Unspecified delta (no change)\n);\n\n")),(0,o.kt)("h3",{id:"step-24-return-values"},"Step 2.4: Return values"),(0,o.kt)("p",null,"We return the function selector, our ",(0,o.kt)("inlineCode",{parentName:"p"},"returnDelta"),", and 0 for the fee override."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"return (BaseHook.beforeSwap.selector, returnDelta, 0);\n")),(0,o.kt)("h2",{id:"step-3-understanding-the-beforeswapdelta-mechanism"},"Step 3: Understanding the BeforeSwapDelta Mechanism"),(0,o.kt)("p",null,"Now, let's dive deeper into how the ",(0,o.kt)("inlineCode",{parentName:"p"},"BeforeSwapDelta")," works and how it affects the overall swap process."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Initial State"),":\nLet's say a user wants to swap 100 USDC for USDT",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre"},"- Hook's delta: (0, 0)\n- User's swap request: -100 USDC (negative because they're selling)\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"After Hook Execution"),":\nOur hook has taken a 1 USDC fee (assuming 1% for simplicity):",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre"},"- Hook's delta: (-1 USDC, 0) // The hook now owes 1 USDC to the pool\n- BeforeSwapDelta returned: (1 USDC, 0) // This will be added to the hook's delta and subtracted from the swap delta\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"PoolManager Processing"),":\nThe PoolManager applies our ",(0,o.kt)("inlineCode",{parentName:"li"},"BeforeSwapDelta"),"\nThe pool then swaps 99 USDC for, let's say, 98 USDT.\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"amountToSwap = params.amountSpecified + hookDelta.getSpecifiedDelta();\n-99 USDC = -100 USDC + 1 USDC\n")),(0,o.kt)("ol",{start:4},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Delta Resolution"),":\nThe PoolManager then resolves the deltas:\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Hook's new delta\nnewHookDelta = oldHookDelta + returnDelta\n(0, 0) = (-1 USDC, 0) + (1 USDC, 0)\n\n// Swap delta for router\nswapDelta = (-99 USDC, 98 USDT) - (1 USDC, 0)\n            = (-100 USDC, 98 USDT)\n")),(0,o.kt)("ol",{start:5},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Final Outcome"),":",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},'The hook\'s debt is cleared: It took 1 USDC as a fee, but "returned" it to the swap process.'),(0,o.kt)("li",{parentName:"ul"},"The router (on behalf of the user) must pay 100 USDC (original amount including fee) and receives 98 USDT.")))),(0,o.kt)("p",null,"This process demonstrates how ",(0,o.kt)("inlineCode",{parentName:"p"},"BeforeSwapDelta"),' effectively "transfers" the hook\'s outstanding delta to the swap router, ensuring that the user pays the fee while the hook collects it, all within a single atomic transaction.'),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"By implementing hook fees this way, we've leveraged Uniswap v4's delta accounting system to create a seamless fee collection mechanism. This approach allows for complex fee structures and behaviors without disrupting the core swap process or requiring separate fee transfers."))}u.isMDXComponent=!0},3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(a),m=o,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return a?n.createElement(h,i(i({ref:t},c),{},{components:a})):n.createElement(h,i({ref:t},c))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"}}]);