"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[8457],{94557:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=n(83117),o=(n(67294),n(3905));const i={id:"flash-callback",title:"The Flash Callback",sidebar_position:3},r=void 0,s={unversionedId:"contracts/v3/guides/flash-integrations/flash-callback",id:"contracts/v3/guides/flash-integrations/flash-callback",title:"The Flash Callback",description:"Setting Up The Callback",source:"@site/docs/contracts/v3/guides/flash-integrations/flash-callback.md",sourceDirName:"contracts/v3/guides/flash-integrations",slug:"/contracts/v3/guides/flash-integrations/flash-callback",permalink:"/docs/contracts/v3/guides/flash-integrations/flash-callback",editUrl:"https://github.com/hoffms/docs/tree/main/docs/contracts/v3/guides/flash-integrations/flash-callback.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"flash-callback",title:"The Flash Callback",sidebar_position:3},sidebar:"contractsSidebar",previous:{title:"Calling Flash",permalink:"/docs/contracts/v3/guides/flash-integrations/calling-flash"},next:{title:"The Final Contract",permalink:"/docs/contracts/v3/guides/flash-integrations/final-contract"}},l={},d=[{value:"Setting Up The Callback",id:"setting-up-the-callback",level:2},{value:"Initiating A Swap",id:"initiating-a-swap",level:2},{value:"Paying back the pool",id:"paying-back-the-pool",level:2}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"setting-up-the-callback"},"Setting Up The Callback"),(0,o.kt)("p",null,"Here we will override the flash callback with our custom logic to execute the desired swaps and pay the profits to the original ",(0,o.kt)("inlineCode",{parentName:"p"},"msg.sender"),"."),(0,o.kt)("p",null,"Declare the ",(0,o.kt)("inlineCode",{parentName:"p"},"uniswapV3FlashCallback")," function and override it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    function uniswapV3FlashCallback(\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external override {\n")),(0,o.kt)("p",null,"Declare a variable ",(0,o.kt)("inlineCode",{parentName:"p"},"decoded")," in memory and assign it to the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.7.6/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions"},(0,o.kt)("strong",{parentName:"a"},"decoded data"))," previously encoded into the calldata."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));\n")),(0,o.kt)("p",null,"Each callback must be validated to verify that the call originated from a genuine V3 pool. Otherwise, the pool contract would be vulnerable to attack via an EOA manipulating the callback function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"        CallbackValidation.verifyCallback(factory, decoded.poolKey);\n")),(0,o.kt)("p",null,"Assign local variables of type ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," as ",(0,o.kt)("inlineCode",{parentName:"p"},"token0")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"token1")," to approve the router to interact with the tokens from the flash."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"        address token0 = decoded.poolKey.token0;\n        address token1 = decoded.poolKey.token1;\n\n        TransferHelper.safeApprove(token0, address(swapRouter), decoded.amount0);\n        TransferHelper.safeApprove(token1, address(swapRouter), decoded.amount1);\n")),(0,o.kt)("p",null,"Code in a minimum amount out for both of the upcoming swaps, such that the following swaps will revert if we do not receive a profitable trade."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"        uint256 amount1Min = LowGasSafeMath.add(decoded.amount1, fee1);\n        uint256 amount0Min = LowGasSafeMath.add(decoded.amount0, fee0);\n")),(0,o.kt)("h2",{id:"initiating-a-swap"},"Initiating A Swap"),(0,o.kt)("p",null,"Call the first of two swaps, calling ",(0,o.kt)("inlineCode",{parentName:"p"},"exactInputSingle")," on the ",(0,o.kt)("a",{parentName:"p",href:"/docs/contracts/v3/reference/periphery/interfaces/ISwapRouter"},(0,o.kt)("strong",{parentName:"a"},"router interface"))," contract. In this call, we are using the previously declared ",(0,o.kt)("inlineCode",{parentName:"p"},"amount0In")," as the minimum amount out, and assigning the returned balance of the swap to ",(0,o.kt)("inlineCode",{parentName:"p"},"amountOut0"),"."),(0,o.kt)("p",null,"Most of These function arguments have already been discussed, except for two new introductions:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"sqrtPriceLimitX96"),": This value limits the price that the swap can change the pool to. Remember that price is always expressed in the pool contract as ",(0,o.kt)("inlineCode",{parentName:"p"},"token1")," in terms of ",(0,o.kt)("inlineCode",{parentName:"p"},"token0"),". This is useful for circumstances where the user wants to swap ",(0,o.kt)("em",{parentName:"p"},"up until")," a specific price. For this example, we will set it to 0, which makes to make the argument inactive."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"deadline"),": this is the timestamp after which the transaction will revert, to protect the transaction from dramatic changes in price environment that can happen if the transaction is pending for too long. For this example, we will set it far in the future for the sake of simplicity."),(0,o.kt)("p",null,"The first swap takes the ",(0,o.kt)("inlineCode",{parentName:"p"},"amount1")," that we withdrew from the original pool, and passes that amount as the input amount for a single swap that trades a fixed input for the maximum amount of possible output. It calls this function on the pool determined by our previous token pair, but with the next fee tier in our list of three."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 amountOut0 =\n            swapRouter.exactInputSingle(\n                ISwapRouter.ExactInputSingleParams({\n                    tokenIn: token1,\n                    tokenOut: token0,\n                    fee: decoded.poolFee2,\n                    recipient: address(this),\n                    deadline: block.timestamp + 200,\n                    amountIn: decoded.amount1,\n                    amountOutMinimum: amount0Min,\n                    sqrtPriceLimitX96: 0\n                })\n            );\n")),(0,o.kt)("p",null,"Populate the second of two swaps, this time with the last fee tier and with the ",(0,o.kt)("inlineCode",{parentName:"p"},"amount0")," that we withdrew from the original pool."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 amountOut1 =\n            swapRouter.exactInputSingle(\n                ISwapRouter.ExactInputSingleParams({\n                    tokenIn: token0,\n                    tokenOut: token1,\n                    fee: decoded.poolFee3,\n                    recipient: address(this),\n                    deadline: block.timestamp + 200,\n                    amountIn: decoded.amount0,\n                    amountOutMinimum: amount1Min,\n                    sqrtPriceLimitX96: 0\n                })\n            );\n")),(0,o.kt)("h2",{id:"paying-back-the-pool"},"Paying back the pool"),(0,o.kt)("p",null,"To pay the original pool back for the flash transaction, first calculate the balance due to it and approve the router to transfer the tokens in our contract back to the pool."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 amount0Owed = LowGasSafeMath.add(decoded.amount0, fee0);\nuint256 amount1Owed = LowGasSafeMath.add(decoded.amount1, fee1);\n\nTransferHelper.safeApprove(token0, address(this), amount0Owed);\nTransferHelper.safeApprove(token1, address(this), amount1Owed);\n")),(0,o.kt)("p",null,"If there is any balance due to the token, use simple logic to call ",(0,o.kt)("a",{parentName:"p",href:"/docs/contracts/v3/reference/periphery/base/PeripheryPayments#pay"},"pay"),". Remember that the callback function is being called by the pool itself, which is why we can call ",(0,o.kt)("inlineCode",{parentName:"p"},"pay")," despite the function being marked ",(0,o.kt)("inlineCode",{parentName:"p"},"internal"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"if (amount0Owed > 0) pay(token0, address(this), msg.sender, amount0Owed);\nif (amount1Owed > 0) pay(token1, address(this), msg.sender, amount1Owed);\n")),(0,o.kt)("p",null,"Send the profits to the ",(0,o.kt)("inlineCode",{parentName:"p"},"payer"),": the original ",(0,o.kt)("inlineCode",{parentName:"p"},"msg.sender")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"initFlash")," function, which executed the flash transaction and in turn triggered the callback."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    if (amountOut0 > amount0Owed) {\n            uint256 profit0 = LowGasSafeMath.sub(amountOut0, amount0Owed);\n\n            TransferHelper.safeApprove(token0, address(this), profit0);\n            pay(token0, address(this), decoded.payer, profit0);\n        }\n\n    if (amountOut1 > amount1Owed) {\n            uint256 profit1 = LowGasSafeMath.sub(amountOut1, amount1Owed);\n            TransferHelper.safeApprove(token0, address(this), profit1);\n            pay(token1, address(this), decoded.payer, profit1);\n        }\n")),(0,o.kt)("h1",{id:"the-full-function"},"The full function"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    function uniswapV3FlashCallback(\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external override {\n        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));\n        CallbackValidation.verifyCallback(factory, decoded.poolKey);\n\n        address token0 = decoded.poolKey.token0;\n        address token1 = decoded.poolKey.token1;\n\n        TransferHelper.safeApprove(token0, address(swapRouter), decoded.amount0);\n        TransferHelper.safeApprove(token1, address(swapRouter), decoded.amount1);\n\n        // profitable check\n        // exactInputSingle will fail if this amount not met\n        uint256 amount1Min = LowGasSafeMath.add(decoded.amount1, fee1);\n        uint256 amount0Min = LowGasSafeMath.add(decoded.amount0, fee0);\n\n        // call exactInputSingle for swapping token1 for token0 in pool w/fee2\n        uint256 amountOut0 =\n            swapRouter.exactInputSingle(\n                ISwapRouter.ExactInputSingleParams({\n                    tokenIn: token1,\n                    tokenOut: token0,\n                    fee: decoded.poolFee2,\n                    recipient: address(this),\n                    deadline: block.timestamp + 200,\n                    amountIn: decoded.amount1,\n                    amountOutMinimum: amount0Min,\n                    sqrtPriceLimitX96: 0\n                })\n            );\n\n        // call exactInputSingle for swapping token0 for token 1 in pool w/fee3\n        uint256 amountOut1 =\n            swapRouter.exactInputSingle(\n                ISwapRouter.ExactInputSingleParams({\n                    tokenIn: token0,\n                    tokenOut: token1,\n                    fee: decoded.poolFee3,\n                    recipient: address(this),\n                    deadline: block.timestamp + 200,\n                    amountIn: decoded.amount0,\n                    amountOutMinimum: amount1Min,\n                    sqrtPriceLimitX96: 0\n                })\n            );\n\n        // end up with amountOut0 of token0 from first swap and amountOut1 of token1 from second swap\n        uint256 amount0Owed = LowGasSafeMath.add(decoded.amount0, fee0);\n        uint256 amount1Owed = LowGasSafeMath.add(decoded.amount1, fee1);\n\n        TransferHelper.safeApprove(token0, address(this), amount0Owed);\n        TransferHelper.safeApprove(token1, address(this), amount1Owed);\n\n        if (amount0Owed > 0) pay(token0, address(this), msg.sender, amount0Owed);\n        if (amount1Owed > 0) pay(token1, address(this), msg.sender, amount1Owed);\n\n        // if profitable pay profits to payer\n        if (amountOut0 > amount0Owed) {\n            uint256 profit0 = LowGasSafeMath.sub(amountOut0, amount0Owed);\n\n            TransferHelper.safeApprove(token0, address(this), profit0);\n            pay(token0, address(this), decoded.payer, profit0);\n        }\n        if (amountOut1 > amount1Owed) {\n            uint256 profit1 = LowGasSafeMath.sub(amountOut1, amount1Owed);\n            TransferHelper.safeApprove(token0, address(this), profit1);\n            pay(token1, address(this), decoded.payer, profit1);\n        }\n    }\n")))}c.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=d(n),m=o,f=u["".concat(l,".").concat(m)]||u[m]||c[m]||i;return n?a.createElement(f,r(r({ref:t},p),{},{components:n})):a.createElement(f,r({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);