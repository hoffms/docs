"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[761],{75727:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(83117),o=(n(67294),n(3905));const r={title:"Swap routing"},i="Introduction to Universal Router for Uniswap v4 Swaps",s={unversionedId:"contracts/v4/guides/swap-routing",id:"contracts/v4/guides/swap-routing",title:"Swap routing",description:"Uniswap v4 introduces a new architecture where all pools are managed by a single PoolManager contract. While the underlying architecture uses a callback system for swaps, developers can still use the Universal Router to execute swaps on v4 pools, just as you would for v2 or v3.",source:"@site/docs/contracts/v4/guides/09-swap-routing.mdx",sourceDirName:"contracts/v4/guides",slug:"/contracts/v4/guides/swap-routing",permalink:"/docs/contracts/v4/guides/swap-routing",editUrl:"https://github.com/hoffms/docs/tree/main/docs/contracts/v4/guides/09-swap-routing.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"Swap routing"},sidebar:"contractsSidebar",previous:{title:"Custom Accounting",permalink:"/docs/contracts/v4/guides/custom-accounting"},next:{title:"ERC-6909",permalink:"/docs/contracts/v4/guides/ERC-6909"}},l={},p=[{value:"What is the Universal Router?",id:"what-is-the-universal-router",level:2},{value:"UniversalRouter command encoding",id:"universalrouter-command-encoding",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Step 1: Set Up the Project",id:"step-1-set-up-the-project",level:2},{value:"Step 2: Implement Token Approval with Permit2",id:"step-2-implement-token-approval-with-permit2",level:2},{value:"Step 3: Implementing a Swap Function",id:"step-3-implementing-a-swap-function",level:2},{value:"3.1: Function Signature",id:"31-function-signature",level:3},{value:"3.2: Encoding the Swap Command",id:"32-encoding-the-swap-command",level:3},{value:"3.3: Action Encoding",id:"33-action-encoding",level:3},{value:"3.4: Preparing the Swap Inputs",id:"34-preparing-the-swap-inputs",level:3},{value:"3.5: Executing the Swap",id:"35-executing-the-swap",level:3},{value:"3.6: (Optional) Verifying the Swap Output",id:"36-optional-verifying-the-swap-output",level:3},{value:"3.7: Returning the Result",id:"37-returning-the-result",level:3}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction-to-universal-router-for-uniswap-v4-swaps"},"Introduction to Universal Router for Uniswap v4 Swaps"),(0,o.kt)("p",null,"Uniswap v4 introduces a new architecture where all pools are managed by a single PoolManager contract. While the underlying architecture uses a callback system for swaps, developers can still use the Universal Router to execute swaps on v4 pools, just as you would for v2 or v3."),(0,o.kt)("h2",{id:"what-is-the-universal-router"},"What is the Universal Router?"),(0,o.kt)("p",null,"The Universal Router is a flexible, gas-efficient contract designed to execute complex swap operations across various protocols, including Uniswap v4. It serves as an intermediary between users and the Uniswap v4 ",(0,o.kt)("inlineCode",{parentName:"p"},"PoolManager"),", handling the intricacies of swap execution."),(0,o.kt)("p",null,"While it\u2019s technically possible to interact directly with the PoolManager contract for swaps, this approach is generally not recommended due to its complexity and potential inefficiencies. The Universal Router is designed to abstract away these complexities, providing a more straightforward and efficient method for executing swaps on v4 pools."),(0,o.kt)("h2",{id:"universalrouter-command-encoding"},"UniversalRouter command encoding"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/contracts/universal-router/overview"},"Universal Router")," uses a unique encoding system for its commands and inputs, which is crucial to understand when configuring it for v4 swaps."),(0,o.kt)("p",null,"When calling ",(0,o.kt)("inlineCode",{parentName:"p"},"UniversalRouter.execute()"),", you provide two main parameters:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"bytes commands"),": A string of bytes where each byte represents a single command to be executed."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"bytes[] inputs"),": An array of byte strings, each containing the encoded parameters for its corresponding command.")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"commands[i]")," byte corresponds to the ",(0,o.kt)("inlineCode",{parentName:"p"},"inputs[i]")," parameters, allowing for a series of operations to be defined and executed in sequence."),(0,o.kt)("p",null,"Each command is encoded as a single byte (",(0,o.kt)("inlineCode",{parentName:"p"},"bytes1"),") with a specific structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"0 1 2 3 4 5 6 7\n\u250c\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502f\u2502r|  command  \u2502\n\u2514\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The first bit (",(0,o.kt)("inlineCode",{parentName:"li"},"f"),") is a flag that determines whether the command is allowed to revert without causing the entire transaction to fail. This enables partial execution of complex transactions."),(0,o.kt)("li",{parentName:"ul"},"The second bit (",(0,o.kt)("inlineCode",{parentName:"li"},"r"),") is reserved for future use, providing flexibility for potential upgrades."),(0,o.kt)("li",{parentName:"ul"},"The remaining 6 bits represent the specific command to be executed.")),(0,o.kt)("h1",{id:"configuring-universal-router-for-uniswap-v4-swaps"},"Configuring Universal Router for Uniswap v4 Swaps"),(0,o.kt)("h2",{id:"use-cases"},"Use Cases"),(0,o.kt)("p",null,"Developers might need to configure the Universal Router for swapping on Uniswap v4 pools in several scenarios:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Building a DEX aggregator"),": If you\u2019re creating a platform that finds the best rates across multiple DEXes, you\u2019ll want to include Uniswap v4 pools in your options."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Developing a trading bot"),": Automated trading strategies often require the ability to execute swaps programmatically across various pools and versions."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Creating a Dapp"),": Many DeFi applications (lending platforms, yield aggregators, etc.) need to perform token swaps as part of their core functionality.")),(0,o.kt)("p",null,"This guide focuses on how to interact with Universal Router from an on-chain contract."),(0,o.kt)("h2",{id:"step-1-set-up-the-project"},"Step 1: Set Up the Project"),(0,o.kt)("p",null,"First, we need to set up our project and install the necessary dependencies."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"forge install uniswap/v4-core\nforge install uniswap/v4-periphery\nforge install uniswap/permit2\nforge install uniswap/universal-router\nforge install OpenZeppelin/openzeppelin-contracts\n")),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"remappings.txt"),", add the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"@uniswap/v4-core/=lib/v4-core/\n@uniswap/v4-periphery/=lib/v4-periphery/\n@uniswap/permit2/=lib/permit2/\n@uniswap/universal-router/=lib/universal-router/\n@openzeppelin/contracts/=lib/openzeppelin-contracts/\n[...]\n")),(0,o.kt)("p",null,"We\u2019ll create a new Solidity contract for our example."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport { UniversalRouter } from "@uniswap/universal-router/contracts/UniversalRouter.sol";\nimport { Commands } from "@uniswap/universal-router/contracts/libraries/Commands.sol";\nimport { IPoolManager } from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";\nimport { IV4Router } from "@uniswap/v4-periphery/src/interfaces/IV4Router.sol";\nimport { Actions } from "@uniswap/v4-periphery/src/libraries/Actions.sol";\nimport { IPermit2 } from "@uniswap/permit2/src/interfaces/IPermit2.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\ncontract Example {\n    using StateLibrary for IPoolManager;\n\n    UniversalRouter public immutable router;\n    IPoolManager public immutable poolManager;\n    IPermit2 public immutable permit2;\n\n    constructor(address _router, address _poolManager, address _permit2) {\n        router = UniversalRouter(_router);\n        poolManager = IPoolManager(_poolManager);\n        permit2 = IPermit2(_permit2);\n    }\n\n    // We\'ll add more functions here\n}\n')),(0,o.kt)("p",null,"In this step, we\u2019re importing the necessary contracts and interfaces:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"UniversalRouter"),": This will be our main interface for executing swaps. It provides a flexible way to interact with various Uniswap versions and other protocols."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Commands"),": This library contains the command definitions used by the UniversalRouter."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"IPoolManager"),": This interface is needed for interacting with Uniswap v4 pools. While we don't directly use it in our simple example, it's often necessary for more complex interactions with v4 pools."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"IPermit2"),": This interface allows us to interact with the Permit2 contract, which provides enhanced token approval functionality."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"StateLibrary"),": This provides optimized functions for interacting with the PoolManager\u2019s state. By using ",(0,o.kt)("inlineCode",{parentName:"li"},"StateLibrary"),", we can more efficiently read and manipulate pool states, which is crucial for many operations in Uniswap v4.")),(0,o.kt)("h2",{id:"step-2-implement-token-approval-with-permit2"},"Step 2: Implement Token Approval with Permit2"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"UniversalRouter")," integrates with ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/permit2"},"Permit2"),", to enable users to have more safety, flexibility, and control over their ERC20 token approvals."),(0,o.kt)("p",null,"Before we can execute swaps, we need to ensure our contract can transfer tokens. We\u2019ll implement a function to approve the Universal Router to spend tokens on behalf of our contract."),(0,o.kt)("p",null,"Here, for testing purposes, we set up our contract to use Permit2 with the UniversalRouter:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function approveTokenWithPermit2(\n    address token,\n    uint160 amount,\n    uint48 expiration\n) external {\n    IERC20(token).approve(address(permit2), type(uint256).max);\n    permit2.approve(token, address(router), amount, expiration);\n}\n")),(0,o.kt)("p",null,"This function first approves Permit2 to spend the token, then uses Permit2 to approve the UniversalRouter with a specific amount and expiration time."),(0,o.kt)("h2",{id:"step-3-implementing-a-swap-function"},"Step 3: Implementing a Swap Function"),(0,o.kt)("h3",{id:"31-function-signature"},"3.1: Function Signature"),(0,o.kt)("p",null,"First, let\u2019s define our function signature:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function swapExactInputSingle(\n    PoolKey calldata key, // PoolKey struct that identifies the v4 pool\n    uint128 amountIn, // Exact amount of tokens to swap\n    uint128 minAmountOut, // Minimum amount of output tokens expected\n    uint256 deadline // Timestamp after which the transaction will revert\n) external returns (uint256 amountOut) {\n    // Implementation will follow\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Important note:")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The deadline parameter allows users to specify when their transaction should expire. This protects against unfavorable execution due to network delays or MEV attacks."),(0,o.kt)("li",{parentName:"ol"},"When swapping tokens involving native ETH, we use ",(0,o.kt)("inlineCode",{parentName:"li"},"Currency.wrap(address(0))")," to represent ETH in the ",(0,o.kt)("inlineCode",{parentName:"li"},"PoolKey")," struct.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"struct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically.\n    ///         For native ETH, Currency currency0 = Currency.wrap(address(0));\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n")),(0,o.kt)("h3",{id:"32-encoding-the-swap-command"},"3.2: Encoding the Swap Command"),(0,o.kt)("p",null,"When encoding a swap command for the Universal Router, we need to choose between two types of swaps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Exact Input Swaps:")),(0,o.kt)("p",null,"Use this swap-type when you know the exact amount of tokens you want to swap in, and you're willing to accept any amount of output tokens above your minimum. This is common when you want to sell a specific amount of tokens."),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Exact Output Swaps:")),(0,o.kt)("p",null,"Use this swap-type when you need a specific amount of output tokens, and you're willing to spend up to a maximum amount of input tokens. This is useful when you need to acquire a precise amount of tokens, for example, to repay a loan or meet a specific requirement."),(0,o.kt)("p",null,"Next, we encode the swap command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));\n")),(0,o.kt)("p",null,"Here, we're using ",(0,o.kt)("inlineCode",{parentName:"p"},"V4_SWAP"),", which tells the Universal Router that we want to perform a swap on a Uniswap v4 pool. The specific type of swap (exact input or exact output) will be determined by the V4Router actions we encode later. As we saw earlier, we encode this as a single byte, which is how the Universal Router expects to receive commands."),(0,o.kt)("p",null,"Check the complete list of ",(0,o.kt)("a",{parentName:"p",href:"https://docs.uniswap.org/contracts/universal-router/technical-reference#command"},"commands"),"."),(0,o.kt)("h3",{id:"33-action-encoding"},"3.3: Action Encoding"),(0,o.kt)("p",null,"Now, let\u2019s encode the actions for the swap:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Encode V4Router actions\nbytes memory actions = abi.encodePacked(\n    uint8(Actions.SWAP_EXACT_IN_SINGLE),\n    uint8(Actions.SETTLE_ALL),\n    uint8(Actions.TAKE_ALL)\n);\n")),(0,o.kt)("p",null,"These actions define the sequence of operations that will be performed in our v4 swap:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"SWAP_EXACT_IN_SINGLE"),": This action specifies that we want to perform an exact input swap using a single pool."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"SETTLE_ALL"),": This action ensures all input tokens involved in the swap are properly paid. This is part of v4's settlement pattern for handling token transfers."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"TAKE_ALL"),": This final action collects all output tokens after the swap is complete.")),(0,o.kt)("p",null,"The sequence of these actions is important as they define the complete flow of our swap operation from start to finish."),(0,o.kt)("h3",{id:"34-preparing-the-swap-inputs"},"3.4: Preparing the Swap Inputs"),(0,o.kt)("p",null,"For our v4 swap, we need to prepare three parameters that correspond to our encoded actions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes[] memory params = new bytes[](3);\n\n// First parameter: swap configuration\nparams[0] = abi.encode(\n    IV4Router.ExactInputSingleParams({\n        poolKey: key,\n        zeroForOne: true,            // true if we're swapping token0 for token1\n        amountIn: amountIn,          // amount of tokens we're swapping\n        amountOutMinimum: minAmountOut, // minimum amount we expect to receive\n        hookData: bytes(\"\")             // no hook data needed\n    })\n);\n\n// Second parameter: specify input tokens for the swap\n// encode SETTLE_ALL parameters\nparams[1] = abi.encode(key.currency0, amountIn);\n\n// Third parameter: specify output tokens from the swap\nparams[2] = abi.encode(key.currency1, minAmountOut);\n")),(0,o.kt)("p",null,"Each encoded parameter serves a specific purpose:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The first parameter configures how the swap should be executed, defining the pool, amounts, and other swap-specific details"),(0,o.kt)("li",{parentName:"ol"},"The second parameter defines what tokens we're putting into the swap"),(0,o.kt)("li",{parentName:"ol"},"The third parameter defines what tokens we expect to receive from the swap")),(0,o.kt)("p",null,"These parameters work in conjunction with the actions we encoded earlier (",(0,o.kt)("inlineCode",{parentName:"p"},"SWAP_EXACT_IN_SINGLE"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"SETTLE_ALL"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"TAKE_ALL"),") to execute our swap operation."),(0,o.kt)("h3",{id:"35-executing-the-swap"},"3.5: Executing the Swap"),(0,o.kt)("p",null,"Now we can execute the swap using the Universal Router. It's crucial to allow users to specify their own deadline for transaction execution:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Combine actions and params into inputs\ninputs[0] = abi.encode(actions, params);\n\n// Execute the swap with deadline protection\nrouter.execute(commands, inputs, deadline);\n")),(0,o.kt)("p",null,"This prepares and executes the swap based on our encoded commands, actions, and parameters."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note"),":  Never use block.timestamp or type(uint256).max as the deadline parameter.")),(0,o.kt)("h3",{id:"36-optional-verifying-the-swap-output"},"3.6: (Optional) Verifying the Swap Output"),(0,o.kt)("p",null,"After the swap, we need to verify that we received at least the minimum amount of tokens we specified:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'amountOut = IERC20(key.currency1).balanceOf(address(this));\nrequire(amountOut >= minAmountOut, "Insufficient output amount");\n')),(0,o.kt)("h3",{id:"37-returning-the-result"},"3.7: Returning the Result"),(0,o.kt)("p",null,"Finally, we return the amount of tokens we received:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"return amountOut;\n")),(0,o.kt)("p",null,"This allows the caller of the function to know exactly how many tokens were received in the swap."),(0,o.kt)("p",null,"Here's the complete swap function that combines all the steps we've covered:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'function swapExactInputSingle(\n    PoolKey calldata key,\n    uint128 amountIn,\n    uint128 minAmountOut,\n    uint256 deadline \n) external returns (uint256 amountOut) {\n// Encode the Universal Router command\n    bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));\n    bytes[] memory inputs = new bytes[](1);\n\n// Encode V4Router actions\n    bytes memory actions = abi.encodePacked(\n        uint8(Actions.SWAP_EXACT_IN_SINGLE),\n        uint8(Actions.SETTLE_ALL),\n        uint8(Actions.TAKE_ALL)\n    );\n\n// Prepare parameters for each action\n    bytes[] memory params = new bytes[](3);\n    params[0] = abi.encode(\n        IV4Router.ExactInputSingleParams({\n            poolKey: key,\n            zeroForOne: true,\n            amountIn: amountIn,\n            amountOutMinimum: minAmountOut,\n            hookData: bytes("")\n        })\n    );\n    params[1] = abi.encode(key.currency0, amountIn);\n    params[2] = abi.encode(key.currency1, minAmountOut);\n\n// Combine actions and params into inputs\n    inputs[0] = abi.encode(actions, params);\n\n// Execute the swap\n    router.execute(commands, inputs, deadline);\n\n// Verify and return the output amount\n    amountOut = IERC20(key.currency1).balanceOf(address(this));\n    require(amountOut >= minAmountOut, "Insufficient output amount");\n    return amountOut;\n}\n')))}c.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=o,h=m["".concat(l,".").concat(d)]||m[d]||c[d]||r;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);