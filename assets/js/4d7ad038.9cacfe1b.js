"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[79818],{60773:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>k,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(83117),i=(n(67294),n(3905));const r={sidebar_label:"Uniswap V3 Staker Design",sidebar_position:1},l="Uniswap V3 Staker Design",s={unversionedId:"contracts/v3/reference/periphery/staker/Design",id:"contracts/v3/reference/periphery/staker/Design",title:"Uniswap V3 Staker Design",description:"The liquidity mining staker design is comprised of one canonical position staking contract, Staker. The technical reference for this contract is here and the source code is here.",source:"@site/docs/contracts/v3/reference/periphery/staker/Design.md",sourceDirName:"contracts/v3/reference/periphery/staker",slug:"/contracts/v3/reference/periphery/staker/Design",permalink:"/docs/contracts/v3/reference/periphery/staker/Design",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/v3/reference/periphery/staker/Design.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_label:"Uniswap V3 Staker Design",sidebar_position:1},sidebar:"contractsSidebar",previous:{title:"WeightedOracleLibrary",permalink:"/docs/contracts/v3/reference/periphery/libraries/WeightedOracleLibrary"},next:{title:"Uniswap V3 Staker Contract",permalink:"/docs/contracts/v3/reference/periphery/staker/UniswapV3Staker"}},o={},d=[{value:"Data Structures",id:"data-structures",level:2},{value:"Incentives",id:"incentives",level:2},{value:"<code>createIncentive(CreateIncentiveParams memory params)</code>",id:"createincentivecreateincentiveparams-memory-params",level:3},{value:"<code>endIncentive(EndIncentiveParams memory params)</code>",id:"endincentiveendincentiveparams-memory-params",level:3},{value:"Deposit/Withdraw Token",id:"depositwithdraw-token",level:2},{value:"<code>onERC721Received(address, address from, uint256 tokenId, bytes calldata data)</code>",id:"onerc721receivedaddress-address-from-uint256-tokenid-bytes-calldata-data",level:3},{value:"<code>withdrawToken(uint256 tokenId, address to, bytes memory data)</code>",id:"withdrawtokenuint256-tokenid-address-to-bytes-memory-data",level:3},{value:"Stake/Unstake/Rewards",id:"stakeunstakerewards",level:2},{value:"<code>stakeToken</code>",id:"staketoken",level:3},{value:"<code>claimReward</code>",id:"claimreward",level:3},{value:"<code>unstakeToken</code>",id:"unstaketoken",level:3},{value:"<code>getRewardInfo</code>",id:"getrewardinfo",level:3}],p={toc:d};function k(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"uniswap-v3-staker-design"},"Uniswap V3 Staker Design"),(0,i.kt)("p",null,"The liquidity mining staker design is comprised of one canonical position staking contract, Staker. The technical reference for this contract is ",(0,i.kt)("a",{parentName:"p",href:"/docs/contracts/v3/reference/periphery/staker/UniswapV3Staker"},"here")," and the source code is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/uniswap-v3-staker"},"here"),"."),(0,i.kt)("h2",{id:"data-structures"},"Data Structures"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Incentive {\n  uint128 totalRewardUnclaimed;\n  uint128 numberOfStakes;\n  uint160 totalSecondsClaimedX128;\n}\n\nstruct Deposit {\n  address owner;\n  uint96 numberOfStakes;\n}\n\nstruct Stake {\n  uint160 secondsPerLiquidityInsideInitialX128;\n  uint128 liquidity;\n}\n\nstruct IncentiveKey {\n        IERC20Minimal rewardToken;\n        IUniswapV3Pool pool;\n        uint256 startTime;\n        uint256 endTime;\n        address refundee;\n}\n")),(0,i.kt)("p",null,"State:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"IUniswapV3Factory public immutable factory;\nINonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n/// @dev bytes32 refers to the return value of IncentiveId.compute\nmapping(bytes32 => Incentive) public incentives;\n\n/// @dev deposits[tokenId] => Deposit\nmapping(uint256 => Deposit) public deposits;\n\n/// @dev stakes[tokenId][incentiveHash] => Stake\nmapping(uint256 => mapping(bytes32 => Stake)) public stakes;\n\n/// @dev rewards[rewardToken][msg.sender] => uint256\nmapping(address => mapping(address => uint256)) public rewards;\n")),(0,i.kt)("p",null,"Params:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"struct CreateIncentiveParams {\n  address rewardToken;\n  address pool;\n  uint256 startTime;\n  uint256 endTime;\n  uint128 totalReward;\n}\n\nstruct EndIncentiveParams {\n  address creator;\n  address rewardToken;\n  address pool;\n  uint256 startTime;\n  uint256 endTime;\n}\n\n")),(0,i.kt)("h2",{id:"incentives"},"Incentives"),(0,i.kt)("h3",{id:"createincentivecreateincentiveparams-memory-params"},(0,i.kt)("inlineCode",{parentName:"h3"},"createIncentive(CreateIncentiveParams memory params)")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"createIncentive")," creates a liquidity mining incentive program. The key used to look up an Incentive is the hash of its immutable properties."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Check:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Incentive with these params does not already exist"),(0,i.kt)("li",{parentName:"ul"},"Timestamps: ",(0,i.kt)("inlineCode",{parentName:"li"},"params.endTime >= params.startTime"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"params.startTime >= block.timestamp")),(0,i.kt)("li",{parentName:"ul"},"Incentive with this ID does not already exist.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Effects:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Sets ",(0,i.kt)("inlineCode",{parentName:"li"},"incentives[key] = Incentive(totalRewardUnclaimed=totalReward, totalSecondsClaimedX128=0, rewardToken=rewardToken)"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Interaction:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Transfers ",(0,i.kt)("inlineCode",{parentName:"li"},"params.totalReward")," from ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," to self.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Make sure there is a check here and it fails if the transfer fails"))),(0,i.kt)("li",{parentName:"ul"},"Emits ",(0,i.kt)("inlineCode",{parentName:"li"},"IncentiveCreated"))),(0,i.kt)("h3",{id:"endincentiveendincentiveparams-memory-params"},(0,i.kt)("inlineCode",{parentName:"h3"},"endIncentive(EndIncentiveParams memory params)")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"endIncentive")," can be called by anyone to end an Incentive after the ",(0,i.kt)("inlineCode",{parentName:"p"},"endTime")," has passed, transferring ",(0,i.kt)("inlineCode",{parentName:"p"},"totalRewardUnclaimed")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"rewardToken")," back to ",(0,i.kt)("inlineCode",{parentName:"p"},"refundee"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Check:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"block.timestamp > params.endTime")),(0,i.kt)("li",{parentName:"ul"},"Incentive exists (",(0,i.kt)("inlineCode",{parentName:"li"},"incentive.totalRewardUnclaimed != 0"),")")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Effects:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"deletes ",(0,i.kt)("inlineCode",{parentName:"li"},"incentives[key]")," (This is a new change)")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Interactions:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"safeTransfers ",(0,i.kt)("inlineCode",{parentName:"li"},"totalRewardUnclaimed")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"rewardToken")," to the incentive creator ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")),(0,i.kt)("li",{parentName:"ul"},"emits ",(0,i.kt)("inlineCode",{parentName:"li"},"IncentiveEnded"))),(0,i.kt)("h2",{id:"depositwithdraw-token"},"Deposit/Withdraw Token"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Interactions")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nonfungiblePositionManager.safeTransferFrom(sender, this, tokenId)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This transfer triggers the onERC721Received hook")))),(0,i.kt)("h3",{id:"onerc721receivedaddress-address-from-uint256-tokenid-bytes-calldata-data"},(0,i.kt)("inlineCode",{parentName:"h3"},"onERC721Received(address, address from, uint256 tokenId, bytes calldata data)")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Check:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Make sure sender is univ3 nft")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Effects:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Creates a deposit for the token setting deposit ",(0,i.kt)("inlineCode",{parentName:"li"},"owner")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"from"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Setting ",(0,i.kt)("inlineCode",{parentName:"li"},"owner")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"from")," ensures that the owner of the token also owns the deposit. Approved addresses and operators may first transfer the token to themselves before depositing for deposit ownership."))),(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"data.length>0"),", stakes the token in one or more incentives")),(0,i.kt)("h3",{id:"withdrawtokenuint256-tokenid-address-to-bytes-memory-data"},(0,i.kt)("inlineCode",{parentName:"h3"},"withdrawToken(uint256 tokenId, address to, bytes memory data)")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Checks")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Check that a Deposit exists for the token and that ",(0,i.kt)("inlineCode",{parentName:"li"},"msg.sender")," is the ",(0,i.kt)("inlineCode",{parentName:"li"},"owner")," on that Deposit."),(0,i.kt)("li",{parentName:"ul"},"Check that ",(0,i.kt)("inlineCode",{parentName:"li"},"numberOfStakes")," on that Deposit is 0.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Effects")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Delete the Deposit ",(0,i.kt)("inlineCode",{parentName:"li"},"delete deposits[tokenId]"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Interactions")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"safeTransferFrom")," the token to ",(0,i.kt)("inlineCode",{parentName:"li"},"to")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"data"),"."),(0,i.kt)("li",{parentName:"ul"},"emit ",(0,i.kt)("inlineCode",{parentName:"li"},"DepositTransferred(token, deposit.owner, address(0))"))),(0,i.kt)("h2",{id:"stakeunstakerewards"},"Stake/Unstake/Rewards"),(0,i.kt)("h3",{id:"staketoken"},(0,i.kt)("inlineCode",{parentName:"h3"},"stakeToken")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Check:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deposits[params.tokenId].owner == msg.sender")),(0,i.kt)("li",{parentName:"ul"},"Make sure incentive actually exists and has reward that could be claimed (incentive.rewardToken != address(0))",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Check if this check can check totalRewardUnclaimed instead"))),(0,i.kt)("li",{parentName:"ul"},"Make sure token not already staked")),(0,i.kt)("h3",{id:"claimreward"},(0,i.kt)("inlineCode",{parentName:"h3"},"claimReward")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Interactions")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"msg.sender")," to withdraw all of their reward balance in a specific token to a specified ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," address.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"emit RewardClaimed(to, reward)"))),(0,i.kt)("h3",{id:"unstaketoken"},(0,i.kt)("inlineCode",{parentName:"h3"},"unstakeToken")),(0,i.kt)("p",null,"To unstake an NFT, you call ",(0,i.kt)("inlineCode",{parentName:"p"},"unstakeToken"),", which takes all the same arguments as ",(0,i.kt)("inlineCode",{parentName:"p"},"stake"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Checks")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It checks that you are the owner of the Deposit"),(0,i.kt)("li",{parentName:"ul"},"It checks that there exists a ",(0,i.kt)("inlineCode",{parentName:"li"},"Stake")," for the provided key (with exists=true).")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Effects")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Deletes the Stake."),(0,i.kt)("li",{parentName:"ul"},"Decrements ",(0,i.kt)("inlineCode",{parentName:"li"},"numberOfStakes")," for the Deposit by 1."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"totalRewardsUnclaimed")," is decremented by ",(0,i.kt)("inlineCode",{parentName:"li"},"reward"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"totalSecondsClaimed")," is incremented by ",(0,i.kt)("inlineCode",{parentName:"li"},"seconds"),"."),(0,i.kt)("li",{parentName:"ul"},"Increments ",(0,i.kt)("inlineCode",{parentName:"li"},"rewards[rewardToken][msg.sender]")," by the amount given by ",(0,i.kt)("inlineCode",{parentName:"li"},"getRewardInfo"),".")),(0,i.kt)("h3",{id:"getrewardinfo"},(0,i.kt)("inlineCode",{parentName:"h3"},"getRewardInfo")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It computes ",(0,i.kt)("inlineCode",{parentName:"p"},"secondsInsideX128")," (the total liquidity seconds for which rewards are owed) for a given Stake, by:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"using",(0,i.kt)("inlineCode",{parentName:"li"},"snapshotCumulativesInside")," from the Uniswap v3 core contract to get ",(0,i.kt)("inlineCode",{parentName:"li"},"secondsPerLiquidityInRangeX128"),", and subtracting ",(0,i.kt)("inlineCode",{parentName:"li"},"secondsPerLiquidityInRangeInitialX128"),"."),(0,i.kt)("li",{parentName:"ul"},"Multiplying that by ",(0,i.kt)("inlineCode",{parentName:"li"},"stake.liquidity")," to get the total seconds accrued by the liquidity in that period"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Note that X128 means it's a ",(0,i.kt)("inlineCode",{parentName:"p"},"UQ32X128"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It computes ",(0,i.kt)("inlineCode",{parentName:"p"},"totalSecondsUnclaimed")," by taking ",(0,i.kt)("inlineCode",{parentName:"p"},"max(endTime, block.timestamp) - startTime"),", casting it as a Q128, and subtracting ",(0,i.kt)("inlineCode",{parentName:"p"},"totalSecondsClaimedX128"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It computes ",(0,i.kt)("inlineCode",{parentName:"p"},"rewardRate")," for the Incentive casting ",(0,i.kt)("inlineCode",{parentName:"p"},"incentive.totalRewardUnclaimed")," as a Q128, then dividing it by ",(0,i.kt)("inlineCode",{parentName:"p"},"totalSecondsUnclaimedX128"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"reward")," is then calculated as ",(0,i.kt)("inlineCode",{parentName:"p"},"secondsInsideX128")," times the ",(0,i.kt)("inlineCode",{parentName:"p"},"rewardRate"),", scaled down to a regular uint128."))))}k.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),d=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(o.Provider,{value:t},e.children)},k={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=i,u=c["".concat(o,".").concat(m)]||c[m]||k[m]||r;return n?a.createElement(u,l(l({ref:t},p),{},{components:n})):a.createElement(u,l({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var d=2;d<r;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);