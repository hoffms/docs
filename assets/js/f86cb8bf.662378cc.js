"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[1830],{51136:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(83117),o=(n(67294),n(3905));const r={title:"Flash Accounting"},i="Introduction",l={unversionedId:"contracts/v4/guides/flash-accounting",id:"contracts/v4/guides/flash-accounting",title:"Flash Accounting",description:"Flash accounting is v4\u2019s mechanism for tracking token movements throughout a transaction. Unlike traditional token accounting which updates balances immediately after each operation, flash accounting accumulates changes (deltas) and settles them at the end of the transaction.",source:"@site/docs/contracts/v4/guides/13-flash-accounting.mdx",sourceDirName:"contracts/v4/guides",slug:"/contracts/v4/guides/flash-accounting",permalink:"/docs/contracts/v4/guides/flash-accounting",editUrl:"https://github.com/hoffms/docs/tree/main/docs/contracts/v4/guides/13-flash-accounting.mdx",tags:[],version:"current",sidebarPosition:13,frontMatter:{title:"Flash Accounting"},sidebar:"contractsSidebar",previous:{title:"StateView",permalink:"/docs/contracts/v4/guides/state-view"},next:{title:"Access msg.sender Inside a Hook",permalink:"/docs/contracts/v4/guides/accessing-msg.sender-using-hook"}},s={},c=[{value:"How Flash Accounting Works",id:"how-flash-accounting-works",level:2},{value:"The PoolManager Lock\xa0Pattern",id:"the-poolmanager-lockpattern",level:2},{value:"Working with\xa0Deltas",id:"working-withdeltas",level:2},{value:"Reading Delta\xa0States",id:"reading-deltastates",level:2},{value:"Resolving Deltas",id:"resolving-deltas",level:2},{value:"Using the Lock/Unlock Pattern",id:"using-the-lockunlock-pattern",level:2},{value:"Implementing the Unlock\xa0Callback",id:"implementing-the-unlockcallback",level:2},{value:"Adding Liquidity",id:"adding-liquidity",level:2},{value:"Removing Liquidity",id:"removing-liquidity",level:2}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"Flash accounting is v4\u2019s mechanism for tracking token movements throughout a transaction. Unlike traditional token accounting which updates balances immediately after each operation, flash accounting accumulates changes (deltas) and settles them at the end of the transaction."),(0,o.kt)("h2",{id:"how-flash-accounting-works"},"How Flash Accounting Works"),(0,o.kt)("p",null,"When interacting with v4's PoolManager, all token movements follow a consistent pattern: negative values represent tokens moving from users to the PoolManager, while positive values represent tokens moving from the PoolManager to users. This pattern appears in operations like swaps and liquidity management, where:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Negative values indicate tokens going to the PoolManager"),(0,o.kt)("li",{parentName:"ul"},"Positive values indicate tokens coming from the PoolManager")),(0,o.kt)("p",null,"These movements are tracked through deltas that represent token obligations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Negative deltas indicate tokens owed to the PoolManager"),(0,o.kt)("li",{parentName:"ul"},"Positive deltas indicate tokens the PoolManager owes to an address")),(0,o.kt)("h2",{id:"the-poolmanager-lockpattern"},"The PoolManager Lock\xa0Pattern"),(0,o.kt)("p",null,"All operations that access pool liquidity must occur while the PoolManager is unlocked. This pattern ensures atomic execution and proper delta tracking:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Unlock the PoolManager"),(0,o.kt)("li",{parentName:"ol"},"Execute operations (creating deltas)"),(0,o.kt)("li",{parentName:"ol"},"Resolve all deltas"),(0,o.kt)("li",{parentName:"ol"},"Context returns to the PoolManager which verifies no outstanding deltas")),(0,o.kt)("p",null,"If any deltas remain unresolved when the PoolManager locks, the entire transaction reverts. This guarantees that all token movements balance out by the end of the transaction. "),(0,o.kt)("h1",{id:"understanding-thebasics"},"Understanding the\xa0Basics"),(0,o.kt)("p",null,"Before diving into implementation patterns, let\u2019s look at the key concepts you\u2019ll need to work with flash accounting. Each example includes common scenarios you\u2019ll encounter when building on v4."),(0,o.kt)("h2",{id:"working-withdeltas"},"Working with\xa0Deltas"),(0,o.kt)("p",null,"Every operation in v4 that involves tokens creates deltas. These deltas track what the executor owes to the PoolManager and vice versa:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// Example: Executing a swap\n// Note: This assumes the PoolManager has been unlocked\nfunction executeSwap(PoolKey calldata key) external {\n    // A swap returns a BalanceDelta\n    BalanceDelta delta = poolManager.swap(\n        key,\n        IPoolManager.SwapParams({\n            zeroForOne: true,\n            amountSpecified: -1e18,  // Negative means spending/providing 1 ETH\n            sqrtPriceLimitX96: MAX_SQRT_RATIO - 1  // Max price willing to accept\n        }),\n        ""\n    );\n\n    // Delta shows:\n    // delta.amount0() = -1e18    (executor owes 1 ETH)\n    // delta.amount1() = +2000e6  (executor receives 2000 USDC)\n}\n')),(0,o.kt)("p",null,"When a swap is executed, the PoolManager returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"BalanceDelta")," that shows your token obligations. In this example, the negative delta (-1e18) means the executor owes 1 ETH to the PoolManager, while the positive delta (+2000e6) means the executor is entitled to receive 2000 USDC. These deltas must be resolved before the transaction completes."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Note how negative values in v4 consistently represent tokens going to the PoolManager - both in ",(0,o.kt)("inlineCode",{parentName:"em"},"amountSpecified")," for the input amount and in the returned delta for tokens owed.")),(0,o.kt)("h2",{id:"reading-deltastates"},"Reading Delta\xa0States"),(0,o.kt)("p",null,"A common pattern is checking current deltas before executing operations. The ",(0,o.kt)("inlineCode",{parentName:"p"},"TransientStateLibrary")," helps you track these balances:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'import {TransientStateLibrary} from "@uniswap/v4-core/src/libraries/TransientStateLibrary.sol";\n\ncontract DeltaReader {\n    using TransientStateLibrary for IPoolManager;\n\n    function checkDeltaBeforeOperation(\n        Currency currency,\n        address user\n    ) external view returns (int256) {\n        // Important: This shows the current delta for this token/user pair\n        return poolManager.getCurrentDelta(currency, user);\n        // Negative: User owes tokens\n        // Positive: User can claim tokens\n        // Zero: No outstanding obligations\n    }\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"TransientStateLibrary")," provides utilities to check the current state of deltas at any point in your transaction. The ",(0,o.kt)("inlineCode",{parentName:"p"},"getCurrentDelta")," function returns an int256 where negative values indicate the user owes tokens to the PoolManager, positive values mean the user can claim tokens from the PoolManager, and zero means there are no outstanding obligations for this token/user pair."),(0,o.kt)("h2",{id:"resolving-deltas"},"Resolving Deltas"),(0,o.kt)("p",null,"You must resolve all deltas before your transaction completes. There are two main approaches:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"1. Using ERC-20 Functions")),(0,o.kt)("p",null,"When using ERC-20 tokens, settling requires a specific sequence of operations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function resolveWithERC20(\n    Currency currency,\n    uint256 amount\n) external {\n    // For negative deltas (you owe tokens):\n    if (!currency.isAddressZero()) {  // If not ETH\n        poolManager.sync(currency);    // Sync currency balance first\n        IERC20Minimal(Currency.unwrap(currency)).transfer(\n            address(poolManager), \n            amount\n        );\n        poolManager.settle();          // Complete the settlement\n    }\n\n    // For positive deltas (receiving tokens):\n    poolManager.take(currency, address(this), amount);\n}\n")),(0,o.kt)("p",null,"When resolving negative deltas with ERC-20 tokens, you need to:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Sync the currency balance with ",(0,o.kt)("inlineCode",{parentName:"li"},"sync()")),(0,o.kt)("li",{parentName:"ol"},"Transfer the tokens to the PoolManager"),(0,o.kt)("li",{parentName:"ol"},"Complete the settlement with ",(0,o.kt)("inlineCode",{parentName:"li"},"settle()"))),(0,o.kt)("p",null,"For positive deltas, simply use ",(0,o.kt)("inlineCode",{parentName:"p"},"take")," to receive tokens from the PoolManager."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"2. Using ERC-6909 Functions")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function resolveWithERC6909(\n    Currency currency,\n    uint256 amount\n) external {\n    // For negative deltas (you owe tokens):\n    poolManager.burn(currency, address(this), amount);\n\n    // For positive deltas (receiving tokens):\n    poolManager.mint(currency, address(this), amount);\n}\n")),(0,o.kt)("p",null,"ERC-6909 operations map to their ERC-20 equivalents in v4:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Use ",(0,o.kt)("inlineCode",{parentName:"li"},"burn")," when you would use ",(0,o.kt)("inlineCode",{parentName:"li"},"settle")," (for negative deltas)"),(0,o.kt)("li",{parentName:"ul"},"Use ",(0,o.kt)("inlineCode",{parentName:"li"},"mint")," when you would use ",(0,o.kt)("inlineCode",{parentName:"li"},"take")," (for positive deltas)")),(0,o.kt)("p",null,"Notice how this pattern requires no additional sync operations or separate token transfers."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Important"),": ",(0,o.kt)("em",{parentName:"p"},"Every delta must be resolved before the transaction ends, or the entire transaction will revert. Use")," ",(0,o.kt)("inlineCode",{parentName:"p"},"TransientStateLibrary")," ",(0,o.kt)("em",{parentName:"p"},"to verify your balances are properly settled."))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("em",{parentName:"p"},"Delta is a net balance resulting from token movements thus not bound to a certain token type i.e. can be resolved via mix-and-match with ERC-20 functions and ERC-6909 functions."))),(0,o.kt)("h1",{id:"working-with-flash-accounting"},"Working with Flash Accounting"),(0,o.kt)("p",null,"To interact with the PoolManager, we first need to create the functions our users will call. Then we'll implement the unlock callback pattern required to execute these operations."),(0,o.kt)("h2",{id:"using-the-lockunlock-pattern"},"Using the Lock/Unlock Pattern"),(0,o.kt)("p",null,"Let's start by creating our external function. First, we need to implement the callback that the ",(0,o.kt)("inlineCode",{parentName:"p"},"PoolManager")," will use:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function unlockCallback(bytes calldata data) external returns (bytes memory) {\n    // To be implemented later\n}\n")),(0,o.kt)("p",null,"Now let's implement our external function that users will call:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function executeSwap(\n    PoolKey calldata key,\n    uint256 amount\n) external returns (int256, int256) {\n    // Encode operation parameters\n    bytes memory data = abi.encode(key, amount);\n\n    // Call unlock with encoded data\n    bytes memory result = poolManager.unlock(data);\n\n    // Optional: Decode any relevant return data\n    return (0, 0); // Replace with actual return values if needed\n}\n")),(0,o.kt)("p",null,"When you call this function the flow followed is the following:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"unlock")," is called on the PoolManager"),(0,o.kt)("li",{parentName:"ol"},"PoolManager calls back to your ",(0,o.kt)("inlineCode",{parentName:"li"},"unlockCallback")),(0,o.kt)("li",{parentName:"ol"},"Your callback executes the operations"),(0,o.kt)("li",{parentName:"ol"},"All deltas must be resolved before returning"),(0,o.kt)("li",{parentName:"ol"},"Execution of the logic returns to the PoolManager which verifies there are no outstanding deltas, and will relock itself")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Warning*"),": Always implement proper access control in your unlock callback. Only the PoolManager should be able to call it.*")),(0,o.kt)("h2",{id:"implementing-the-unlockcallback"},"Implementing the Unlock\xa0Callback"),(0,o.kt)("p",null,"First, let\u2019s set up a contract with the proper unlock callback implementation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";\nimport {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";\nimport {BalanceDelta} from "@uniswap/v4-core/src/types/BalanceDelta.sol";\nimport {Currency} from "@uniswap/v4-core/src/types/Currency.sol";\n\ncontract FlashAccountingExample {\n    IPoolManager public immutable poolManager;\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n    }\n    \n    function executeSwap(\n        PoolKey calldata key,\n        uint256 amount\n    ) external returns (int256, int256) {\n        ...\n    }\n\n    function unlockCallback(bytes calldata data) external returns (bytes memory) {\n        // Important: Must check caller is PoolManager\n        require(msg.sender == address(poolManager), "Not pool manager");\n\n        // Decode and call our executeOperations function which \n        // we\'ll implement next\n        (bytes memory result) = executeOperations(data);\n\n        // Important: Must return bytes, even if empty\n        return result;\n    }\n}\n')),(0,o.kt)("p",null,"This base contract sets up the foundation for working with v4\u2019s flash accounting. The ",(0,o.kt)("inlineCode",{parentName:"p"},"unlockCallback")," function is required for any operations that access pool liquidity - when your contract calls ",(0,o.kt)("inlineCode",{parentName:"p"},"poolManager.unlock()"),", the PoolManager calls back to this function to execute your operations."),(0,o.kt)("p",null,"The callback must verify it's being called by the PoolManager and return a bytes value (even if empty) to prevent transaction failures. Any actual pool operations (like swaps or liquidity changes) will be handled through the ",(0,o.kt)("inlineCode",{parentName:"p"},"executeOperations")," function."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Critical Note*"),": The most common mistake developers make is not returning a bytes value from unlockCallback. This will cause your transaction to revert. Always return a bytes value, even if it\u2019s empty.*")),(0,o.kt)("p",null,"Let\u2019s add functionality to execute operations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'function executeOperations(\n    bytes calldata data\n) internal returns (bytes memory) {\n    // Decode operation parameters\n    (PoolKey memory key, uint256 amount) = abi.decode(\n        data,\n        (PoolKey, uint256)\n    );\n\n    // Execute operation (e.g. swap)\n    BalanceDelta delta = poolManager.swap(\n        key,\n        IPoolManager.SwapParams({\n            zeroForOne: true,\n            amountSpecified: -int256(amount),\n            sqrtPriceLimitX96: 0\n        }),\n        ""\n    );\n\n    // Resolve deltas\n    if (delta.amount0() < 0) {\n        poolManager.sync(key.currency0);\n        IERC20Minimal(Currency.unwrap(key.currency0)).transfer(\n            address(poolManager),\n            uint256(-delta.amount0())\n        );\n        poolManager.settle();\n    }\n    if (delta.amount1() > 0) {\n        poolManager.take(\n            key.currency1,\n            address(this),\n            uint256(delta.amount1())\n        );\n    }\n\n    return ""; // Return empty bytes if no specific result needed\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"executeOperations")," function handles the actual pool operations. It first decodes the data passed from the unlock call to get the operation parameters. "),(0,o.kt)("p",null,"In this example, it executes a swap which creates deltas (token obligations) that must be resolved. For negative deltas (tokens we owe), we follow a specific sequence: first sync the currency state, then transfer the tokens to the PoolManager, and finally call settle. For positive deltas (tokens we receive), we use take to claim them. All deltas must be resolved before the function returns or the transaction will revert."),(0,o.kt)("h1",{id:"managing-liquidity-with-flash-accounting"},"Managing Liquidity with Flash Accounting"),(0,o.kt)("p",null,"When adding or removing liquidity in v4, you\u2019ll use ",(0,o.kt)("inlineCode",{parentName:"p"},"modifyLiquidity")," which creates deltas that need to be handled through flash accounting. Let's understand how this works."),(0,o.kt)("h2",{id:"adding-liquidity"},"Adding Liquidity"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// Example: Adding liquidity creates negative deltas (you need to provide tokens)\nBalanceDelta delta = poolManager.modifyLiquidity(\n    key,\n    IPoolManager.ModifyLiquidityParams({\n        tickLower: tickLower,       // Lower price bound for position\n        tickUpper: tickUpper,       // Upper price bound for position\n        liquidityDelta: liquidityAmount  // Positive for adding liquidity\n    }),\n    ""  // No hook data needed\n);\n\n// Negative deltas for both tokens\n// delta.amount0() = -100  (need to provide token0)\n// delta.amount1() = -200  (need to provide token1)\n')),(0,o.kt)("p",null,"When adding liquidity to a pool, you\u2019ll need to provide both tokens in the pair. The ",(0,o.kt)("inlineCode",{parentName:"p"},"modifyLiquidity")," function returns a ",(0,o.kt)("a",{parentName:"p",href:"/contracts/v4/reference/core/types/balancedelta"},(0,o.kt)("inlineCode",{parentName:"a"},"BalanceDelta"))," that indicates how many tokens you need to provide. In this case:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The negative values in the delta (-100, -200) indicate you need to provide these amounts of each token"),(0,o.kt)("li",{parentName:"ul"},"The values are proportional to the current pool price and your specified price range (tickLower to tickUpper)"),(0,o.kt)("li",{parentName:"ul"},"These deltas must be resolved by providing the tokens before the transaction completes")),(0,o.kt)("h2",{id:"removing-liquidity"},"Removing Liquidity"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// Example: Removing liquidity creates positive deltas (you receive tokens)\nBalanceDelta delta = poolManager.modifyLiquidity(\n    key,\n    IPoolManager.ModifyLiquidityParams({\n        tickLower: tickLower,       // Same position bounds as when added\n        tickUpper: tickUpper,\n        liquidityDelta: -liquidityAmount  // Negative for removing liquidity\n    }),\n    ""  // No hook data needed\n);\n\n// Positive deltas for both tokens\n// delta.amount0() = +100  (receive token0)\n// delta.amount1() = +200  (receive token1)\n')),(0,o.kt)("p",null,"When removing liquidity, the process is reversed. The negative ",(0,o.kt)("inlineCode",{parentName:"p"},"liquidityDelta")," indicates you're removing liquidity, and the function returns positive deltas representing the tokens you'll receive:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The positive values (+100, +200) indicate the amounts you\u2019ll receive of each token"),(0,o.kt)("li",{parentName:"ul"},"The amounts depend on the pool\u2019s current state and how much liquidity you\u2019re removing"),(0,o.kt)("li",{parentName:"ul"},"These positive deltas represent tokens you can claim from the pool")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Important*"),": Unlike single token operations, liquidity management typically involves handling deltas for both tokens in the pool.*")))}p.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,k=d["".concat(s,".").concat(m)]||d[m]||p[m]||r;return n?a.createElement(k,i(i({ref:t},u),{},{components:n})):a.createElement(k,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);