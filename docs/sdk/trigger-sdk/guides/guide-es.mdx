---
description: Construa mini apps din√°micas usando Next.js y el Sherry Links SDK
sidebar_position: 1
tags: [nextjs, sdk, mini-apps, blockchain, tutorial]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import Admonition from '@theme/Admonition';

# Gu√≠a - MiniApp con NextJS

## Creando Mini Apps con Next.js y Sherry SDK

Esta gu√≠a completa te ense√±ar√° paso a paso c√≥mo crear mini apps potentes usando **Next.js** y el **Sherry Links SDK**. Las mini apps son aplicaciones din√°micas que pueden integrarse en diferentes plataformas y permiten a los usuarios interactuar con contratos inteligentes de manera fluida.

<Admonition type="info" title="Informaci√≥n del Minithon">
  Este tutorial contiene notas espec√≠ficas para **participantes del hackathon Minithon**. Si el
  Minithon ya ha concluido, puedes ignorar estas referencias - todo el contenido t√©cnico y ejemplos
  siguen siendo completamente aplicables para aprender y probar acciones din√°micas en producci√≥n.
</Admonition>

<Admonition type="warning" title="Importante para Participantes del Minithon">
  Este tutorial progresa desde un **ejemplo b√°sico** (transferencia simple) hasta un **ejemplo
  complejo** (interacci√≥n con contratos inteligentes). Para env√≠os al minithon, necesitar√°s
  implementar la versi√≥n compleja que interact√∫a con contratos inteligentes, ya que las
  transferencias simples ya pueden manejarse con nuestro TransferAction incorporado.
</Admonition>

## üìã Tabla de Contenidos

- [C√≥mo Funciona Sherry - Entendiendo el Flujo](#c√≥mo-funciona-sherry---entendiendo-el-flujo)
- [Requisitos Previos](#requisitos-previos)
- [Configuraci√≥n Inicial](#configuraci√≥n-inicial)
- [Creando el Endpoint GET - Metadata](#creando-el-endpoint-get---metadata)
- [Ejemplo 1: Transferencia Simple (Solo Aprendizaje)](#ejemplo-1-transferencia-simple-solo-aprendizaje)
- [Ejemplo 2: Interacci√≥n con Contratos Inteligentes (Listo para Minithon)](#ejemplo-2-interacci√≥n-con-contratos-inteligentes-listo-para-minithon)
- [Manejo de CORS](#manejo-de-cors)
- [Probando tu Mini App](#probando-tu-mini-app)
- [Resoluci√≥n de Problemas](#resoluci√≥n-de-problemas)

## üîÑ C√≥mo Funciona Sherry - Entendiendo el Flujo

Antes de empezar a construir, es importante entender c√≥mo Sherry Links conecta usuarios, plataformas y tu backend de mini app. El siguiente diagrama ilustra el flujo completo:

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img
    src="/img/sherry-flow.png"
    alt="Diagrama de Flujo de Sherry Links - C√≥mo los usuarios interact√∫an con mini apps a trav√©s de la plataforma"
    style={{
      maxWidth: '100%',
      height: 'auto',
      border: '1px solid var(--ifm-color-emphasis-300)',
      borderRadius: '8px',
      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
    }}
  />
</div>

### Flujo Paso a Paso

1. **Sherry hace petici√≥n GET y recibe metadata**

   - La plataforma descubre tu mini app y solicita su configuraci√≥n
   - Tu backend responde con metadata que define la UI y funcionalidad

2. **Back-End retorna metadata**

   - La metadata incluye campos de formulario, botones de acci√≥n, descripciones y endpoints
   - Esto le dice a Sherry c√≥mo renderizar la interfaz de tu mini app

3. **Sherry renderiza mini-app**

   - La plataforma crea un formulario amigable basado en tu metadata
   - Los usuarios pueden ver campos de entrada, descripciones y botones de acci√≥n

4. **Usuario ejecuta mini-app**

   - El usuario llena el formulario con sus par√°metros deseados
   - El usuario hace clic en el bot√≥n de acci√≥n para enviar su solicitud

5. **Sherry hace petici√≥n POST y recibe transacci√≥n serializada desde Back-End**

   - La plataforma env√≠a la entrada del usuario a tu backend para procesamiento
   - Tu backend aplica l√≥gica personalizada y retorna una transacci√≥n blockchain lista para firmar

6. **Usuario confirma transacci√≥n**
   - El usuario revisa los detalles de la transacci√≥n en su wallet
   - El usuario firma y env√≠a la transacci√≥n a la blockchain

<Admonition type="tip" title="Concepto Clave">
  Tu mini app act√∫a como una **f√°brica inteligente de transacciones** - toma la entrada del usuario,
  aplica tu l√≥gica de negocio √∫nica, y produce transacciones blockchain listas para firmar. Esto es
  lo que hace poderoso a Sherry Links: combinar gran UX con funcionalidad blockchain personalizada.
</Admonition>

## üõ†Ô∏è Requisitos Previos

Antes de comenzar, aseg√∫rate de tener lo siguiente instalado y configurado:

- **Node.js**: Versi√≥n 18.x o superior
- **Gestor de Paquetes**: npm, yarn, o pnpm
- **Conocimiento del Framework**: Conceptos b√°sicos de Next.js y TypeScript
- **Conceptos B√°sicos de Blockchain**: Entendimiento de contratos inteligentes y ABI

## üèóÔ∏è Configuraci√≥n Inicial

### 1. Crear Proyecto Next.js

<Tabs>
<TabItem value="npm" label="npm" default>

```bash
npx create-next-app@latest mi-sherry-app --typescript --eslint --tailwind --src-dir --app --import-alias "@/*"
cd mi-sherry-app
```

</TabItem>
<TabItem value="yarn" label="yarn">

```bash
yarn create next-app mi-sherry-app --typescript --eslint --tailwind --src-dir --app --import-alias "@/*"
cd mi-sherry-app
```

</TabItem>
<TabItem value="pnpm" label="pnpm">

```bash
pnpm create next-app mi-sherry-app --typescript --eslint --tailwind --src-dir --app --import-alias "@/*"
cd mi-sherry-app
```

</TabItem>
</Tabs>

### 2. Instalar Dependencias

<Tabs>
<TabItem value="npm" label="npm" default>

```bash
npm install @sherrylinks/sdk viem wagmi
```

</TabItem>
<TabItem value="yarn" label="yarn">

```bash
yarn add @sherrylinks/sdk viem wagmi
```

</TabItem>
<TabItem value="pnpm" label="pnpm">

```bash
pnpm add @sherrylinks/sdk viem wagmi
```

</TabItem>
</Tabs>

### 3. Configurar Next.js (Opcional)

<Admonition type="tip" title="Optimizaci√≥n de Build">
  Para evitar errores de build con ESLint, puedes deshabilitarlo en `next.config.js`:
</Admonition>

```javascript title="next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: {
    ignoreDuringBuilds: true,
  },
};

module.exports = nextConfig;
```

## üéØ Creando el Endpoint GET - Metadata

El endpoint GET es el **coraz√≥n** de tu mini app. Aqu√≠ defines toda la informaci√≥n y estructura que las plataformas necesitan para renderizar tu aplicaci√≥n.

<Admonition type="note" title="Entendiendo la Metadata">
  La metadata le dice a las plataformas **c√≥mo** renderizar tu mini app, **qu√©** inputs mostrar a
  los usuarios, y **d√≥nde** enviar los datos cuando los usuarios interact√∫an con ella.
</Admonition>

### 1. Crear el Archivo de Ruta

Crea el archivo `app/api/mi-app/route.ts`:

```typescript title="app/api/mi-app/route.ts"
import { NextRequest, NextResponse } from 'next/server';
import { createMetadata, Metadata, ValidatedMetadata } from '@sherrylinks/sdk';
```

### 2. Configurar la Estructura B√°sica del Handler GET

```typescript
export async function GET(req: NextRequest) {
  try {
    // Obtener informaci√≥n de la URL del servidor
    const host = req.headers.get('host') || 'localhost:3000';
    const protocol = req.headers.get('x-forwarded-proto') || 'http';

    // Construir la URL base
    const serverUrl = `${protocol}://${host}`;

    // Construiremos el objeto metadata paso a paso abajo
  } catch (error) {
    console.error('Error creando metadata:', error);
    return NextResponse.json({ error: 'Error al crear metadata' }, { status: 500 });
  }
}
```

<Admonition type="info" title="¬øPor qu√© serverUrl?">
  Esto detecta autom√°ticamente si est√°s ejecutando localmente (`http://localhost:3000`) o en
  producci√≥n (`https://tudominio.com`) y construye la URL base correcta para tu mini app.
</Admonition>

### 3. Definir Informaci√≥n B√°sica de la App

```typescript
export async function GET(req: NextRequest) {
  try {
    const host = req.headers.get('host') || 'localhost:3000';
    const protocol = req.headers.get('x-forwarded-proto') || 'http';
    const serverUrl = `${protocol}://${host}`;

    const metadata: Metadata = {
      url: 'https://sherry.social',
      icon: 'https://avatars.githubusercontent.com/u/117962315',
      title: 'Mensaje con Timestamp',
      baseUrl: serverUrl,
      description:
        'Almacena un mensaje con un timestamp optimizado calculado por nuestro algoritmo',
      // Las acciones se agregar√°n en el siguiente paso
    };
  } catch (error) {
    // Manejo de errores...
  }
}
```

<details>
<summary><strong>Entendiendo Cada Campo</strong></summary>

| Campo           | Descripci√≥n                                                      | Ejemplo                                           |
| --------------- | ---------------------------------------------------------------- | ------------------------------------------------- |
| **url**         | URL principal del sitio web de tu proyecto                       | `"https://sherry.social"`                         |
| **icon**        | URL de imagen p√∫blicamente accesible (200x200px recomendado)     | `"https://ejemplo.com/icon.png"`                  |
| **title**       | Nombre corto y descriptivo para tu mini app                      | `"Mensaje con Timestamp"`                         |
| **baseUrl**     | URL del servidor donde tu mini app est√° alojada (auto-detectada) | `"https://tudominio.com"`                         |
| **description** | Explicaci√≥n clara de qu√© hace tu mini app                        | `"Almacenar mensajes con timestamps optimizados"` |

</details>

### 4. Agregar Array de Acciones

<Admonition type="caution" title="Las Acciones Definen la Funcionalidad">
  Las acciones definen **qu√© pueden hacer** los usuarios con tu mini app. Cada acci√≥n representa un
  bot√≥n con funcionalidad espec√≠fica.
</Admonition>

```typescript
const metadata: Metadata = {
  url: 'https://sherry.social',
  icon: 'https://avatars.githubusercontent.com/u/117962315',
  title: 'Mensaje con Timestamp',
  baseUrl: serverUrl,
  description: 'Almacena un mensaje con un timestamp optimizado calculado por nuestro algoritmo',
  actions: [
    {
      type: 'dynamic',
      label: 'Almacenar Mensaje',
      description:
        'Almacena tu mensaje con un timestamp personalizado calculado para almacenamiento √≥ptimo',
      chains: { source: 'fuji' },
      path: `/api/mi-app`,
      // Los par√°metros se agregar√°n en el siguiente paso
    },
  ],
};
```

<details>
<summary><strong>Entendiendo las Propiedades de Acci√≥n</strong></summary>

- **type**: Siempre usa `"dynamic"` para mini apps complejas que necesitan l√≥gica personalizada
- **label**: El texto que aparecer√° en el bot√≥n de acci√≥n
- **description**: Explicaci√≥n de qu√© hace esta acci√≥n espec√≠fica
- **chains.source**: La blockchain donde se ejecutar√° la transacci√≥n
  - `"fuji"` = Avalanche Fuji Testnet
  - `"avalanche"` = Avalanche Mainnet
- **path**: El endpoint de API que manejar√° la petici√≥n POST

</details>

### 5. Configurar Par√°metros de Entrada del Usuario

```typescript
const metadata: Metadata = {
  url: 'https://sherry.social',
  icon: 'https://avatars.githubusercontent.com/u/117962315',
  title: 'Mensaje con Timestamp',
  baseUrl: serverUrl,
  description: 'Almacena un mensaje con un timestamp optimizado calculado por nuestro algoritmo',
  actions: [
    {
      type: 'dynamic',
      label: 'Almacenar Mensaje',
      description:
        'Almacena tu mensaje con un timestamp personalizado calculado para almacenamiento √≥ptimo',
      chains: { source: 'fuji' },
      path: `/api/mi-app`,
      params: [
        {
          name: 'mensaje',
          label: '¬°Tu Mensaje Hermano!',
          type: 'text',
          required: true,
          description: 'Ingresa el mensaje que quieres almacenar en la blockchain',
        },
      ],
    },
  ],
};
```

<Admonition type="info" title="Tipos de Par√°metros Disponibles">
  - `"text"`: Entrada de texto de una l√≠nea - `"textarea"`: Entrada de texto multil√≠nea -
  `"number"`: Entrada num√©rica con validaci√≥n - `"email"`: Entrada de email con validaci√≥n -
  `"url"`: Entrada de URL con validaci√≥n
</Admonition>

### 6. Validar y Retornar la Metadata

```typescript
export async function GET(req: NextRequest) {
  try {
    const host = req.headers.get('host') || 'localhost:3000';
    const protocol = req.headers.get('x-forwarded-proto') || 'http';
    const serverUrl = `${protocol}://${host}`;

    const metadata: Metadata = {
      url: 'https://sherry.social',
      icon: 'https://avatars.githubusercontent.com/u/117962315',
      title: 'Mensaje con Timestamp',
      baseUrl: serverUrl,
      description:
        'Almacena un mensaje con un timestamp optimizado calculado por nuestro algoritmo',
      actions: [
        {
          type: 'dynamic',
          label: 'Almacenar Mensaje',
          description:
            'Almacena tu mensaje con un timestamp personalizado calculado para almacenamiento √≥ptimo',
          chains: { source: 'fuji' },
          path: `/api/mi-app`,
          params: [
            {
              name: 'mensaje',
              label: '¬°Tu Mensaje Hermano!',
              type: 'text',
              required: true,
              description: 'Ingresa el mensaje que quieres almacenar en la blockchain',
            },
          ],
        },
      ],
    };

    // Validar metadata usando el SDK
    const validated: ValidatedMetadata = createMetadata(metadata);

    // Retornar con headers CORS para acceso cross-origin
    return NextResponse.json(validated, {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      },
    });
  } catch (error) {
    console.error('Error creando metadata:', error);
    return NextResponse.json({ error: 'Error al crear metadata' }, { status: 500 });
  }
}
```

<Admonition type="success" title="Beneficios de la Validaci√≥n">
  La funci√≥n `createMetadata()` valida la estructura de tu metadata y asegura que cumple con los
  requisitos del Sherry SDK antes de retornarla a la plataforma.
</Admonition>

## üìö Ejemplo 1: Transferencia Simple (Solo Aprendizaje)

<Admonition type="danger" title="Nota Importante">
  Este ejemplo es para **aprender los conceptos b√°sicos solamente**. Transferencias simples como
  esta ya est√°n soportadas por nuestro TransferAction incorporado y **NO ser√°n aceptadas** en env√≠os
  al minithon. √ösalo para entender el flujo, luego pasa al Ejemplo 2 para funcionalidad lista para
  minithon.
</Admonition>

### Entendiendo el Flujo de Petici√≥n POST

Cuando un usuario completa el formulario de tu mini app y hace clic en el bot√≥n de acci√≥n, la plataforma enviar√° una **petici√≥n POST** a tu endpoint con la entrada del usuario como par√°metros de URL.

### 1. Configurar la Estructura del Handler POST

Agrega estas importaciones al inicio de tu archivo:

```typescript title="app/api/mi-app/route.ts"
import { NextRequest, NextResponse } from 'next/server';
import { avalancheFuji } from 'viem/chains';
import { createMetadata, Metadata, ValidatedMetadata, ExecutionResponse } from '@sherrylinks/sdk';
import { serialize } from 'wagmi';
```

Ahora construyamos el handler POST:

<Tabs>
<TabItem value="basic" label="Estructura B√°sica" default>

```typescript
export async function POST(req: NextRequest) {
  try {
    // Paso 1: Extraer par√°metros de la URL
    const { searchParams } = new URL(req.url);
    const mensaje = searchParams.get('mensaje');

    // Agregaremos validaci√≥n y creaci√≥n de transacci√≥n abajo
  } catch (error) {
    console.error('Error en petici√≥n POST:', error);
    return NextResponse.json({ error: 'Error Interno del Servidor' }, { status: 500 });
  }
}
```

</TabItem>
<TabItem value="validation" label="Con Validaci√≥n">

```typescript
export async function POST(req: NextRequest) {
  try {
    // Extraer par√°metros
    const { searchParams } = new URL(req.url);
    const mensaje = searchParams.get('mensaje');

    // Validar par√°metros requeridos
    if (!mensaje) {
      return NextResponse.json(
        { error: 'El par√°metro mensaje es requerido' },
        {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        },
      );
    }

    // La creaci√≥n de transacci√≥n se agregar√° despu√©s
  } catch (error) {
    // Manejo de errores...
  }
}
```

</TabItem>
</Tabs>

### 2. Crear el Objeto de Transacci√≥n

```typescript
// Crear una transacci√≥n de transferencia simple
const tx = {
  to: '0x5ee75a1B1648C023e885E58bD3735Ae273f2cc52',
  value: BigInt(1000000), // 1000000 wei = 0.000001 AVAX
  chainId: avalancheFuji.id,
};
```

<details>
<summary><strong>Entendiendo las Propiedades de Transacci√≥n</strong></summary>

- **to**: La direcci√≥n de destino que recibir√° la transferencia
- **value**: La cantidad a transferir en wei (unidad m√°s peque√±a). Usa `BigInt()` para n√∫meros grandes
- **chainId**: El ID num√©rico de la blockchain (avalancheFuji.id = 43113)

</details>

### 3. Ejemplo Completo de Transferencia Simple

```typescript title="Handler POST Completo - Transferencia Simple"
export async function POST(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const mensaje = searchParams.get('mensaje');

    if (!mensaje) {
      return NextResponse.json(
        { error: 'El par√°metro mensaje es requerido' },
        {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        },
      );
    }

    const tx = {
      to: '0x5ee75a1B1648C023e885E58bD3735Ae273f2cc52',
      value: BigInt(1000000),
      chainId: avalancheFuji.id,
    };

    // Serializar la transacci√≥n para la blockchain
    const serialized = serialize(tx);

    // Crear el objeto de respuesta que Sherry espera
    const resp: ExecutionResponse = {
      serializedTransaction: serialized,
      chainId: avalancheFuji.name, // Usar el nombre de la chain, no el ID
    };

    // Retornar la respuesta con headers CORS
    return NextResponse.json(resp, {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    });
  } catch (error) {
    console.error('Error en petici√≥n POST:', error);
    return NextResponse.json({ error: 'Error Interno del Servidor' }, { status: 500 });
  }
}
```

<Admonition type="warning" title="Por Qu√© Esto No Es Listo para Minithon">
  Este ejemplo solo realiza una transferencia simple de tokens. Dado que nuestra plataforma ya
  proporciona **TransferAction** para esta funcionalidad exacta, los env√≠os al minithon necesitan
  demostrar funcionalidad m√°s compleja y con valor agregado.
</Admonition>

## üéØ Ejemplo 2: Interacci√≥n con Contratos Inteligentes (Listo para Minithon)

<Admonition type="success" title="Adecuado para Minithon">
  Este ejemplo demuestra **interacci√≥n con contratos inteligentes** con l√≥gica de negocio
  personalizada, que es lo que buscamos en los env√≠os al minithon.
</Admonition>

### 1. Entendiendo el Contrato Inteligente

Primero, entendamos qu√© hace nuestro contrato inteligente:

```solidity title="Contrato TimestampedMessage"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @title TimestampedMessage
 * @dev Stores messages with an optimized timestamp
 */
contract TimestampedMessage {
    event MessageStored(address indexed sender, string message, uint256 timestamp, uint256 optimizedTimestamp);

    struct MessageData {
        address sender;
        string message;
        uint256 timestamp;
        uint256 optimizedTimestamp;
    }

    // Array to store all messages
    MessageData[] public messages;

    // Mapping from address to their message count
    mapping(address => uint256) public userMessageCount;

    /**
     * @dev Store a message with an optimized timestamp
     * @param message The message to store
     * @param optimizedTimestamp A timestamp calculated off-chain
     */
    function storeMessage(string memory message, uint256 optimizedTimestamp) public {
        // Store message with the current block timestamp and the optimized timestamp
        messages.push(MessageData({
            sender: msg.sender,
            message: message,
            timestamp: block.timestamp,
            optimizedTimestamp: optimizedTimestamp
        }));

        // Increment message count for the sender
        userMessageCount[msg.sender]++;

        // Emit event
        emit MessageStored(msg.sender, message, block.timestamp, optimizedTimestamp);
    }

    /**
     * @dev Get the count of all messages
     */
    function getMessageCount() public view returns (uint256) {
        return messages.length;
    }

    /**
     * @dev Get a message by index
     */
    function getMessage(uint256 index) public view returns (
        address sender,
        string memory message,
        uint256 timestamp,
        uint256 optimizedTimestamp
    ) {
        require(index < messages.length, "Index out of bounds");
        MessageData memory data = messages[index];
        return (data.sender, data.message, data.timestamp, data.optimizedTimestamp);
    }

    /**
     * @dev Get all messages from a specific sender
     */
    function getMessagesBySender(address sender) public view returns (
        string[] memory messageTexts,
        uint256[] memory timestamps,
        uint256[] memory optimizedTimestamps
    ) {
        uint256 count = userMessageCount[sender];

        messageTexts = new string[](count);
        timestamps = new uint256[](count);
        optimizedTimestamps = new uint256[](count);

        uint256 currentIndex = 0;

        for (uint256 i = 0; i < messages.length; i++) {
            if (messages[i].sender == sender) {
                messageTexts[currentIndex] = messages[i].message;
                timestamps[currentIndex] = messages[i].timestamp;
                optimizedTimestamps[currentIndex] = messages[i].optimizedTimestamp;
                currentIndex++;
            }
        }

        return (messageTexts, timestamps, optimizedTimestamps);
    }
}
```

<Admonition type="info" title="Por Qu√© Esto Es Listo para Minithon">
  - L√≥gica de negocio personalizada (c√°lculo de timestamp optimizado) - Gesti√≥n de estado de
  contrato inteligente - Emisi√≥n de eventos para seguimiento - Estructuras de datos complejas - Va
  m√°s all√° de transferencias simples
</Admonition>

### 2. Actualizar las Importaciones de tu Archivo de Ruta

```typescript title="app/api/mi-app/route.ts"
import { NextRequest, NextResponse } from 'next/server';
import { avalancheFuji } from 'viem/chains';
import { createMetadata, Metadata, ValidatedMetadata, ExecutionResponse } from '@sherrylinks/sdk';
import { serialize, TransactionSerializable, encodeFunctionData } from 'wagmi';
import { abi } from '@/blockchain/abi';

// Direcci√≥n del contrato en Avalanche Fuji Testnet
const CONTRACT_ADDRESS = '0xTuContratoInteligenteDirecci√≥nAqu√≠';
```

### 3. Construir el Handler POST del Contrato Inteligente

<Tabs>
<TabItem value="step1" label="Paso 1: Validaci√≥n" default>

```typescript
export async function POST(req: NextRequest) {
  try {
    // Extraer entrada del usuario
    const { searchParams } = new URL(req.url);
    const message = searchParams.get('mensaje');

    // Validar par√°metros requeridos
    if (!message) {
      return NextResponse.json(
        { error: 'Message parameter is required' },
        {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        },
      );
    }

    // La l√≥gica personalizada y creaci√≥n de transacci√≥n se agregar√°n abajo
  } catch (error) {
    console.error('Error en petici√≥n POST:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
```

</TabItem>
<TabItem value="step2" label="Paso 2: L√≥gica Personalizada">

```typescript
export async function POST(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const message = searchParams.get('mensaje');

    if (!message) {
      // Error de validaci√≥n...
    }

    // L√ìGICA DE NEGOCIO PERSONALIZADA: Calcular timestamp optimizado
    // Esto es lo que hace tu mini app √∫nica y valiosa
    const optimizedTimestamp = calculateOptimizedTimestamp(message);

    console.log(`Procesando mensaje: "${message}"`);
    console.log(`Timestamp optimizado: ${optimizedTimestamp}`);

    // La creaci√≥n de transacci√≥n se agregar√° despu√©s
  } catch (error) {
    // Manejo de errores...
  }
}
```

</TabItem>
<TabItem value="step3" label="Paso 3: Transacci√≥n del Contrato">

```typescript
export async function POST(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const message = searchParams.get('mensaje');

    if (!message) {
      // Validaci√≥n...
    }

    const optimizedTimestamp = calculateOptimizedTimestamp(message);

    // Codificar los datos de la funci√≥n del contrato
    const data = encodeFunctionData({
      abi: abi,
      functionName: 'storeMessage',
      args: [message, BigInt(optimizedTimestamp)],
    });

    // Crear transacci√≥n de interacci√≥n con contrato inteligente
    const tx: TransactionSerializable = {
      to: CONTRACT_ADDRESS,
      data: data,
      chainId: avalancheFuji.id,
      type: 'legacy',
    };

    // La serializaci√≥n y respuesta se agregar√°n despu√©s
  } catch (error) {
    // Manejo de errores...
  }
}
```

</TabItem>
</Tabs>

<details>
<summary><strong>Entendiendo las Propiedades de Transacci√≥n de Contrato Inteligente</strong></summary>

- **to**: La direcci√≥n del contrato desplegado en la blockchain
- **data**: Los datos codificados de la funci√≥n usando `encodeFunctionData`
- **chainId**: El ID num√©rico de la blockchain (avalancheFuji.id = 43113)
- **type**: El tipo de transacci√≥n ('legacy' para compatibilidad amplia)

</details>

### 4. Handler Completo de Contrato Inteligente

```typescript title="Handler POST Completo - Interacci√≥n con Contrato Inteligente"
export async function POST(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const message = searchParams.get('mensaje');

    if (!message) {
      return NextResponse.json(
        { error: 'Message parameter is required' },
        {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        },
      );
    }

    // Calcular timestamp optimizado usando algoritmo personalizado
    const optimizedTimestamp = calculateOptimizedTimestamp(message);

    // Codificar los datos de la funci√≥n del contrato
    const data = encodeFunctionData({
      abi: abi,
      functionName: 'storeMessage',
      args: [message, BigInt(optimizedTimestamp)],
    });

    // Crear transacci√≥n de contrato inteligente
    const tx: TransactionSerializable = {
      to: CONTRACT_ADDRESS,
      data: data,
      chainId: avalancheFuji.id,
      type: 'legacy',
    };

    // Serializar transacci√≥n
    const serialized = serialize(tx);

    // Crear respuesta
    const resp: ExecutionResponse = {
      serializedTransaction: serialized,
      chainId: avalancheFuji.name,
    };

    // Retornar respuesta exitosa
    return NextResponse.json(resp, {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    });
  } catch (error) {
    console.error('Error en petici√≥n POST:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
```

### 5. Implementar el Algoritmo Personalizado

```typescript title="Algoritmo Personalizado para Timestamp"
// Algoritmo personalizado para calcular timestamp optimizado basado en el contenido del mensaje
function calculateOptimizedTimestamp(message: string): number {
  // Obtener el timestamp actual como punto de partida
  const currentTimestamp = Math.floor(Date.now() / 1000);

  // Algoritmo personalizado: Agregar c√≥digos de caracteres para crear un offset √∫nico
  // Esta es tu l√≥gica de negocio √∫nica - puedes hacer esto tan complejo como necesites
  let offset = 0;

  for (let i = 0; i < message.length; i++) {
    // Sumar c√≥digos de caracteres y usar posici√≥n como multiplicador
    offset += message.charCodeAt(i) * (i + 1);
  }

  // Asegurar que el offset sea razonable (m√°ximo 1 hora)
  const maxOffset = 3600;
  offset = offset % maxOffset;

  // Calcular timestamp optimizado final
  return currentTimestamp + offset;
}
```

## üåê Manejo de CORS

Para permitir que tu mini app sea usada desde diferentes dominios y plataformas, necesitas manejar peticiones preflight de CORS:

```typescript title="Handler CORS OPTIONS"
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 204, // Sin Contenido
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers':
        'Content-Type, Authorization, X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Date, X-Api-Version',
    },
  });
}
```

<Admonition type="info" title="Por Qu√© Se Necesita OPTIONS">
  Cuando las plataformas intentan usar tu mini app desde un dominio diferente, los navegadores
  primero env√≠an una **petici√≥n OPTIONS** para verificar si se permiten peticiones cross-origin.
  Este handler le dice al navegador que tu API acepta peticiones de cualquier dominio.
</Admonition>

## üß™ Probando tu Mini App

### Opci√≥n 1: App Sherry Social

<div
  style={{
    padding: '1rem',
    backgroundColor: 'var(--ifm-color-info-contrast-background)',
    borderLeft: '4px solid var(--ifm-color-info)',
    borderRadius: '4px',
    margin: '1rem 0',
  }}
>
  <strong>Pruebas en Producci√≥n</strong>
  <ol>
    <li>
      Ve a{' '}
      <a href="https://app.sherry.social/home" target="_blank">
        https://app.sherry.social/home
      </a>
    </li>
    <li>En el campo de direcci√≥n, ingresa la URL de tu endpoint GET</li>
    <li>
      Ejemplo: <code>http://localhost:3000/api/mi-app</code> (para desarrollo local)
    </li>
    <li>La plataforma renderizar√° autom√°ticamente tu mini app</li>
  </ol>
</div>

### Opci√≥n 2: Debugger de Sherry (Recomendado para Desarrollo)

<Admonition type="tip" title="Beneficios del Debugger">
  El debugger est√° espec√≠ficamente dise√±ado para **probar y debuggear** mini apps durante el
  desarrollo con m√∫ltiples m√©todos de entrada.
</Admonition>

<Admonition type="warning" title="Importante: Despliega Primero en Producci√≥n">
  Para probar tu mini app en el debugger, **primero debes desplegarla** en un proveedor de hosting
  como Vercel, Netlify, Railway, etc. El debugger necesita una **URL p√∫blica accesible** para poder
  cargar tu mini app. Si quieres probar localmente, usa el m√©todo **JSON** copiando la respuesta de
  tu endpoint GET local y peg√°ndola en el debugger.
</Admonition>

<Tabs>
<TabItem value="url" label="Prueba URL (Recomendado)" default>

1. **Despliega tu mini app** en un proveedor de hosting:
   - Vercel: `vercel --prod`
   - Netlify: Conecta tu repositorio
   - Railway, Render, etc.
2. **Prueba URL**:
   - Pega la URL de tu endpoint GET desplegado
   - Ejemplo: `https://mi-sherry-app.vercel.app/api/mi-app`
   - Haz clic en "Cargar" para renderizar tu mini app

</TabItem>
<TabItem value="json" label="Prueba JSON (Para Testing Local)">

1. Ve a [https://app.sherry.social/debugger](https://app.sherry.social/debugger)
2. **Para testing local √∫nicamente**:
   - Visita tu endpoint GET directamente: `http://localhost:3000/api/mi-app`
   - Copia toda la respuesta JSON
   - P√©gala en la entrada JSON del debugger
   - Esto es √∫til para probar metadata durante desarrollo

</TabItem>
<TabItem value="typescript" label="Prueba TypeScript">

1. Copia tu objeto metadata de tu c√≥digo TypeScript
2. P√©galo directamente en el debugger
3. Bueno para iteraci√≥n r√°pida en la estructura de metadata

</TabItem>
</Tabs>

### Proceso de Pruebas Paso a Paso

1. **Desarrollar Localmente**

   - Ejecutar `npm run dev`
   - Probar en `localhost:3000/api/mi-app`

2. **Desplegar en Producci√≥n**

   - Usar Vercel, Netlify, etc.
   - Obtener URL p√∫blica

3. **Probar en Debugger**

   - Usar URL p√∫blica del despliegue
   - Verificar renderizado completo

4. **Probar Funcionalidad**
   - Completar formulario y probar POST
   - Verificar transacci√≥n generada

## üèÜ Gu√≠as del Minithon

### Qu√© Hace una Presentaci√≥n Ganadora del Minithon

<Tabs>
<TabItem value="technical" label="Requisitos T√©cnicos" default>

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
    gap: '1rem',
  }}
>
  <div style={{ padding: '1rem', border: '2px solid #10b981', borderRadius: '8px' }}>
    <h4>Interacci√≥n con Contratos Inteligentes</h4>
    <p>Funcionalidad significativa m√°s all√° de transferencias simples</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #10b981', borderRadius: '8px' }}>
    <h4>L√≥gica de Negocio Personalizada</h4>
    <p>Algoritmos √∫nicos que agregan valor real</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #10b981', borderRadius: '8px' }}>
    <h4>M√∫ltiples Par√°metros</h4>
    <p>Manejo sofisticado de datos</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #10b981', borderRadius: '8px' }}>
    <h4>Manejo de Errores</h4>
    <p>Mensajes de error amigables para el usuario</p>
  </div>
</div>

</TabItem>
<TabItem value="creativity" label="Factores de Creatividad">

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
    gap: '1rem',
  }}
>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Casos de Uso √önicos</h4>
    <p>Que resuelvan problemas reales</p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Algoritmos Innovadores</h4>
    <p>O procesamiento de datos</p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Combinaciones de Par√°metros Interesantes</h4>
    <p>Que aporten funcionalidad √∫til</p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Aplicaciones Pr√°cticas</h4>
    <p>Para usuarios reales</p>
  </div>
</div>

</TabItem>
<TabItem value="examples" label="Buenas Ideas">

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
    gap: '1rem',
  }}
>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Herramientas DeFi</h4>
    <p>
      Calculadoras de rendimiento personalizadas, rebalanceo de portafolio, estrategias
      automatizadas
    </p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Gaming</h4>
    <p>Mec√°nicas de juego on-chain, interacciones NFT, sistemas de puntuaci√≥n</p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Social</h4>
    <p>Mensajer√≠a descentralizada, sistemas de reputaci√≥n, herramientas comunitarias</p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Productividad</h4>
    <p>Gesti√≥n de tareas con recompensas de tokens, herramientas colaborativas</p>
  </div>
</div>

</TabItem>
</Tabs>

### Qu√© No Ser√° Aceptado en el Minithon

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
    gap: '1rem',
    margin: '1rem 0',
  }}
>
  <div style={{ padding: '1rem', border: '2px solid #dc2626', borderRadius: '8px' }}>
    <h4>Transferencias Simples de Tokens</h4>
    <p>Usa nuestro TransferAction en su lugar</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #dc2626', borderRadius: '8px' }}>
    <h4>Ejemplos Copiados y Pegados</h4>
    <p>Sin modificaciones significativas</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #dc2626', borderRadius: '8px' }}>
    <h4>Sin Contratos Inteligentes</h4>
    <p>Las mini apps deben interactuar con contratos</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #dc2626', borderRadius: '8px' }}>
    <h4>Implementaciones Rotas</h4>
    <p>Deben funcionar de extremo a extremo</p>
  </div>
</div>

## üîß Resoluci√≥n de Problemas

<Tabs>
<TabItem value="get-errors" label="Problemas del Endpoint GET" default>

### Error: "Fall√≥ la validaci√≥n de metadata"

**S√≠ntomas**: La mini app no carga en el debugger

<Admonition type="danger" title="Soluciones">
  - Verifica que todos los campos requeridos est√©n presentes en la metadata - Confirma que los tipos
  de datos coincidan con el formato esperado - Usa `createMetadata()` para validar la estructura -
  Revisa la consola para errores espec√≠ficos de validaci√≥n
</Admonition>

```typescript title="Debug de Metadata"
try {
  const validated = createMetadata(metadata);
  console.log('Validaci√≥n de metadata exitosa:', validated);
} catch (error) {
  console.error('Fall√≥ la validaci√≥n de metadata:', error);
}
```

### Error: "La pol√≠tica CORS bloquea la petici√≥n"

**S√≠ntomas**: "El acceso a fetch ha sido bloqueado por la pol√≠tica CORS"

```typescript title="Headers CORS Correctos"
headers: {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
}
```

</TabItem>
<TabItem value="post-errors" label="Problemas del Endpoint POST">

### Error: "Par√°metro requerido"

**S√≠ntomas**: Error sobre par√°metros faltantes

```typescript title="Debug de Par√°metros"
console.log('Todos los par√°metros:', Object.fromEntries(searchParams.entries()));
console.log('Par√°metro mensaje:', searchParams.get('mensaje'));
```

### Error: "Fall√≥ la serializaci√≥n de transacci√≥n"

**S√≠ntomas**: Error durante la llamada serialize()

<Admonition type="caution" title="Correcciones Comunes">
  - Usa `BigInt(1000000)` no `1000000` para n√∫meros grandes - Verifica que chainId sea correcto para
  la red objetivo - Aseg√∫rate de que todos los campos requeridos de transacci√≥n est√©n presentes -
  Para llamadas a contratos, verifica que el ABI coincida con el contrato desplegado
</Admonition>

</TabItem>
<TabItem value="contract-errors" label="Problemas de Contratos Inteligentes">

### Error: "Funci√≥n ABI no encontrada"

**S√≠ntomas**: Error sobre funci√≥n faltante o incorrecta

<Admonition type="info" title="Pasos de Verificaci√≥n">
  - Verifica que el nombre de la funci√≥n coincida exactamente con el contrato (sensible a
  may√∫sculas) - Confirma que la funci√≥n sea p√∫blica en el contrato inteligente - Aseg√∫rate de que el
  ABI est√© completo e incluya la funci√≥n - Verifica que los tipos de par√°metros coincidan con la
  firma de la funci√≥n del contrato
</Admonition>

### Error: "Direcci√≥n de contrato inv√°lida"

**S√≠ntomas**: La transacci√≥n falla con errores relacionados a la direcci√≥n

- Verifica que el contrato est√© desplegado en la red correcta (Fuji testnet)
- Confirma que la direcci√≥n est√© correctamente formateada (comienza con 0x)
- Aseg√∫rate de tener la direcci√≥n correcta del contrato para tu red
- Verifica que el contrato est√© verificado en el explorador de blockchain

</TabItem>
</Tabs>

## üöÄ Ejemplo de C√≥digo Completo

Aqu√≠ tienes un archivo de ruta completo, **listo para minithon** que demuestra todos los conceptos:

```typescript title="app/api/mi-app/route.ts - Ejemplo Completo"
import { NextRequest, NextResponse } from 'next/server';
import { avalancheFuji } from 'viem/chains';
import { createMetadata, Metadata, ValidatedMetadata, ExecutionResponse } from '@sherrylinks/sdk';
import { serialize, TransactionSerializable, encodeFunctionData } from 'wagmi';
import { abi } from '@/blockchain/abi';

const CONTRACT_ADDRESS = '0xTuContratoInteligenteEnFuji';

export async function GET(req: NextRequest) {
  try {
    const host = req.headers.get('host') || 'localhost:3000';
    const protocol = req.headers.get('x-forwarded-proto') || 'http';
    const serverUrl = `${protocol}://${host}`;

    const metadata: Metadata = {
      url: 'https://sherry.social',
      icon: 'https://avatars.githubusercontent.com/u/117962315',
      title: 'Mensaje con Timestamp',
      baseUrl: serverUrl,
      description:
        'Almacena un mensaje con un timestamp optimizado calculado por nuestro algoritmo',
      actions: [
        {
          type: 'dynamic',
          label: 'Almacenar Mensaje',
          description:
            'Almacena tu mensaje con un timestamp personalizado calculado para almacenamiento √≥ptimo',
          chains: { source: 'fuji' },
          path: `/api/mi-app`,
          params: [
            {
              name: 'mensaje',
              label: '¬°Tu Mensaje Hermano!',
              type: 'text',
              required: true,
              description: 'Ingresa el mensaje que quieres almacenar en la blockchain',
            },
          ],
        },
      ],
    };

    const validated: ValidatedMetadata = createMetadata(metadata);

    return NextResponse.json(validated, {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      },
    });
  } catch (error) {
    return NextResponse.json({ error: 'Error al crear metadata' }, { status: 500 });
  }
}

export async function POST(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const message = searchParams.get('mensaje');

    if (!message) {
      return NextResponse.json(
        { error: 'Message parameter is required' },
        {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        },
      );
    }

    // L√≥gica de negocio personalizada
    const optimizedTimestamp = calculateOptimizedTimestamp(message);

    // Interacci√≥n con contrato inteligente
    const data = encodeFunctionData({
      abi: abi,
      functionName: 'storeMessage',
      args: [message, BigInt(optimizedTimestamp)],
    });

    const tx: TransactionSerializable = {
      to: CONTRACT_ADDRESS,
      data: data,
      chainId: avalancheFuji.id,
      type: 'legacy',
    };

    const serialized = serialize(tx);

    const resp: ExecutionResponse = {
      serializedTransaction: serialized,
      chainId: avalancheFuji.name,
    };

    return NextResponse.json(resp, {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    });
  } catch (error) {
    console.error('Error en petici√≥n POST:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers':
        'Content-Type, Authorization, X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Date, X-Api-Version',
    },
  });
}

// Algoritmo personalizado - aqu√≠ es donde agregas tu valor √∫nico
function calculateOptimizedTimestamp(message: string): number {
  const currentTimestamp = Math.floor(Date.now() / 1000);

  let offset = 0;

  for (let i = 0; i < message.length; i++) {
    offset += message.charCodeAt(i) * (i + 1);
  }

  const maxOffset = 3600;
  offset = offset % maxOffset;

  return currentTimestamp + offset;
}
```

## üìö Repositorio de Ejemplos

<Admonition type="info" title="Ejemplos Completos Disponibles">
  Puedes encontrar ejemplos completos de trabajo en nuestro repositorio:
  [SherryLabs/sherry-example](https://github.com/SherryLabs/sherry-example)
</Admonition>

Este repositorio contiene:

- Tanto ejemplos de transferencia simple como de contrato inteligente
- C√≥digo completo de contrato inteligente con fuente Solidity
- Scripts de despliegue y configuraci√≥n
- Archivos ABI e instrucciones de configuraci√≥n
- Ejemplos de m√∫ltiples par√°metros
- Utilidades avanzadas de prueba
- Documentaci√≥n completa

## üéØ Pr√≥ximos Pasos

<Tabs>
<TabItem value="learning" label="Para Aprender" default>

1. **Comienza con el ejemplo de transferencia simple** para entender el flujo
2. **Pasa al ejemplo de contrato inteligente** una vez que te sientas c√≥modo
3. **Experimenta con diferentes** tipos de par√°metros y validaciones
4. **Prueba minuciosamente** usando el debugger

</TabItem>
<TabItem value="minithon" label="Para Participantes del Minithon">

1. **Omite la transferencia simple** - ve directamente a la interacci√≥n con contratos inteligentes
2. **Dise√±a tu algoritmo √∫nico** - ¬øqu√© problema vas a resolver?
3. **Planifica tu contrato inteligente** - ¬øqu√© funciones y datos necesitas?
4. **Crea m√∫ltiples par√°metros** - hazlo sofisticado y √∫til
5. **Prueba extensivamente** - aseg√∫rate de que todo funcione perfectamente
6. **Documenta tu innovaci√≥n** - explica por qu√© tu soluci√≥n es √∫nica

</TabItem>
<TabItem value="deployment" label="Consideraciones de Despliegue">

- **Desarrollo Local**: Usa `http://localhost:3000` para pruebas
- **Producci√≥n**: Despliega en Vercel, Netlify, o tu plataforma preferida
- **Dominios Personalizados**: Actualiza las URLs de tu metadata para coincidir con tu dominio
- **Variables de Entorno**: Almacena datos sensibles como claves privadas de forma segura
- **Redes de Prueba**: Comienza con Fuji testnet, luego pasa a mainnet

</TabItem>
</Tabs>

---

<div
  style={{
    textAlign: 'center',
    padding: '2rem',
    backgroundColor: 'var(--ifm-color-primary-contrast-background)',
    borderRadius: '8px',
    margin: '2rem 0',
  }}
>
  <h2>üöÄ ¬øListo para Construir Algo Incre√≠ble?</h2>
  <p>
    Recuerda, la clave para un env√≠o exitoso al minithon no es solo hacer que funcione, sino hacerlo{' '}
    <strong>√∫til</strong>, <strong>innovador</strong> y <strong>t√©cnicamente impresionante</strong>.
    Enf√≥cate en resolver problemas reales con soluciones creativas que demuestren el poder de la
    tecnolog√≠a blockchain combinada con una gran experiencia de usuario.
  </p>
  <p>
    <strong>¬°Buena suerte con el desarrollo de tu mini app y el env√≠o al minithon! üèÜ</strong>
  </p>
</div>
